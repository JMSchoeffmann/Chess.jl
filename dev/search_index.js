var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference-1","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Boards-1","page":"API Reference","title":"Boards","text":"","category":"section"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"Board\nstartboard\nfromfen\nfen\npprint(b::Board)\nlichessurl\nlichess(b::Board)\npieceon\nsidetomove\nepsquare\nkingsquare\npieces\npawns\nknights\nbishops\nrooks\nqueens\nkings\nbishoplike\nrooklike\noccupiedsquares\nemptysquares\ncancastlekingside\ncancastlequeenside\nbishopattacks(b::Board, s::Square)\nrookattacks(b::Board, s::Square)\nqueenattacks(b::Board, s::Square)\nisattacked\nattacksto\nattacksfrom\nsee\nlastmove\nischeck\nischeckmate(b::Board)\nisstalemate\nismaterialdraw\nisrule50draw\nisdraw(b::Board)\nisterminal(b::Board)\npinned\ndomove(b::Board, m::Move)\ndomove!(b::Board, m::Move)\ndonullmove(b::Board)\ndonullmove!(b::Board)\nundomove!\ndomoves(b::Board, moves::Vararg{Move})\ndomoves!(b::Board, moves::Vararg{Move})\nMoveList\npush!(list::MoveList, m::Move)\nrecycle!\nmoves\nmovecount\nhaslegalmoves\nperft\ndivide\nflip\nSTART_FEN","category":"page"},{"location":"api/#Chess.Board","page":"API Reference","title":"Chess.Board","text":"Board\n\nType representing a chess board.\n\nA chess board is most commonly obtained from a FEN string (using the fromfen() function), from the startboard() function (which returns a board in the usual chess starting position), or by making a move on some other chess board.\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.startboard","page":"API Reference","title":"Chess.startboard","text":"startboard()\n\nGives a Board object with the standard chess initial position.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.fromfen","page":"API Reference","title":"Chess.fromfen","text":"fromfen(fen::String)\n\nTry to create a Board value from a FEN string.\n\nIf the supplied string doesn't represent a valid board position, this function returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.fen","page":"API Reference","title":"Chess.fen","text":"fen(b::Board)\n\nConvert a board to a FEN string.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.pprint-Tuple{Board}","page":"API Reference","title":"Chess.pprint","text":"pprint(b::Board, color = false, highlight = SS_EMPTY, unicode = false)\n\nPretty-print a Board to the standard output.\n\nOn terminals with 24-bit color support, use color = true for a colored board. Use the parameter highlight to include a SquareSet you want to be highlighted.\n\nUse unicode = true for Unicode piece output, if your font and terminal supports it.\n\nExamples\n\njulia> pprint(startboard(), highlight = SquareSet(SQ_D4, SQ_E4, SQ_D5, SQ_E5))\n+---+---+---+---+---+---+---+---+\n| r | n | b | q | k | b | n | r |\n+---+---+---+---+---+---+---+---+\n| p | p | p | p | p | p | p | p |\n+---+---+---+---+---+---+---+---+\n|   |   |   |   |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   |   | * | * |   |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   |   | * | * |   |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   |   |   |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n| P | P | P | P | P | P | P | P |\n+---+---+---+---+---+---+---+---+\n| R | N | B | Q | K | B | N | R |\n+---+---+---+---+---+---+---+---+\nrnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq -\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.lichessurl","page":"API Reference","title":"Chess.lichessurl","text":"lichessurl(b::Board)\n\nReturns an URL for opening the board in lichess.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.lichess-Tuple{Board}","page":"API Reference","title":"Chess.lichess","text":"lichess(b::Board)\n\nOpens the board in lichess.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.pieceon","page":"API Reference","title":"Chess.pieceon","text":"pieceon(b::Board, s::Square)\npieceon(b::Board, f::SquareFile, r::SquareRank)\npieceon(b::Board, s::String)\n\nFind the piece on the given square of the board.\n\nExamples\n\njulia> b = startboard();\n\njulia> pieceon(b, SQ_E1)\nPIECE_WK\n\njulia> pieceon(b, FILE_B, RANK_8)\nPIECE_BN\n\njulia> pieceon(b, SQ_B5)\nEMPTY\n\njulia> pieceon(b, \"d8\")\nPIECE_BQ\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.sidetomove","page":"API Reference","title":"Chess.sidetomove","text":"sidetomove(b::Board)\n\nThe current side to move, WHITE or BLACK.\n\nExamples\n\njulia> b = startboard();\n\njulia> b2 = domove(b, \"e4\");\n\njulia> sidetomove(b)\nWHITE\n\njulia> sidetomove(b2)\nBLACK\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.epsquare","page":"API Reference","title":"Chess.epsquare","text":"epsquare(b::Board)\n\nThe square on which an en passant capture is possible, or SQ_NONE.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.kingsquare","page":"API Reference","title":"Chess.kingsquare","text":"kingsquare(b::Board, c::PieceColor)\n\nThe square of the king for the given side.\n\nExamples\n\njulia> b = startboard();\n\njulia> kingsquare(b, WHITE)\nSQ_E1\n\njulia> kingsquare(b, BLACK)\nSQ_E8\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.pieces","page":"API Reference","title":"Chess.pieces","text":"pieces(b::Board, c::PieceColor)\npieces(b::Board, t::PieceType)\npieces(b::Board, c::PieceColor, t::PieceType)\npieces(b::Board, p::Piece)\n\nObtain the set of squares containing various kinds of pieces.\n\nExamples\n\njulia> b = startboard();\n\njulia> pieces(b, WHITE) == SS_RANK_1 ∪ SS_RANK_2\ntrue\n\njulia> pieces(b, ROOK) == SquareSet(SQ_A1, SQ_H1, SQ_A8, SQ_H8)\ntrue\n\njulia> pieces(b, BLACK, PAWN) == SS_RANK_7\ntrue\n\njulia> pieces(b, PIECE_WB)\nSquareSet:\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  #  -  -  #  -  -\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.pawns","page":"API Reference","title":"Chess.pawns","text":"pawns(b::Board)\n\nThe set of squares containing pawns of either color.\n\nExamples\n\njulia> b = startboard();\n\njulia> pawns(b) == SS_RANK_2 ∪ SS_RANK_7\ntrue\n\n\n\n\n\npawns(b::Board, c::PieceColor)\n\nThe set of squares containing pawns of the given color.\n\nExamples\n\njulia> b = startboard();\n\njulia> pawns(b, WHITE) == SS_RANK_2\ntrue\n\njulia> pawns(b, BLACK) == SS_RANK_7\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.knights","page":"API Reference","title":"Chess.knights","text":"knights(b::Board)\n\nThe set of squares containing knights of either color.\n\nExamples\n\njulia> b = startboard();\n\njulia> knights(b) == SquareSet(SQ_B1, SQ_G1, SQ_B8, SQ_G8)\ntrue\n\n\n\n\n\nknights(b::Board, c::PieceColor)\n\nThe set of squares containing knights of the given color.\n\nExamples\n\njulia> b = startboard();\n\njulia> knights(b, WHITE) == SquareSet(SQ_B1, SQ_G1)\ntrue\n\njulia> knights(b, BLACK) == SquareSet(SQ_B8, SQ_G8)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.bishops","page":"API Reference","title":"Chess.bishops","text":"bishops(b::Board)\n\nThe set of squares containing bishops of either color.\n\nExamples\n\njulia> b = startboard();\n\njulia> bishops(b) == SquareSet(SQ_C1, SQ_F1, SQ_C8, SQ_F8)\ntrue\n\n\n\n\n\nbishops(b::Board, c::PieceColor)\n\nThe set of squares containing bishops of the given color.\n\nExamples\n\njulia> b = startboard();\n\njulia> bishops(b, WHITE) == SquareSet(SQ_C1, SQ_F1)\ntrue\n\njulia> bishops(b, BLACK) == SquareSet(SQ_C8, SQ_F8)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.rooks","page":"API Reference","title":"Chess.rooks","text":"rooks(b::Board)\n\nThe set of squares containing rooks of either color.\n\nExamples\n\njulia> b = startboard();\n\njulia> rooks(b) == SquareSet(SQ_A1, SQ_H1, SQ_A8, SQ_H8)\ntrue\n\n\n\n\n\nrooks(b::Board, c::PieceColor)\n\nThe set of squares containing rooks of the given color.\n\nExamples\n\njulia> b = startboard();\n\njulia> rooks(b, WHITE) == SquareSet(SQ_A1, SQ_H1)\ntrue\n\njulia> rooks(b, BLACK) == SquareSet(SQ_A8, SQ_H8)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.queens","page":"API Reference","title":"Chess.queens","text":"queens(b::Board)\n\nThe set of squares containing queens of either color.\n\nExamples\n\njulia> b = startboard();\n\njulia> queens(b) == SquareSet(SQ_D1, SQ_D8)\ntrue\n\n\n\n\n\nqueens(b::Board, c::PieceColor)\n\nThe set of squares containing queens of the given color.\n\nExamples\n\njulia> b = startboard();\n\njulia> queens(b, WHITE) == SquareSet(SQ_D1)\ntrue\n\njulia> queens(b, BLACK) == SquareSet(SQ_D8)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.kings","page":"API Reference","title":"Chess.kings","text":"kings(b::Board)\n\nThe set of squares containing kings of either color.\n\nExamples\n\njulia> b = startboard();\n\njulia> kings(b) == SquareSet(SQ_E1, SQ_E8)\ntrue\n\n\n\n\n\nkings(b::Board, c::PieceColor)\n\nThe set of squares containing kings of the given color.\n\nUnless something is very wrong, this set should always contain exactly one square.\n\nExamples\n\njulia> b = startboard();\n\njulia> kings(b, WHITE) == SquareSet(SQ_E1)\ntrue\n\njulia> kings(b, BLACK) == SquareSet(SQ_E8)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.bishoplike","page":"API Reference","title":"Chess.bishoplike","text":"bishoplike(b::Board)\n\nThe set of squares containing bishoplike pieces of either color.\n\nThe bishoplike pieces are the pieces that can move like a bishop, i.e. bishops and queens.\n\nExamples\n\njulia> b = startboard();\n\njulia> bishoplike(b) == SquareSet(SQ_C1, SQ_D1, SQ_F1, SQ_C8, SQ_D8, SQ_F8)\ntrue\n\n\n\n\n\nbishoplike(b::Board, c::PieceColor)\n\nThe set of squares containing bishoplike pieces of the given color.\n\nThe bishoplike pieces are the pieces that can move like a bishop, i.e. bishops and queens.\n\nExamples\n\njulia> b = startboard();\n\njulia> bishoplike(b, WHITE) == SquareSet(SQ_C1, SQ_D1, SQ_F1)\ntrue\n\njulia> bishoplike(b, BLACK) == SquareSet(SQ_C8, SQ_D8, SQ_F8)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.rooklike","page":"API Reference","title":"Chess.rooklike","text":"rooklike(b::Board)\n\nThe set of squares containing rooklike pieces of either color.\n\nThe rooklike pieces are the pieces that can move like a rook, i.e. rooks and queens.\n\nExamples\n\njulia> b = startboard();\n\njulia> rooklike(b) == SquareSet(SQ_A1, SQ_D1, SQ_H1, SQ_A8, SQ_D8, SQ_H8)\ntrue\n\n\n\n\n\nrooklike(b::Board, c::PieceColor)\n\nThe set of squares containing rooklike pieces of the given color.\n\nThe rooklike pieces are the pieces that can move like a rook, i.e. rooks and queens.\n\nExamples\n\njulia> b = startboard();\n\njulia> rooklike(b, WHITE) == SquareSet(SQ_A1, SQ_D1, SQ_H1)\ntrue\n\njulia> rooklike(b, BLACK) == SquareSet(SQ_A8, SQ_D8, SQ_H8)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.occupiedsquares","page":"API Reference","title":"Chess.occupiedsquares","text":"occupiedsquares(b::Board)\nemptysquares(b::Board)\n\nThe set of all occupied or empty squares on the board.\n\nExamples\n\njulia> b = startboard();\n\njulia> occupiedsquares(b) == pieces(b, WHITE) ∪ pieces(b, BLACK)\ntrue\n\njulia> emptysquares(b) == SS_RANK_3 ∪ SS_RANK_4 ∪ SS_RANK_5 ∪ SS_RANK_6\ntrue\n\njulia> isempty(emptysquares(b) ∩ occupiedsquares(b))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.emptysquares","page":"API Reference","title":"Chess.emptysquares","text":"occupiedsquares(b::Board)\nemptysquares(b::Board)\n\nThe set of all occupied or empty squares on the board.\n\nExamples\n\njulia> b = startboard();\n\njulia> occupiedsquares(b) == pieces(b, WHITE) ∪ pieces(b, BLACK)\ntrue\n\njulia> emptysquares(b) == SS_RANK_3 ∪ SS_RANK_4 ∪ SS_RANK_5 ∪ SS_RANK_6\ntrue\n\njulia> isempty(emptysquares(b) ∩ occupiedsquares(b))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.cancastlekingside","page":"API Reference","title":"Chess.cancastlekingside","text":"cancastlekingside(b::Board, c::PieceColor)\n\nDetermine whether the given side still has the right to castle kingside.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.cancastlequeenside","page":"API Reference","title":"Chess.cancastlequeenside","text":"cancastlequeenside(b::Board, c::PieceColor)\n\nDetermine whether the given side still has the right to castle queenside.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.bishopattacks-Tuple{Board,Square}","page":"API Reference","title":"Chess.bishopattacks","text":"bishopattacks(b::Board, s::Square)\n\nThe set of squares a bishop on square s would attack on this board.\n\nBoth empty squares and squares occupied by enemy or friendly pieces are included in the set.\n\nExamples\n\njulia> b = fromfen(\"5k2/8/4q3/8/2B5/8/4P3/3K4 w - -\");\n\njulia> pprint(b, highlight=bishopattacks(b, SQ_C4))\n+---+---+---+---+---+---+---+---+\n|   |   |   |   |   | k |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   |   |   |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n| * |   |   |   |*q*|   |   |   |\n+---+---+---+---+---+---+---+---+\n|   | * |   | * |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   | B |   |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n|   | * |   | * |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n| * |   |   |   |*P*|   |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   |   | K |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n5k2/8/4q3/8/2B5/8/4P3/3K4 w - -\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.rookattacks-Tuple{Board,Square}","page":"API Reference","title":"Chess.rookattacks","text":"rookattacks(b::Board, s::Square)\n\nThe set of squares a rook on square s would attack on this board.\n\nBoth empty squares and squares occupied by enemy or friendly pieces are included in the set.\n\nExamples\n\njulia> b = fromfen(\"2r2k2/8/8/8/2R3P1/8/4P3/3K4 w - -\");\n\njulia> pprint(b, highlight=rookattacks(b, SQ_C4))\n+---+---+---+---+---+---+---+---+\n|   |   |*r*|   |   | k |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   | * |   |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   | * |   |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   | * |   |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n| * | * | R | * | * | * |*P*|   |\n+---+---+---+---+---+---+---+---+\n|   |   | * |   |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   | * |   | P |   |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   | * | K |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n2r2k2/8/8/8/2R3P1/8/4P3/3K4 w - -\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.queenattacks-Tuple{Board,Square}","page":"API Reference","title":"Chess.queenattacks","text":"queenattacks(b::Board, s::Square)\n\nThe set of squares a queen on square s would attack on this board.\n\nBoth empty squares and squares occupied by enemy or friendly pieces are included in the set.\n\nExamples\n\njulia> b = fromfen(\"2r2k2/8/8/8/2Q3P1/8/4P3/3K4 w - -\");\n\njulia> pprint(b, highlight=queenattacks(b, SQ_C4))\n+---+---+---+---+---+---+---+---+\n|   |   |*r*|   |   | k | * |   |\n+---+---+---+---+---+---+---+---+\n|   |   | * |   |   | * |   |   |\n+---+---+---+---+---+---+---+---+\n| * |   | * |   | * |   |   |   |\n+---+---+---+---+---+---+---+---+\n|   | * | * | * |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n| * | * | Q | * | * | * |*P*|   |\n+---+---+---+---+---+---+---+---+\n|   | * | * | * |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n| * |   | * |   |*P*|   |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   | * | K |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n2r2k2/8/8/8/2Q3P1/8/4P3/3K4 w - -\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.isattacked","page":"API Reference","title":"Chess.isattacked","text":"isattacked(b::Board, s::Square, side::PieceColor)\n\nDetermine whether the given square is attacked by the given side.\n\nExamples\n\njulia> b = startboard();\n\njulia> isattacked(b, SQ_F3, WHITE)\ntrue\n\njulia> isattacked(b, SQ_F3, BLACK)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.attacksto","page":"API Reference","title":"Chess.attacksto","text":"attacksto(b::Board, s::Square)\n\nThe set of squares containing pieces of either color which attack square s.\n\nExamples\n\njulia> b = fromfen(\"r1bqkbnr/pppp1ppp/2n5/4p3/3PP3/5N2/PPP2PPP/RNBQKB1R b KQkq - 0 3\");\n\njulia> pprint(b, highlight=attacksto(b, SQ_D4))\n+---+---+---+---+---+---+---+---+\n| r |   | b | q | k | b | n | r |\n+---+---+---+---+---+---+---+---+\n| p | p | p | p |   | p | p | p |\n+---+---+---+---+---+---+---+---+\n|   |   |*n*|   |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   |   |   |*p*|   |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   |   | P | P |   |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   |   |   |   |*N*|   |   |\n+---+---+---+---+---+---+---+---+\n| P | P | P |   |   | P | P | P |\n+---+---+---+---+---+---+---+---+\n| R | N | B |*Q*| K | B |   | R |\n+---+---+---+---+---+---+---+---+\nr1bqkbnr/pppp1ppp/2n5/4p3/3PP3/5N2/PPP2PPP/RNBQKB1R b KQkq -\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.attacksfrom","page":"API Reference","title":"Chess.attacksfrom","text":"attacksfrom(b::Board, s::Square)\n\nThe set of squares attacked by the piece on s.\n\nBoth empty squares, squares containing enemy pieces, and squares containing friendly pieces are included.\n\nExamples\n\njulia> b = fromfen(\"r1bqkbnr/pppp1ppp/2n5/4p3/3PP3/5N2/PPP2PPP/RNBQKB1R b KQkq - 0 3\");\n\njulia> pprint(b, highlight=attacksfrom(b, SQ_F1))\n+---+---+---+---+---+---+---+---+\n| r |   | b | q | k | b | n | r |\n+---+---+---+---+---+---+---+---+\n| p | p | p | p |   | p | p | p |\n+---+---+---+---+---+---+---+---+\n| * |   | n |   |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n|   | * |   |   | p |   |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   | * | P | P |   |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   |   | * |   | N |   |   |\n+---+---+---+---+---+---+---+---+\n| P | P | P |   | * | P |*P*| P |\n+---+---+---+---+---+---+---+---+\n| R | N | B | Q | K | B |   | R |\n+---+---+---+---+---+---+---+---+\nr1bqkbnr/pppp1ppp/2n5/4p3/3PP3/5N2/PPP2PPP/RNBQKB1R b KQkq -\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.see","page":"API Reference","title":"Chess.see","text":"see(b::Board, m::Move)::Int\nsee(b::Board, m::String)::Int\n\nStatic exchange evaluator.\n\nThis function estimates the material gain/loss of a move without doing any search, just looking at the attackers and defenders of the destination square, including X-ray attackers and defenders. It does not consider pins, overloaded pieces, etc., and is therefore only reliable as a very rough guess.\n\nExamples\n\njulia> b = fromfen(\"8/4k3/8/4p3/8/2BK4/8/q7 w - - 0 1\")\nBoard (8/4k3/8/4p3/8/2BK4/8/q7 w - -):\n -  -  -  -  -  -  -  -\n -  -  -  -  k  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  p  -  -  -\n -  -  -  -  -  -  -  -\n -  -  B  K  -  -  -  -\n -  -  -  -  -  -  -  -\n q  -  -  -  -  -  -  -\n\njulia> see(b, \"Bxe5\")\n-2\n\njulia> b = fromfen(\"7q/4k1b1/3p4/4n3/8/2BK1N2/4R3/4R3 w - - 0 1\")\nBoard (7q/4k1b1/3p4/4n3/8/2BK1N2/4R3/4R3 w - -):\n -  -  -  -  -  -  -  q\n -  -  -  -  k  -  b  -\n -  -  -  p  -  -  -  -\n -  -  -  -  n  -  -  -\n -  -  -  -  -  -  -  -\n -  -  B  K  -  N  -  -\n -  -  -  -  R  -  -  -\n -  -  -  -  R  -  -  -\n\njulia> see(b, \"Nxe5\")\n1\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.lastmove","page":"API Reference","title":"Chess.lastmove","text":"lastmove(b::Board)\n\nThe last move that was played to reach this board position.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.ischeck","page":"API Reference","title":"Chess.ischeck","text":"ischeck(b::Board)\n\nDetermine whether the current side to move is in check.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.ischeckmate-Tuple{Board}","page":"API Reference","title":"Chess.ischeckmate","text":"ischeckmate(b::Board)::Bool\n\nReturns true if the side to move is checkmated.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.isstalemate","page":"API Reference","title":"Chess.isstalemate","text":"isstalemate(b::Board)::Bool\n\nReturns true if the board is a stalemate position.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.ismaterialdraw","page":"API Reference","title":"Chess.ismaterialdraw","text":"ismaterialdraw(b::Board)::Bool\n\nReturns true if the position is a draw by material.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.isrule50draw","page":"API Reference","title":"Chess.isrule50draw","text":"isrule50draw(b::Board)::Bool\n\nReturns true if the position is drawn by the 50 moves rule.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.isdraw-Tuple{Board}","page":"API Reference","title":"Chess.isdraw","text":"isdraw(b::Board)::Bool\n\nReturns true if the position is an immediate draw.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.isterminal-Tuple{Board}","page":"API Reference","title":"Chess.isterminal","text":"isterminal(b::Board)::Bool\n\nReturns true if the game position is terminal, i.e. mate or immediate draw.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.pinned","page":"API Reference","title":"Chess.pinned","text":"pinned(b::Board)\n\nThe set of squares containing pinned pieces for the current side to move.\n\nExamples\n\njulia> b = fromfen(\"2r4b/1kp5/8/2P1Q3/1P6/2K1P2r/8/8 w - -\");\n\njulia> pprint(b, highlight=pinned(b))\n+---+---+---+---+---+---+---+---+\n|   |   | r |   |   |   |   | b |\n+---+---+---+---+---+---+---+---+\n|   | k | p |   |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   |   |   |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   | P |   |*Q*|   |   |   |\n+---+---+---+---+---+---+---+---+\n|   | P |   |   |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   | K |   |*P*|   |   | r |\n+---+---+---+---+---+---+---+---+\n|   |   |   |   |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   |   |   |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n2r4b/1kp5/8/2P1Q3/1P6/2K1P2r/8/8 w - -\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.domove-Tuple{Board,Move}","page":"API Reference","title":"Chess.domove","text":"domove(b::Board, m::Move)\ndomove(b::Board, m::String)\n\nDo the move m on the board b, and return the new board.\n\nThe board b itself is left unchanged, a new board is returned. There is a much faster destructive function domove!() that should be called instead when high performance is required.\n\nIf the supplied move is a string, this function tries to parse the move as a UCI move first, then as a SAN move.\n\nIt's the caller's responsibility to make sure m is a legal move on this board.\n\nExamples\n\njulia> b = startboard();\n\njulia> domove(b, \"Nf3\")\nBoard (rnbqkbnr/pppppppp/8/8/8/5N2/PPPPPPPP/RNBQKB1R b KQkq -):\n r  n  b  q  k  b  n  r\n p  p  p  p  p  p  p  p\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  N  -  -\n P  P  P  P  P  P  P  P\n R  N  B  Q  K  B  -  R\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.domove!-Tuple{Board,Move}","page":"API Reference","title":"Chess.domove!","text":"domove!(b::Board, m::Move)\ndomove!(b::Board, m::String)\n\nDestructively modify the board b by making the move m.\n\nIf the supplied move is a string, this function tries to parse the move as a UCI move first, then as a SAN move.\n\nIt's the caller's responsibility to make sure the move m is legal.\n\nThe function returns a value of type UndoInfo. You'll need this if you want to later call undomove!() to take back the move and get the original position back.\n\nExamples\n\njulia> b = startboard();\n\njulia> domove!(b, \"d4\");\n\njulia> b\nBoard (rnbqkbnr/pppppppp/8/8/3P4/8/PPP1PPPP/RNBQKBNR b KQkq -):\n r  n  b  q  k  b  n  r\n p  p  p  p  p  p  p  p\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  P  -  -  -  -\n -  -  -  -  -  -  -  -\n P  P  P  -  P  P  P  P\n R  N  B  Q  K  B  N  R\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.donullmove-Tuple{Board}","page":"API Reference","title":"Chess.donullmove","text":"donullmove(b::Board)\n\nReturns an identical board with the side to move switched.\n\nThe board b itself is left unchanged. A new board is returned that is identical in every way except that the side to move is the opposite. In other words, the function has the effect of \"passing\" and giving the other player the chance to move.\n\nNote that this will result in an illegal position if the side to move at b is in check. It's the caller's responsibility to make sure donullmove is not used in that case.\n\nThere is a much faster destructive function donullmove! that should be called instead when high performance is required.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.donullmove!-Tuple{Board}","page":"API Reference","title":"Chess.donullmove!","text":"donullmove!(b::Board)\n\nDestructively modify the board b by swapping the side to move.\n\nThe board is left unchanged except that the side to move is changed. In other words, the function has the effect of \"passing\" and giving the other player the chance to move.\n\nNote that this will result in an illegal position if the side to move at b is in check. It's the caller's responsibility to make sure donullmove is not used in that case.\n\nThe function returns a value of type UndoInfo. You'll need this if you want to later call undomove!() to take back the move and get the original position back.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.undomove!","page":"API Reference","title":"Chess.undomove!","text":"undomove!(b::Board, u::UndoInfo)\n\nUndo a move earlier done by domove!().\n\nThe second parameter is the UndoInfo value returned by the earlier call to domove!().\n\nExamples\n\njulia> b = startboard();\n\njulia> u = domove!(b, \"c4\");\n\njulia> b\nBoard (rnbqkbnr/pppppppp/8/8/2P5/8/PP1PPPPP/RNBQKBNR b KQkq -):\n r  n  b  q  k  b  n  r\n p  p  p  p  p  p  p  p\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  P  -  -  -  -  -\n -  -  -  -  -  -  -  -\n P  P  -  P  P  P  P  P\n R  N  B  Q  K  B  N  R\n\njulia> undomove!(b, u);\n\njulia> b\nBoard (rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq -):\n r  n  b  q  k  b  n  r\n p  p  p  p  p  p  p  p\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n P  P  P  P  P  P  P  P\n R  N  B  Q  K  B  N  R\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.domoves-Tuple{Board,Vararg{Move,N} where N}","page":"API Reference","title":"Chess.domoves","text":"domoves(b::Board, moves::Vararg{Move})\ndomoves(b::Board, moves::Vararg{String})\n\nReturn the board achieved from a starting board b by making a sequence of moves.\n\nThe input board b is left unchanged.\n\nIf the supplied moves are strings, this function tries to parse the moves as UCI moves first, and as SAN moves if UCI move parsing fails.\n\nIt's the caller's responsibility to make sure all moves are legal. If a plain move is illegal, the consequences are undefined. If a move string cannot be parsed as an unambiguous legal move, the function throws an exception.\n\nThere is also a destructive version of this version, named domoves!\n\nExamples\n\njulia> b = startboard();\n\njulia> domoves(b, \"d4\", \"Nf6\", \"c4\", \"e6\", \"Nc3\", \"Bb4\")\nBoard (rnbqk2r/pppp1ppp/4pn2/8/1bPP4/2N5/PP2PPPP/R1BQKBNR w KQkq -):\n r  n  b  q  k  -  -  r\n p  p  p  p  -  p  p  p\n -  -  -  -  p  n  -  -\n -  -  -  -  -  -  -  -\n -  b  P  P  -  -  -  -\n -  -  N  -  -  -  -  -\n P  P  -  -  P  P  P  P\n R  -  B  Q  K  B  N  R\n\njulia> domoves(b, \"d4\", \"Nf6\", \"c5\")\nERROR: \"Illegal or ambiguous move: c5\"\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.domoves!-Tuple{Board,Vararg{Move,N} where N}","page":"API Reference","title":"Chess.domoves!","text":"domoves!(b::Board, moves::Vararg{Move})\ndomoves!(b::Board, moves::Vararg{String})\n\nDestructively modify the board b by making a sequence of moves.\n\nIf the supplied moves are strings, this function tries to parse the moves as UCI moves first, and as SAN moves if UCI move parsing fails.\n\nIt's the caller's responsibility to make sure all moves are legal. If a plain move is illegal, the consequences are undefined. If a move string cannot be parsed as an unambiguous legal move, the function throws an exception.\n\nThere is also a non-destructive version of this version, named domoves.\n\nExamples\n\njulia> b = startboard();\n\njulia> domoves!(b, \"e4\", \"c5\", \"Nf3\", \"d6\", \"d4\", \"cxd4\", \"Nxd4\", \"Nf6\", \"Nc3\");\n\njulia> b\nBoard (rnbqkb1r/pp2pppp/3p1n2/8/3NP3/2N5/PPP2PPP/R1BQKB1R b KQkq -):\n r  n  b  q  k  b  -  r\n p  p  -  -  p  p  p  p\n -  -  -  p  -  n  -  -\n -  -  -  -  -  -  -  -\n -  -  -  N  P  -  -  -\n -  -  N  -  -  -  -  -\n P  P  P  -  -  P  P  P\n R  -  B  Q  K  B  -  R\n\njulia> b = startboard();\n\njulia> domoves!(b, \"e4\", \"Qxe4+\")\nERROR: \"Illegal or ambiguous move: Qxe4+\"\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.MoveList","page":"API Reference","title":"Chess.MoveList","text":"MoveList\n\nAn iterable type containing a a list of moves, as produced by legal move generators.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.push!-Tuple{MoveList,Move}","page":"API Reference","title":"Base.push!","text":"push!(list::MoveList, m::Move)\n\nAdd a new move to the move list.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.recycle!","page":"API Reference","title":"Chess.recycle!","text":"recycle!(list::MoveList)\n\nRecycle the move list in order to re-use for generating new moves.\n\nThis is useful when you want to avoid allocating too much heap memory. If you have a MoveList lying around that you no longer need, consider reusing it instead of creating a new one the next time you need to generate some moves.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.moves","page":"API Reference","title":"Chess.moves","text":"moves(b::Board, list::MoveList)\nmoves(b::Board)\n\nObtain a list of all legal moves from this board.\n\nWhen performance is important, consider using the two-argument method that supplies a pre-allocated move list.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.movecount","page":"API Reference","title":"Chess.movecount","text":"movecount(b::Board)::Int\n\nThe number of legal moves from this board.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.haslegalmoves","page":"API Reference","title":"Chess.haslegalmoves","text":"haslegalmoves(b::Board)::Bool\n\nReturns true if the side to move has at least one legal move.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.perft","page":"API Reference","title":"Chess.perft","text":"perft(b::Board, depth::Int)\n\nDo a perft search to the given depth.\n\nSee https://www.chessprogramming.org/Perft.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.divide","page":"API Reference","title":"Chess.divide","text":"divide(b::Board, depth::Int)\n\nDo a divide search to debug the perft() function.\n\nSee https://www.chessprogramming.org/Perft.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.flip","page":"API Reference","title":"Chess.flip","text":"flip(b::Board)\n\nReturns an identical board, but flipped horizontally, and with the opposite side to move.\n\nExamples\n\njulia> b = domoves!(startboard(), \"d4\", \"Nf6\", \"c4\", \"e6\", \"Nc3\", \"Bb4\", \"e3\", \"O-O\")\nBoard (rnbq1rk1/pppp1ppp/4pn2/8/1bPP4/2N1P3/PP3PPP/R1BQKBNR w KQ -):\n r  n  b  q  -  r  k  -\n p  p  p  p  -  p  p  p\n -  -  -  -  p  n  -  -\n -  -  -  -  -  -  -  -\n -  b  P  P  -  -  -  -\n -  -  N  -  P  -  -  -\n P  P  -  -  -  P  P  P\n R  -  B  Q  K  B  N  R\n\njulia> flip(b)\nBoard (r1bqkbnr/pp3ppp/2n1p3/1Bpp4/8/4PN2/PPPP1PPP/RNBQ1RK1 b kq -):\n r  -  b  q  k  b  n  r\n p  p  -  -  -  p  p  p\n -  -  n  -  p  -  -  -\n -  B  p  p  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  P  N  -  -\n P  P  P  P  -  P  P  P\n R  N  B  Q  -  R  K  -\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.START_FEN","page":"API Reference","title":"Chess.START_FEN","text":"START_FEN\n\nThe FEN string of the standard chess opening position.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Games-1","page":"API Reference","title":"Games","text":"","category":"section"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"SimpleGame\nSimpleGame(startboard::Board=startboard())\nSimpleGame(startfen::String)\nGame\nGame()\nGame(startboard::Board)\nGame(startfen::String)\nGameHeader\nGameHeaders\nGameNode\nheadervalue\ndateplayed\nwhiteelo\nblackelo\nsetheadervalue!\nboard\ndomove!(g::SimpleGame, m::Move)\ndomoves!(g::SimpleGame, moves::Vararg{Union{Move, String}})\naddmove!\naddmoves!\nnextmove\nply\nisatbeginning\nisatend\nback!\nforward!\ntobeginning!\ntoend!\ntobeginningofvariation!\ntonode!\nisleaf\ncomment\nprecomment\nnag\naddcomment!\naddprecomment!\naddnag!\nremoveallchildren!\nremovenode!\nadddata!\nremovedata!\ncontinuations\nisdraw(g::SimpleGame)\nischeckmate(g::SimpleGame)\nisterminal(g::SimpleGame)","category":"page"},{"location":"api/#Chess.SimpleGame","page":"API Reference","title":"Chess.SimpleGame","text":"SimpleGame\n\nA type representing a simple game, with no support for comments or variations.\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.SimpleGame","page":"API Reference","title":"Chess.SimpleGame","text":"SimpleGame(startboard::Board=startboard())\n\nConstructor that creates a SimpleGame from the provided starting position.\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.SimpleGame-Tuple{String}","page":"API Reference","title":"Chess.SimpleGame","text":"SimpleGame(startfen::String)\n\nConstructor that creates a SimpleGame from the position given by the provided FEN string.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.Game","page":"API Reference","title":"Chess.Game","text":"Game\n\nType representing a chess game, with support for comments and variations.\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.Game-Tuple{}","page":"API Reference","title":"Chess.Game","text":"Game()\n\nConstructor that creates a new Game from the regular starting position.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.Game-Tuple{Board}","page":"API Reference","title":"Chess.Game","text":"Game(startboard::Board)\n\nConstructor that creates a Game from the provided starting position.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.Game-Tuple{String}","page":"API Reference","title":"Chess.Game","text":"Game(startfen::String)\n\nConstructor that creates a Game from the position given by the provided FEN string.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.GameHeader","page":"API Reference","title":"Chess.GameHeader","text":"GameHeader\n\nType representing a PGN header tag.\n\nContains name and value slots, both of which are strings.\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.GameHeaders","page":"API Reference","title":"Chess.GameHeaders","text":"GameHeaders\n\nType representing the PGN header tags for a game.\n\nContains a slot for each the seven required PGN tags event, site, date, round, white, black and result, all of which are strings. Remaining tags are included in the othertags slot, which contains a vector of GameHeaders.\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.GameNode","page":"API Reference","title":"Chess.GameNode","text":"GameNode\n\nType representing a node in a Game.\n\nGame can contain variations, so this type actually represents a node in a tree-like structure.\n\nA GameNode is a mutable struct with the following slots:\n\nparent: The parent GameNode, or nothing if this node is the root of the game.\nboard: The board position at this node.\nchildren: A vector of GameNodes, the children of the current node. The first entry is the main continuation, the remaining entries are alternative variations.\ndata: A Dict{String, Any} used to store information about this node. This is used for comments and numeric annotation glyphs, but can also be used to store other data.\nid: An Int, used to look up this node in a Game, which contains a dictionary mapping ids to GameNodes.\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.headervalue","page":"API Reference","title":"Chess.headervalue","text":"headervalue(ghs::GameHeaders, name::String)\nheadervalue(g::SimpleGame, name::String)\nheadervalue(g::Game, name::String)\n\nLooks up the value for the header with the given name.\n\nReturns the value as a String, or nothing if no header with the provided name exists.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.dateplayed","page":"API Reference","title":"Chess.dateplayed","text":"dateplayed(g::SimpleGame)::Union{Date, Nothing}\ndateplayed(g::Game)::Union{Date, Nothing}\n\nThe date at which the game was played, or nothing.\n\nThis function makes use of the PGN date tag, trying to behave robustly with sensible defaults when the date is incomplete or incorrectly formatted. It handles both ISO format YYYY-MM-DD dates and PGN format YYYY.MM.DD dates. If either the month or the day is missing, they are replaced with 1. On failure, returns nothing.\n\nExamples\n\njulia> g = Game();\n\njulia> setheadervalue!(g, \"Date\", \"2019.09.20\");\n\njulia> dateplayed(g)\n2019-09-20\n\njulia> setheadervalue!(g, \"Date\", \"2019.09.??\");\n\njulia> dateplayed(g)\n2019-09-01\n\njulia> setheadervalue!(g, \"Date\", \"2019.??.??\");\n\njulia> dateplayed(g)\n2019-01-01\n\njulia> setheadervalue!(g, \"Date\", \"*\");\n\njulia> dateplayed(g) == nothing\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.whiteelo","page":"API Reference","title":"Chess.whiteelo","text":"whiteelo(g::SimpeGame)\nwhiteelo(g::Game)\n\nThe Elo of the white player (as given by the \"WhiteElo\" tag), or nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.blackelo","page":"API Reference","title":"Chess.blackelo","text":"blackelo(g::SimpeGame)\nblackelo(g::Game)\n\nThe Elo of the black player (as given by the \"BlackElo\" tag), or nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.setheadervalue!","page":"API Reference","title":"Chess.setheadervalue!","text":"setheadervalue!(ghs::GameHeaders, name::String, value::String)\nsetheadervalue!(g::SimpleGame, name::String, value::String)\nsetheadervalue!(g::Game, name::String, value::String)\n\nSets a header value, creating the header if it doesn't exist.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.board","page":"API Reference","title":"Chess.board","text":"board(g::SimpleGame)\nboard(g::Game)\n\nThe board position at the current node in a game.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.domove!-Tuple{SimpleGame,Move}","page":"API Reference","title":"Chess.domove!","text":"domove!(g::SimpleGame, m::Move)\ndomove!(g::SimpleGame, m::String)\ndomove!(g::Game, m::Move)\ndomove!(g::Game, m::String)\n\nAdds a new move at the current location in the game move list.\n\nIf the supplied move is a string, this function tries to parse the move as a UCI move first, then as a SAN move.\n\nIf we are at the end of the game, all previous moves are kept, and the new move is added at the end. If we are at any earlier point in the game (because we have taken back one or more moves), the existing game continuation will be deleted and replaced by the new move. All variations starting at this point in the game will also be deleted. If you want to add the new move as a variation instead, make sure you use the Game type instead of SimpleGame, and use addmove! instead of domove!.\n\nThe move m is assumed to be a legal move. It's the caller's responsibility to ensure that this is the case.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.domoves!-Tuple{SimpleGame,Vararg{Union{Move, String},N} where N}","page":"API Reference","title":"Chess.domoves!","text":"domoves!(g::SimpleGame, moves::Vararg{Union{Move, String}})\ndomoves!(g::Game, moves::Vararg{Union{Move, String}})\n\nAdds a sequence of new moves at the current location in the game move list.\n\nThe moves can be either Move values or strings. In the case of strings, the function tries to parse them first as UCI moves, then as SAN moves.\n\nIf we are at the end of the game, all previous moves are kept, and the new moves are added at the end. If we are at any earlier point in the game (because we have taken back one or more moves), the existing game continuation will be deleted and replaced by the new moves. All variations starting at this point in the game will also be deleted. If you want to add the new moves as a variation instead, make sure you use the Game type instead of SimpleGame, and use addmoves! instead of domoves!.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.addmove!","page":"API Reference","title":"Chess.addmove!","text":"addmove!(g::Game, m::Move)\naddmove!(g::Game, m::String)\n\nAdds the move m to the game g at the current node.\n\nIf the supplied move is a string, this function tries to parse the move as a UCI move first, then as a SAN move.\n\nThe move m must be a legal move from the current node board position. A new game node with the board position after the move has been made is added to the end of the current node's children vector, and that node becomes the current node of the game.\n\nThe move m is assumed to be a legal move. It's the caller's responsibility to ensure that this is the case.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.addmoves!","page":"API Reference","title":"Chess.addmoves!","text":"addmoves!(g::Game, moves::Vararg{Union{Move, String}})\n\nAdds a sequence of moves to the game g at the current node.\n\nThe moves can be either Move values or strings. In the case of strings, the function tries to parse them first as UCI moves, then as SAN moves.\n\nThis function works by calling addmove! repeatedly for all input moves. It's the caller's responsibility to ensure that all moves are legal and unambiguous.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.nextmove","page":"API Reference","title":"Chess.nextmove","text":"nextmove(g::SimpleGame)\nnextmove(g::Game)\n\nThe next move in the game, or nothing if we're at the end of the game.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.ply","page":"API Reference","title":"Chess.ply","text":"ply(g::SimpleGame)\nply(g::Game)\n\nThe ply count of the current node.\n\nReturns 1 for the root node, 2 for children of the root node, etc.\n\nExamples\n\njulia> g = Game();\n\njulia> addmoves!(g, \"d4\", \"Nf6\", \"c4\", \"g6\", \"Nc3\", \"Bg7\");\n\njulia> ply(g)\n7\n\njulia> back!(g);\n\njulia> ply(g)\n6\n\njulia> tobeginning!(g);\n\njulia> ply(g)\n1\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.isatbeginning","page":"API Reference","title":"Chess.isatbeginning","text":"isatbeginning(g::SimpleGame)::Bool\nisatbeginning(g::Game)::Bool\n\nReturn true if we are at the beginning of the game, and false otherwise.\n\nWe can be at the beginning of the game either because we haven't yet added any moves to the game, or because we have stepped back to the beginning.\n\nExamples\n\njulia> g = SimpleGame();\n\njulia> isatbeginning(g)\ntrue\n\njulia> domove!(g, \"e4\");\n\njulia> isatbeginning(g)\nfalse\n\njulia> back!(g);\n\njulia> isatbeginning(g)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.isatend","page":"API Reference","title":"Chess.isatend","text":"isatend(g::SimpleGame)::Bool\nisatend(g::Game)::Bool\n\nReturn true if we are at the end of the game, and false otherwise.\n\nExamples\n\njulia> g = SimpleGame();\n\njulia> isatend(g)\ntrue\n\njulia> domove!(g, \"Nf3\");\n\njulia> isatend(g)\ntrue\n\njulia> back!(g);\n\njulia> isatend(g)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.back!","page":"API Reference","title":"Chess.back!","text":"back!(g::SimpleGame)\nback!(g::Game)\n\nGo one step back in the game by retracting a move.\n\nIf we're already at the beginning of the game, the game is unchanged.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.forward!","page":"API Reference","title":"Chess.forward!","text":"forward!(g::SimpleGame)\nforward!(g::Game)\nforward!(g::Game, m::Move)\nforward!(g::Game, m::String)\n\nGo one step forward in the game by replaying a previously retracted move.\n\nIf we're already at the end of the game, the game is unchanged. If the current node has multiple children, we always pick the first child (i.e. the main line). If any child other than the first child is desired, supply the move leading to the child node as the second argument. It's the caller's responsibility that the move supplied leads to one of the existing child nodes.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.tobeginning!","page":"API Reference","title":"Chess.tobeginning!","text":"tobeginning!(g::SimpleGame)\ntobeginning!(g::Game)\n\nGo back to the beginning of a game by taking back all moves.\n\nIf we're already at the beginning of the game, the game is unchanged.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.toend!","page":"API Reference","title":"Chess.toend!","text":"toend!(g::SimpleGame)\ntoend!(g::Game)\n\nGo forward to the end of a game by replaying all moves, following the main line.\n\nIf we're already at the end of the game, the game is unchanged.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.tobeginningofvariation!","page":"API Reference","title":"Chess.tobeginningofvariation!","text":"tobeginningofvariation!(g::Game)\n\nGo to the beginning of the variation containing the current node of the game.\n\nSteps back up the game tree until we reach the point where the first child node (i.e. the main line) is not contained in the current variation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.tonode!","page":"API Reference","title":"Chess.tonode!","text":"tonode!(g::Game, id::Int)\n\nGo to the game tree node with the given node id, if it exists.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.isleaf","page":"API Reference","title":"Chess.isleaf","text":"isleaf(n::GameNode)::Bool\n\nTests whether a GameNode is a leaf, i.e. that it has no children.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.comment","page":"API Reference","title":"Chess.comment","text":"comment(n::GameNode)\n\nThe comment after the move leading to this node, or nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.precomment","page":"API Reference","title":"Chess.precomment","text":"precomment(n::GameNode)\n\nThe comment before the move leading to this node, or nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.nag","page":"API Reference","title":"Chess.nag","text":"nag(n::GameNode)\n\nThe numeric annotation glyph for the move leading to this node, or nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.addcomment!","page":"API Reference","title":"Chess.addcomment!","text":"addcomment!(g::Game, comment::String)\n\nAdds a comment to the current game node.\n\nIn PGN and other text ouput formats, the comment is printed after the move leading to the node.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.addprecomment!","page":"API Reference","title":"Chess.addprecomment!","text":"addprecomment!(g::Game, comment::String)\n\nAdds a pre-comment to the current game node.\n\nIn PGN and other text ouput formats, the comment is printed before the move leading to the node.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.addnag!","page":"API Reference","title":"Chess.addnag!","text":"addnag!(g::Game, nag::Int)\n\nAdds a Numeric Annotation Glyph (NAG) to the current game node.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.removeallchildren!","page":"API Reference","title":"Chess.removeallchildren!","text":"removeallchildren!(g::Game, node::GameNode = g.node)\n\nRecursively remove all children of the given node in the game.\n\nIf no node is supplied, removes the children of the current node.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.removenode!","page":"API Reference","title":"Chess.removenode!","text":"removenode!(g::Game, node::GameNode = g.node)\n\nRemove a node (by default, the current node) in a Game, and go to the parent node.\n\nAll children of the node are also recursively deleted.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.adddata!","page":"API Reference","title":"Chess.adddata!","text":"adddata!(n::GameNode, key::String, value)\n\nAdd a piece of data to the given node's data dictionary.\n\nThis is a low-level function that is mainly used to add comments and NAGs, but can also be used to add any type of custom annotation data to a game node.\n\n\n\n\n\nadddata!(g::Game, key::String, value)\n\nAdd a piece of data to the current game node's data dictionary.\n\nThis is a low-level function that is mainly used to add comments and NAGs, but can also be used to add any type of custom annotation data to a game node.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.removedata!","page":"API Reference","title":"Chess.removedata!","text":"removedata!(n::GameNode, key::String)\n\nRemove a piece of data from the game node's data dictionary.\n\nThis is a low-level function that is mainly used to delete comments and NAGs.\n\n\n\n\n\nremovedata!(n::GameNode, key::String)\n\nRemove a piece of data from the current game node's data dictionary.\n\nThis is a low-level function that is mainly used to delete comments and NAGs.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.continuations","page":"API Reference","title":"Chess.continuations","text":"continuations(n::GameNode)::Vector{Move}\ncontinuations(g::Game)::Vector{Move}\n\nAll moves at this node in the game tree.\n\nOne move for each child node of the current node. The first element is the main line.\n\nExamples\n\njulia> g = Game();\n\njulia> addmoves!(g, \"e4\", \"e5\");\n\njulia> back!(g);\n\njulia> addmove!(g, \"c5\");\n\njulia> back!(g);\n\njulia> continuations(g)\n2-element Array{Move,1}:\n Move(e7e5)\n Move(c7c5)\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.isdraw-Tuple{SimpleGame}","page":"API Reference","title":"Chess.isdraw","text":"isdraw(g::SimpleGame)\nisdraw(g::Game)\n\nChecks whether the current game position is drawn.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.ischeckmate-Tuple{SimpleGame}","page":"API Reference","title":"Chess.ischeckmate","text":"ischeckmate(g::SimpleGame)\nischeckmate(g::Game)\n\nChecks whether the current game position is a checkmate.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.isterminal-Tuple{SimpleGame}","page":"API Reference","title":"Chess.isterminal","text":"isterminal(g::SimpleGame)\nisterminal(g::Game)\n\nChecks whether the current game position is terminal, i.e. mate or drawn.\n\n\n\n\n\n","category":"method"},{"location":"api/#Opening-Books-1","page":"API Reference","title":"Opening Books","text":"","category":"section"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"BookEntry\ncreatebook\nwritebooktofile\npurgebook\nfindbookentries\npickbookmove\nprintbookentries","category":"page"},{"location":"api/#Chess.Book.BookEntry","page":"API Reference","title":"Chess.Book.BookEntry","text":"BookEntry\n\nA struct representing an opening book entry.\n\nBook entries contain the following slots:\n\nkey: The hash key of the board position this book entry represents.\nmove: The move played, encoded as an Int32. In order to get the actual Move value representing the move stored in a book entry e, you should do Move(e.move).\nelo: The highest Elo rating of a player who played this move.\noppelo: The highest Elo of the opponent in a game where this move was played.\nwins: The number of times the player who played this move won the game.\ndraws: The number of times the player who played this move drew the game.\nlosses: The number of times the player who played this move lost the game.\nfirstyear: The year this move was first played.\nlastyear: The year this move was last played.\nscore: The score of this move, used to obtain a probability distribution when picking a book move for a position. The score is computed based on the W/L/D stats for the move, the ratings of the players who have played it, and on its popularity in more recent games.\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.Book.createbook","page":"API Reference","title":"Chess.Book.createbook","text":"createbook(pgnfiles::Vararg{String};\n           scorewhitewin = 8.0,\n           scorewhitedraw = 4.0,\n           scorewhiteloss = 1.0,\n           scoreblackwin = 8.0,\n           scoreblackdraw = 5.0,\n           scoreblackloss = 1.0,\n           scoreunknown = 0.0,\n           highelofactor = 6.0,\n           yearlydecay = 0.85,\n           maxply = 60,\n           minelo = 0)\n\nCreates an opening book tree from one or more PGN files.\n\nThe opening tree is stored in RAM. You will probably want to save it to disk using writebooktofile afterwards, for instance like this:\n\njulia> bk = createbook(\"my-pgn-file.pgn\");\n\njulia> writebooktofile(bk, \"my-book.obk\")\n\nThe createbook function takes a number of optional named parameters that can be used to control what moves are included in the opening tree, and the scoring of the moves (which is used to produce move probabilities when picking a move using pickbookmove). These are:\n\nscorewhitewin: The base score for all white moves in a game won by white.\nscorewhitedraw: The base score for all white moves in a drawn game.\nscorewhiteloss: The base score for all black moves in a game won by black.\nscoreblackwin: The base score for all black moves in a game won by black.\nscoreblackdraw: The base score for all black moves in a drawn game.\nscoreblackloss: The base score for all black moves in a game won by white.\nscoreunknown: The base score for all moves in a game with an unknown result.\nhighelofactor: Score multiplier for moves played by a player with high rating. The base score is multiplied by max(1.0 0.01 * highelofactor * (2300 - elo))\nyearlydecay: Controls exponential yearly reduction of scores. If a game was played n years ago, all scores are multiplied by n^yearlydecay.\nmaxply: Maximum depth of the opening tree. If maxply equals 60 (the default), no moves after move 30 are included in the opening tree.\nminelo: Minimum Elo for book moves. Moves played by players below this number are not included in the opening tree.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.Book.writebooktofile","page":"API Reference","title":"Chess.Book.writebooktofile","text":"writebooktofile(entries::Vector{BookEntry}, filename::String,\n                compact = false)\n\nWrites a book (as created by createbookfile) to a binary file.\n\nIf the optional parameter compact is true, the book is written in a more compact format that does not include W/L/D counts, Elo numbers and years.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.Book.purgebook","page":"API Reference","title":"Chess.Book.purgebook","text":"purgebook(infilename::String, outfilename::String;\n          minscore = 0, mingamecount = 5, compact = false)\n\nCreates a smaller version of an opening book file by removing unimportant lines.\n\nBook moves with score lower than minscore or which have been played in fewer than mingamecount games are not included in the output file.\n\nIf the optional parameter compact is true, the output file is written in a more compact format that does not include W/L/D counts, Elo numbers and years.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.Book.findbookentries","page":"API Reference","title":"Chess.Book.findbookentries","text":"findbookentries(b::Board, bookfilename::String)\nfindbookentries(key::UInt64, bookfilename::String)\n\nReturns all book entries for the given board or key.\n\nThe return value is a (possibly empty) Vector{BookEntry}, sorted by descending scores.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.Book.pickbookmove","page":"API Reference","title":"Chess.Book.pickbookmove","text":"pickbookmove(b::Board, bookfilename::String;\n             minscore = 0, mingamecount = 1)\n\nPicks a book move for the board b, returning nothing when out of book.\n\nThe move is selected with probabilities given by the score slots in the BookEntry objects. The minscore and mingamecount parameters can be used to exclude moves with low score or low play counts.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.Book.printbookentries","page":"API Reference","title":"Chess.Book.printbookentries","text":"printbookentries(b::Board, bookfilename::String)\n\nPretty-print the move entries for the provided board.\n\n\n\n\n\n","category":"function"},{"location":"api/#PGN-Files-1","page":"API Reference","title":"PGN Files","text":"","category":"section"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"PGNReader\nPGNReader(io::IO)\nreadgame\ngamefromstring\ngametopgn\ngamesinfile\ngotonextgame!","category":"page"},{"location":"api/#Chess.PGN.PGNReader","page":"API Reference","title":"Chess.PGN.PGNReader","text":"PGNReader\n\nA type for reading PGN data from a stream.\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.PGN.PGNReader-Tuple{IO}","page":"API Reference","title":"Chess.PGN.PGNReader","text":"PGNReader(io::IO)\n\nInitializes a PGNReader from an IO object.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.PGN.readgame","page":"API Reference","title":"Chess.PGN.readgame","text":"readgame(p::PGNReader; annotations=false)\n\nAttempts to parse a PGN game and use it to create a Game or a SimpleGame.\n\nIf the optional parameter annotations is true, the return value will be a Game containing all comments, variations and numeric annotation glyphs in the PGN. Otherwise, it will be a SimpleGame with only the game moves.\n\nThis function assumes that the PGNReader is pointed at the beginning of a game. If you are not sure this is the case, call gotonextgame! on the PGNReader first.\n\nIf parsing fails or the notation contains illegal or ambiguous moves, the function raises a PGNException.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.PGN.gamefromstring","page":"API Reference","title":"Chess.PGN.gamefromstring","text":"gamefromstring(s::String; annotations=false)\n\nAttempts to create a Game or SimpleGame object from the provided PGN string.\n\nIf the optional parameter annotations is true, the return value will be a Game containing all comments, variations and numeric annotation glyphs in the PGN. Otherwise, it will be a SimpleGame with only the game moves.\n\nIf the string does not parse as valid PGN, or if the notation contains illegal or ambiguous moves, the function raises a PGNException\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.PGN.gametopgn","page":"API Reference","title":"Chess.PGN.gametopgn","text":"gametopgn(g)::String\n\nExports a Game or a SimpleGame to a PGN string.\n\nLimitations\n\nThe movetext section is written in a single long line, with no line breaks.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.PGN.gamesinfile","page":"API Reference","title":"Chess.PGN.gamesinfile","text":"gamesinfile(filename::String; annotations=false)\n\nCreates a Channel of Game/SimpleGame objects read from the PGN file with the provided file name.\n\nIf the optional parameter annotations is true, the return value will be a channel of Game objects containing all comments, variations and numeric annotation glyphs in the PGN. Otherwise, it will consist of SimpleGame objects with only the game moves.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.PGN.gotonextgame!","page":"API Reference","title":"Chess.PGN.gotonextgame!","text":"gotonextgame!(p::PGNReader)::Bool\n\nTries to go to the next game, returns true on success.\n\n\n\n\n\n","category":"function"},{"location":"api/#UCI-Chess-Engines-1","page":"API Reference","title":"UCI Chess Engines","text":"","category":"section"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"Engine\nrunengine\nnewgame\nquit\nsetoption\nsendisready\nsendcommand\nsetboard\nsearch\nmpvsearch\nBestMoveInfo\nparsebestmove\nSearchInfo\nparsesearchinfo\ntouci\nScore\nBoundType\nOption\nOptionType\nOptionValue","category":"page"},{"location":"api/#Chess.UCI.Engine","page":"API Reference","title":"Chess.UCI.Engine","text":"Engine\n\nType representing a UCI chess engine.\n\nThis is a struct with the following slots:\n\nname: The engine name, as provided by the engine in response to the uci command.\nauthor: The engine author name, as provided by the engine in response to the uci command.\noptions: The UCI options for this engine. This is a dictionary mapping option names (Strings) to options (instances of the Option type).\nio: A Base.Process object used to communicate with the engine.\n\nEngines are created by calling the runengine function, which takes a pathname for an UCI engine as input, runs the engine, and returns an Engine object.\n\nExamples\n\nThe below is a typical interaction with a UCI engine. The example assumes that you have a UCI engine with the file name stockfish somewhere in your PATH.\n\njulia> sf = runengine(\"stockfish\");\n\njulia> setoption(sf, \"Hash\", 128)\n\njulia> setboard(sf, fromfen(\"1kbr3r/pp6/8/P1n2ppq/2N3n1/R3Q1P1/3B1P2/2R2BK1 w - -\"))\n\njulia> search(sf, \"go depth 18\", infoaction=println)\ninfo depth 1 seldepth 1 multipv 1 score cp -842 nodes 88 nps 88000 tbhits 0 time 1 pv f1g2 g4e3 d2e3\ninfo depth 2 seldepth 2 multipv 1 score cp -842 nodes 207 nps 103500 tbhits 0 time 2 pv f1g2 g4e3\ninfo depth 3 seldepth 3 multipv 1 score cp -844 nodes 270 nps 135000 tbhits 0 time 2 pv f1g2 g4e3 d2e3 d8d1 c1d1 h5d1 g2f1\ninfo depth 4 seldepth 5 multipv 1 score cp -844 nodes 367 nps 183500 tbhits 0 time 2 pv f1g2 g4e3 d2e3 d8d1 c1d1\ninfo depth 5 seldepth 7 multipv 1 score cp -953 nodes 866 nps 433000 tbhits 0 time 2 pv f1g2 h5h2 g1f1 g4e3 d2e3 c5d3 e3g5\ninfo depth 6 seldepth 8 multipv 1 score cp -1060 nodes 1507 nps 753500 tbhits 0 time 2 pv f1g2 g4e3 d2e3 c5d3 e3d2 d3c1\ninfo depth 7 seldepth 11 multipv 1 score cp -876 nodes 1995 nps 665000 tbhits 0 time 3 pv f1g2 g4e3\ninfo depth 8 seldepth 10 multipv 1 score cp -882 nodes 2771 nps 923666 tbhits 0 time 3 pv f1g2 g4e3 d2e3 c8e6 e3c5 d8d1 c1d1 h5d1 g2f1 e6c4\ninfo depth 9 seldepth 15 multipv 1 score cp -1068 nodes 12059 nps 1339888 tbhits 0 time 9 pv f1g2 g4e3 a3e3 c8e6 e3e6 c5e6 d2e1 d8d1 c1d1 h5d1\ninfo depth 10 seldepth 15 multipv 1 score cp -1050 nodes 17558 nps 1463166 tbhits 0 time 12 pv f1g2 g4e3 a3e3 c8e6 g1f1 h5g4 e3e6 c5e6 c4e3 g4a4 d2c3\ninfo depth 11 seldepth 17 multipv 1 score cp -1013 nodes 23543 nps 1569533 tbhits 0 time 15 pv f1g2 g4e3 a3e3 c8e6 g1f1 h5g4 e3e6 c5e6 c4e3 g4a4 d2c3\ninfo depth 12 seldepth 20 multipv 1 score cp -995 nodes 48497 nps 1672310 tbhits 0 time 29 pv f1g2 g4e3 a3e3 c8e6 g1f1 c5e4 d2e1 d8c8 g3g4 h5g4 c4e5 g4h4 c1c8 h8c8\ninfo depth 13 seldepth 29 multipv 1 score cp -1116 nodes 205726 nps 1959295 tbhits 0 time 105 pv f1g2 g4e3 f2e3 c5e4 a3a2 h5h2 g1f1 e4g3 f1f2 g3e4 f2f1 e4d2 c4d2 h2g3 d2f3 d8d3 f1g1 d3e3 f3d4 e3e8 a2e2\ninfo depth 14 seldepth 28 multipv 1 score cp -148 nodes 247247 nps 1993927 tbhits 0 time 124 pv e3f4 g5f4 d2f4 b8a8 c4b6 a7b6 a5b6 c5a6\ninfo depth 15 seldepth 16 multipv 1 score cp 120 nodes 248911 nps 1991288 tbhits 0 time 125 pv e3f4 g5f4 d2f4 g4e5 f4e5 d8d6 e5d6 b8a8 f1g2 c8e6 d6c5\ninfo depth 16 seldepth 24 multipv 1 score cp 1117 nodes 251829 nps 1982905 tbhits 0 time 127 pv e3f4 g4e5 f4e5 d8d6 e5d6 b8a8 f1g2 h5h2 g1f1 c5e4 g2e4 f5e4 d2g5 c8h3 f1e2\ninfo depth 17 seldepth 22 multipv 1 score cp 1500 nodes 258707 nps 1990053 tbhits 0 time 130 pv e3f4 g4e5 f4e5 d8d6 e5d6 b8a8 f1g2 h5h2 g1f1 c5e4 g2e4 h2h3 e4g2\ninfo depth 18 seldepth 22 multipv 1 score mate 11 nodes 281736 nps 1984056 tbhits 0 time 142 pv e3f4 g5f4 d2f4 g4e5 f4e5 d8d6 e5d6 b8a8 c4b6 a7b6 a5b6 c5a6 c1c8 h8c8\nBestMoveInfo (best=e3f4, ponder=g5f4)\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.UCI.runengine","page":"API Reference","title":"Chess.UCI.runengine","text":"function runengine(path::String)::Engine\n\nRuns the engine at the specified path, returning an Engine.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.UCI.newgame","page":"API Reference","title":"Chess.UCI.newgame","text":"newgame(e::Engine)\n\nInstructs the engine that a new game is about to begin.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.UCI.quit","page":"API Reference","title":"Chess.UCI.quit","text":"function quit(e::Engine)\n\nSends the UCI engine e the \"quit\" command.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.UCI.setoption","page":"API Reference","title":"Chess.UCI.setoption","text":"function setoption(e::Engine, name::String, value::OptionValue = nothing)\n\nSets the UCI option named name to the new value value.\n\nThrows an error if the engine e does not have an option with the provided name, or if the value is incompatible with the type of the option.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.UCI.sendisready","page":"API Reference","title":"Chess.UCI.sendisready","text":"sendisready(e::Engine)::Bool\n\nSends the engine e an \"isready\" command and waits for the \"readyok\" response.\n\nReturns true on success, false on failure (i.e. if the engine replies with anything other than \"readyok\").\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.UCI.sendcommand","page":"API Reference","title":"Chess.UCI.sendcommand","text":"sendcommand(e::Engine, cmd::String)\n\nSends the UCI command cmd to the engine e.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.UCI.setboard","page":"API Reference","title":"Chess.UCI.setboard","text":"setboard(e::Engine, b::Board)\nsetboard(e::Engine, g::SimpleGame)\nsetboard(e::Engine, g::Game)\n\nSet the engine's current board position to the given board/game state.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.UCI.search","page":"API Reference","title":"Chess.UCI.search","text":"function search(e::Engine, gocmd::String; infoaction = nothing)\n\nTells a UCI engine to start searching.\n\nThe parameter gocmd is the actual command you want to send to the engine; e.g. \"go movetime 10000\" or \"go infinite\". The named parameter infoaction is a function accepting the output of the engine's \"info\" commands and doing something with the output. Usually, it will be some function making internal use of parsesearchinfo().\n\nThe return value is of type BestMoveInfo.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.UCI.mpvsearch","page":"API Reference","title":"Chess.UCI.mpvsearch","text":"mpvsearch(game, engine; nodes, depth, pvs)::Vector{SearchInfo}\n\nPerforms a multi-PV search and returns the result as a vector of SearchInfo.\n\nParameters:\n\ngame: A Game, a SimpleGame or a Board.\nengine: An Engine.\nnodes: A named parameter instructing the engine to search to the desired tree size.\ndepth: A named parameter instructing the engine to search to the given depth.\npvs: The number of desired lines. Analysis for the pvs best moves is returned. If pvs is greater than the number of legal moves, analysis for all legal moves is returned.\n\nAt least one of nodes and depth must be supplied. If both are supplied, the function will use depth and ignore nodes.\n\nThe function returns a vector of SearchInfo values, one for each of the pvs best moves.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.UCI.BestMoveInfo","page":"API Reference","title":"Chess.UCI.BestMoveInfo","text":"BestMoveInfo\n\nA struct representing the contents of a UCI engine's bestmove output.\n\nContains the following slots:\n\nbestmove: The Move returned by the engine as the best move.\nponder: The engine's expected reply to the best move, a Move or nothing.\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.UCI.parsebestmove","page":"API Reference","title":"Chess.UCI.parsebestmove","text":"parsebestmove(line::String)::BestMoveInfo\n\nParses a bestmove line printed by a UCI engine to a BestMoveInfo object.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.UCI.SearchInfo","page":"API Reference","title":"Chess.UCI.SearchInfo","text":"SearchInfo\n\nA struct representing the contents of a UCI engine's info output.\n\nContains the following slots, all of which can be nothing for a given line of search output:\n\ndepth: The current search depth.\nseldepth: The current selective search depth.\ntime: The time spent searching so far, in milliseconds.\nnodes: The number of nodes searched so far.\npv: The main line, as a vector of Move values.\nmultipv: The multipv index of the line currently printed.\nscore: The score, a value of type Score.\ncurrmove: The move currently searched, a value of type Move.\ncurrmovenumber: The index of the move currently searched in the move list.\nhashfull: A number in the range 0–100, indicating the transposition table saturation percentage.\nnps: Nodes/second count.\ntbhits: Number of tablebase hits.\ncpuload: CPU load percentage.\nstring: An arbitrary string sent by the engine.\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.UCI.parsesearchinfo","page":"API Reference","title":"Chess.UCI.parsesearchinfo","text":"parsesearchinfo(line::String)::SearchInfo\n\nParses an info line printed by a UCI engine to a SearchInfo object.\n\nSee the documentation for SearchInfo for information about how to inspect and use the return value.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.UCI.touci","page":"API Reference","title":"Chess.UCI.touci","text":"touci(b::Board)\ntouci(g::SimpleGame)\ntouci(g::Game)\n\nCreate a UCI string representation of a board or a game.\n\nExamples\n\njulia> touci(startboard())\n\"position fen rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq -\"\n\njulia> sg = SimpleGame(); domove!(sg, \"e4\"); domove!(sg, \"c5\"); domove!(sg, \"Nf3\");\n\njulia> touci(sg)\n\"position fen rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - moves e2e4 c7c5 g1f3\"\n\njulia> g = Game(); domove!(g, \"d4\"); domove!(g, \"Nf6\"); domove!(g, \"c4\");\n\njulia> touci(g)\n\"position fen rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - moves d2d4 g8f6 c2c4\"\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.UCI.Score","page":"API Reference","title":"Chess.UCI.Score","text":"Score\n\nA struct type representing a score returned by a UCI engine.\n\nThe struct has the following slots:\n\nvalue: An Int representing the score value.\nismate: A Bool that tells whether this is a mate score.\nbound: A BoundType, indicating whether this score is a lower bound, an upper bound, or an exact value.\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.UCI.BoundType","page":"API Reference","title":"Chess.UCI.BoundType","text":"BoundType\n\nAn enum type representing the score bound types lower, upper and exact.\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.UCI.Option","page":"API Reference","title":"Chess.UCI.Option","text":"Option\n\nType representing a UCI option. This is a mutable struct with the following slots:\n\nname: A String, the name of the option, as provided by the engine.\ntype: An OptionType, the type of the option, as provided by the engine.\ndefaultValue: An OptionValue, as provided by the engine.\nvalue: An OptionValue, the current value of the option.\nmin: The minimum value of this option. Only used for options of type spin.\nmax: The maximum value of this option. Only used for options of type spin.\ncombovals: Vector of the possible values for this option. Only used for options of type Combo.\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.UCI.OptionType","page":"API Reference","title":"Chess.UCI.OptionType","text":"OptionType\n\nType representing an UCI option type. This is an enum with values corresponding to the option types defined in the UCI protocol: check, spin, combo, button and string.\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.UCI.OptionValue","page":"API Reference","title":"Chess.UCI.OptionValue","text":"OptionValue\n\nType representing the value of a UCI option. This is a union type containing the types Nothing (for options of type button), Bool (for options of type check, Int (for options of type spin) and String (for options of type combo or string).)\n\n\n\n\n\n","category":"constant"},{"location":"api/#Pieces,-Piece-Types-and-Piece-Colors-1","page":"API Reference","title":"Pieces, Piece Types and Piece Colors","text":"","category":"section"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"Piece\nPiece(c::PieceColor, t::PieceType)\nPieceColor\nPieceType\npcolor\nptype\ncoloropp\nisslider\ncolorfromchar\npiecetypefromchar\npiecefromchar\ntochar(c::PieceColor)\ntochar(t::PieceType, uppercase = false)\ntochar(p::Piece)","category":"page"},{"location":"api/#Chess.Piece","page":"API Reference","title":"Chess.Piece","text":"Piece\n\nType representing a chess piece.\n\nThe possible values are PIECE_WP, PIECE_WN, PIECE_WB, PIECE_WR, PIECE_WQ, PIECE_WK, PIECE_BP, PIECE_BN, PIECE_BB, PIECE_BR, PIECE_BQ, PIECE_BK and EMPTY. The reason for the existence of the value EMPTY is that we represent a chess board as an array of pieces, and we need a value to indicate an empty square on the board.\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.Piece-Tuple{PieceColor,PieceType}","page":"API Reference","title":"Chess.Piece","text":"Piece(c::PieceColor, t::PieceType)\n\nConstruct a piece with the given color and type.\n\nExamples\n\njulia> Piece(BLACK, QUEEN)\nPIECE_BQ\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.PieceColor","page":"API Reference","title":"Chess.PieceColor","text":"PieceColor\n\nType representing the color of a chess piece.\n\nThe possible values are WHITE, BLACK and COLOR_NONE. The reason for the existence of the value COLOR_NONE is that we represent a chess board as an array of pieces, and we need a special Piece value EMPTY to indicate an empty square on the board. The color of the EMPTY piece is COLOR_NONE.\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.PieceType","page":"API Reference","title":"Chess.PieceType","text":"PieceType\n\nType representing the type of a chess piece.\n\nThis is essentially a piece without color. The possible values are PAWN, KNIGHT, BISHOP, ROOK, QUEEN, KING and PIECE_TYPE_NONE. The reason for the existence of the value PIECE_TYPE_NONE is that we represent a chess board as an array of pieces, and we need a special Piece value EMPTY to indicate an empty square on the board. The type of the EMPTY piece is PIECE_TYPE_NONE\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.pcolor","page":"API Reference","title":"Chess.pcolor","text":"pcolor(p::Piece)\n\nFind the color of a Piece.\n\nExamples\n\njulia> pcolor(PIECE_WB)\nWHITE\n\njulia> pcolor(EMPTY)\nCOLOR_NONE\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.ptype","page":"API Reference","title":"Chess.ptype","text":"ptype(p::Piece)\n\nFind the type of a Piece.\n\nExamples\n\njulia> ptype(PIECE_BQ)\nQUEEN\n\njulia> ptype(EMPTY)\nPIECE_TYPE_NONE\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.coloropp","page":"API Reference","title":"Chess.coloropp","text":"coloropp(c::PieceColor)\n\nReturns the opposite of a color.\n\nExamples\n\njulia> coloropp(WHITE) == BLACK\ntrue\n\njulia> coloropp(BLACK) == WHITE\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.isslider","page":"API Reference","title":"Chess.isslider","text":"isslider(t::PieceType)\nisslider(p::Piece)\n\nDetermine whether a piece is a sliding piece.\n\n\n\n\n\nisslider(t::PieceType)\nisslider(p::Piece)\n\nDetermine whether a piece is a sliding piece.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.colorfromchar","page":"API Reference","title":"Chess.colorfromchar","text":"colorfromchar(c::Char)\n\nTries to convert a character to a PieceColor.\n\nThe return value is a Union{PieceColor, Nothing}. If the input character is one of the four characters 'w', 'b', 'W', 'B', the function returns the obvious corresponding color (WHITE or BLACK). For all other input characters, the function returns nothing.\n\nExamples\n\njulia> colorfromchar('w') == WHITE\ntrue\n\njulia> colorfromchar('B') == BLACK\ntrue\n\njulia> colorfromchar('x') == nothing\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.piecetypefromchar","page":"API Reference","title":"Chess.piecetypefromchar","text":"piecetypefromchar(c::Chars)\n\nTries to convert a character to a PieceType.\n\nThe return value is a Union{PieceType, Nothing}. If the input character is a valid upper- or lowercase English piece letter (PNBRQK), the function returns the corresponding piece type. For all other input characters, the function returns nothing.\n\nExamples\n\njulia> piecetypefromchar('n') == KNIGHT\ntrue\n\njulia> piecetypefromchar('B') == BISHOP\ntrue\n\njulia> piecetypefromchar('a') == nothing\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.piecefromchar","page":"API Reference","title":"Chess.piecefromchar","text":"piecefromchar(ch::Char)\n\nTries to convert a character to a Piece.\n\nThe return value is a Union{Piece, Nothing}. If the input character is a valid English piece letter, the corresponding piece is returned. If the piece letter is uppercase, the piece is white. If the piece letter is lowercase, the piece is black.\n\nIf the input value is not a valid English piece letter, the function returns nothing.\n\nExamples\n\njulia> piecefromchar('Q')\nPIECE_WQ\n\njulia> piecefromchar('n')\nPIECE_BN\n\njulia> piecefromchar('-') == nothing\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.tochar-Tuple{PieceColor}","page":"API Reference","title":"Chess.tochar","text":"tochar(c::PieceColor)\n\nConverts a color to a character.\n\nExamples\n\njulia> tochar(WHITE)\n'w': ASCII/Unicode U+0077 (category Ll: Letter, lowercase)\n\njulia> tochar(BLACK)\n'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)\n\njulia> tochar(COLOR_NONE)\n'?': ASCII/Unicode U+003f (category Po: Punctuation, other)\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.tochar","page":"API Reference","title":"Chess.tochar","text":"tochar(t::PieceType, uppercase = false)\n\nConverts a PieceType value to a character.\n\nA valid piece type value is converted to its standard English algebraic notation piece letter. Any invalid piece type value is converted to a '?' character. The optional parameter uppercase controls whether the character is an upper- or lower-case letter.\n\nExamples\n\njulia> tochar(PAWN)\n'p': ASCII/Unicode U+0070 (category Ll: Letter, lowercase)\n\njulia> tochar(ROOK, true)\n'R': ASCII/Unicode U+0052 (category Lu: Letter, uppercase)\n\njulia> tochar(PIECE_TYPE_NONE)\n'?': ASCII/Unicode U+003f (category Po: Punctuation, other)\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.tochar-Tuple{Piece}","page":"API Reference","title":"Chess.tochar","text":"tochar(p::Piece)\n\nConverts a piece to a character.\n\nExamples\n\njulia> tochar(PIECE_WN)\n'N': ASCII/Unicode U+004e (category Lu: Letter, uppercase)\n\njulia> tochar(PIECE_BK)\n'k': ASCII/Unicode U+006b (category Ll: Letter, lowercase)\n\njulia> tochar(EMPTY)\n'?': ASCII/Unicode U+003f (category Po: Punctuation, other)\n\n\n\n\n\n","category":"method"},{"location":"api/#Squares-1","page":"API Reference","title":"Squares","text":"","category":"section"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"Square\nSquare(f::SquareFile, r::SquareRank)\nSquareFile\nSquareRank\nSquareDelta\nfile\nrank\ndistance(s1::Square, s2::Square)\ndistance(f1::SquareFile, f2::SquareFile)\ndistance(r1::SquareRank, r2::SquareRank)\nfilefromchar\nrankfromchar\ntochar(f::SquareFile)\ntochar(r::SquareRank)\nsquarefromstring\ntostring(s::Square)","category":"page"},{"location":"api/#Chess.Square","page":"API Reference","title":"Chess.Square","text":"Square\n\nType representing a square on a chess board.\n\nA Square can be constructed either with an Int (with the convention a8=1, a7=2, ..., a1=8, b8=9, b7=10, ..., h1=64) or with a SquareFile and a SquareRank. There are also constants SQ_A1, ..., SQ_H8 for all 64 squares on the board.\n\nExamples\n\njulia> Square(FILE_G, RANK_6)\nSQ_G6\n\njulia> Square(8)\nSQ_A1\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.Square-Tuple{SquareFile,SquareRank}","page":"API Reference","title":"Chess.Square","text":"Square(f::SquareFile, r::SquareRank)\n\nConstruct a square with the given file and rank.\n\nExamples\n\njulia> Square(FILE_D, RANK_5)\nSQ_D5\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.SquareFile","page":"API Reference","title":"Chess.SquareFile","text":"SquareFile\n\nType representing the file of a square on a chess board.\n\nUsually, a SquareFile is obtained either by calling the function file() on a Square or through one of the constants FILE_A, FILE_B, ..., FILE_H.\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.SquareRank","page":"API Reference","title":"Chess.SquareRank","text":"SquareRank\n\nType representing the rank of a square on a chess board.\n\nUsually, a SquareRank is obtained either by calling the function rank() on a Square or through one of the constants RANK_1, RANK_2, ..., RANK_8.\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.SquareDelta","page":"API Reference","title":"Chess.SquareDelta","text":"SquareDelta\n\nA type representing the delta or vector between two squares.\n\nA SquareDelta value is usually obtained either through one of the constants DELTA_N, DELTA_S, DELTA_E, DELTA_W, DELTA_NW, DELTA_NE, DELTA_SW, DELTA_SE, or by subtracting two square values.\n\nIt is possible to add or subtract two SquareDeltas, to multiply a SquareDelta by an integer scalar, or to add or subtract a SquareDelta to a Square.\n\nExamples\n\njulia> DELTA_N + DELTA_W == DELTA_NW\ntrue\n\njulia> SQ_D3 - SQ_C3 == DELTA_E\ntrue\n\njulia> SQ_G8 - 3 * DELTA_N\nSQ_G5\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.file","page":"API Reference","title":"Chess.file","text":"file(s::Square)\n\nCompute the file of the square s.\n\nExamples\n\njulia> file(SQ_C4)\nFILE_C\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.rank","page":"API Reference","title":"Chess.rank","text":"rank(s::Square)\n\nCompute the rank of the square s.\n\nExamples\n\njulia> rank(SQ_C4)\nRANK_4\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.distance-Tuple{Square,Square}","page":"API Reference","title":"Chess.distance","text":"distance(s1::Square, s2::Square)\n\nThe distance between two squares, counted by number of king moves.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.distance-Tuple{SquareFile,SquareFile}","page":"API Reference","title":"Chess.distance","text":"distance(f1::SquareFile, f2::SquareFile)\n\nThe horizontal distance between two files.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.distance-Tuple{SquareRank,SquareRank}","page":"API Reference","title":"Chess.distance","text":"distance(r1::SquareRank, r2::SquareRank)\n\nThe vertical distance between two ranks.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.filefromchar","page":"API Reference","title":"Chess.filefromchar","text":"filefromchar(c::Char)\n\nTries to convert a character to a file.\n\nThe return value is a Union{SquareFile, Nothing}. The nothing is returned in case the character does not represent a valid file.\n\nExamples\n\njulia> filefromchar('c')\nFILE_C\n\njulia> filefromchar('2') == nothing\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.rankfromchar","page":"API Reference","title":"Chess.rankfromchar","text":"rankfromchar(c::Char)\n\nTries to convert a character to a rank.\n\nThe return value is a Union{SquareRank, Nothing}. The nothing is returned in case the character does not represent a valid rank.\n\nExamples\n\njulia> rankfromchar('2')\nRANK_2\n\njulia> rankfromchar('x') == nothing\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.tochar-Tuple{SquareFile}","page":"API Reference","title":"Chess.tochar","text":"tochar(f::SquareFile)\n\nConverts a SquareFile to a character.\n\nExamples\n\njulia> tochar(FILE_E)\n'e': ASCII/Unicode U+0065 (category Ll: Letter, lowercase)\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.tochar-Tuple{SquareRank}","page":"API Reference","title":"Chess.tochar","text":"tochar(r::SquareRank)\n\nConverts SquareRank to a character.\n\nExamples\n\njulia> tochar(RANK_3)\n'3': ASCII/Unicode U+0033 (category Nd: Number, decimal digit)\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.squarefromstring","page":"API Reference","title":"Chess.squarefromstring","text":"squarefromstring(s::String)\n\nTries to convert a string to a Square.\n\nThe return value is of type Union{Square, Nothing}.\n\nIf the input string is too short, or if the two first characters do not represent a square in standard algebraic notation, returns nothing. If the first two characters do represent avalid square, that square is returned, even if there are additional characters.\n\nExamples\n\njulia> squarefromstring(\"d6\")\nSQ_D6\n\njulia> squarefromstring(\"xy\") == nothing\ntrue\n\njulia> squarefromstring(\"\") == nothing\ntrue\n\njulia> squarefromstring(\"g1f3\")\nSQ_G1\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.tostring-Tuple{Square}","page":"API Reference","title":"Chess.tostring","text":"tostring(s::Square)\n\nConverts a square to a string in standard algebraic notation. If the square has an invalid value, the returned string is \"??\".\n\nExamples\n\njulia> tostring(SQ_E4)\n\"e4\"\n\njulia> tostring(Square(100))\n\"??\"\n\n\n\n\n\n","category":"method"},{"location":"api/#Moves-1","page":"API Reference","title":"Moves","text":"","category":"section"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"Move\nMove(from::Square, to::Square)\nMove(from::Square, to::Square, promotion::PieceType)\nfrom(m::Move)\nto(m::Move)\nispromotion(m::Move)\npromotion(m::Move)\ntostring(m::Move)\nmovefromstring(s::String)\nmovefromsan\nmovetosan\nvariationtosan(board::Board, v::Vector{Move}; startply=1, movenumbers=true)\nvariationtosan(g::SimpleGame, v::Vector{Move}; movenumbers=true)","category":"page"},{"location":"api/#Chess.Move","page":"API Reference","title":"Chess.Move","text":"Move\n\nType representing a chess move.\n\nA Move value is usually obtained by asking a chess board for moves, or by parsing a move string in UCI or SAN format (in the latter case, we also need a board).\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.Move-Tuple{Square,Square}","page":"API Reference","title":"Chess.Move","text":"Move(from::Square, to::Square)\n\nLow-level constructor for creating a move with the given from and to squares.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.Move-Tuple{Square,Square,PieceType}","page":"API Reference","title":"Chess.Move","text":"Move(from::Square, to::Square, promotion::PieceType)\n\nLow-level constructor for creating a move with the given from and to squares and promotion piece type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.from-Tuple{Move}","page":"API Reference","title":"Chess.from","text":"from(m::Move)\n\nThe source square of a move.\n\nExamples\n\njulia> Move(SQ_D2, SQ_D4)\nMove(d2d4)\n\njulia> from(Move(SQ_G1, SQ_F3))\nSQ_G1\n\njulia> from(Move(SQ_C7, SQ_C8, QUEEN))\nSQ_C7\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.to-Tuple{Move}","page":"API Reference","title":"Chess.to","text":"to(m::Move)\n\nThe destination square of a move.\n\nExamples\n\njulia> to(Move(SQ_G1, SQ_F3))\nSQ_F3\n\njulia> to(Move(SQ_C7, SQ_C8, QUEEN))\nSQ_C8\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.ispromotion-Tuple{Move}","page":"API Reference","title":"Chess.ispromotion","text":"ispromotion(m::Move)\n\nDetermine whether a move is a promotion move.\n\nExamples\n\njulia> ispromotion(Move(SQ_G1, SQ_F3))\nfalse\n\njulia> ispromotion(Move(SQ_C7, SQ_C8, QUEEN))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.promotion-Tuple{Move}","page":"API Reference","title":"Chess.promotion","text":"promotion(m::Move)\n\nFind the promotion piece type of a move.\n\nUse this function only after first using ispromotion to determine whether the move is a promotion move at all.\n\nExamples\n\njulia> promotion(Move(SQ_C7, SQ_C8, QUEEN))\nQUEEN\n\njulia> promotion(Move(SQ_B2, SQ_B1, KNIGHT))\nKNIGHT\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.tostring-Tuple{Move}","page":"API Reference","title":"Chess.tostring","text":"tostring(m::Move)\n\nConvert a move to a string in UCI notation.\n\nExamples\n\njulia> tostring(Move(SQ_G1, SQ_F3))\n\"g1f3\"\n\njulia> tostring(Move(SQ_E2, SQ_E1, KNIGHT))\n\"e2e1n\"\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.movefromstring-Tuple{String}","page":"API Reference","title":"Chess.movefromstring","text":"movefromstring(s::String)\n\nConvert a UCI move string to a move.\n\nReturns nothing if the input string is not a valid UCI move.\n\nExamples\n\njulia> movefromstring(\"d2d4\") == Move(SQ_D2, SQ_D4)\ntrue\n\njulia> movefromstring(\"h7h8q\") == Move(SQ_H7, SQ_H8, QUEEN)\ntrue\n\njulia> movefromstring(\"f7f9\") == nothing\ntrue\n\njulia> movefromstring(\"\") == nothing\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.movefromsan","page":"API Reference","title":"Chess.movefromsan","text":"movefromsan((b::Board, san::String))::Union{Move, Nothing}\n\nTries to read a move in Short Algebraic Notation.\n\nReturns nothing if the provided string is an impossible or ambiguous move.\n\nExamples\n\njulia> movefromsan(b, \"Nf3\")\nMove(g1f3)\n\njulia> movefromsan(b, \"???\") == nothing\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.movetosan","page":"API Reference","title":"Chess.movetosan","text":"function movetosan(b::Board, m::Move)\n\nConverts a move to a string in short algebraic notation.\n\nExamples\n\njulia> b = startboard();\n\njulia> movetosan(b, Move(SQ_D2, SQ_D4))\n\"d4\"\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.variationtosan-Tuple{Board,Array{Move,1}}","page":"API Reference","title":"Chess.variationtosan","text":"variationtosan(board::Board, v::Vector{Move};\n               startply=1, movenumbers=true)::String\n\nConverts a variation to a string in short algebraic notation.\n\nThe vector of moves v should be a sequence of legal moves from the board position. If movenumbers is true, move numbers will be included in the string. The moves are numbered from 1, unless some other variable is supplied through the startply parameter.\n\nExamples\n\njulia> b = startboard();\n\njulia> variationtosan(b, map(movefromstring, [\"e2e4\", \"e7e5\", \"g1f3\", \"b8c6\"]))\n\"1. e4 e5 2. Nf3 Nc6\"\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.variationtosan-Tuple{SimpleGame,Array{Move,1}}","page":"API Reference","title":"Chess.variationtosan","text":"variationtosan(g::SimpleGame, v::Vector{Move}; movenumbers=true)::String\nvariationtosan(g::Game, v::Vector{Move}; movenumbers=true)::String\n\nConverts a variation to a string in short algebraic notation.\n\nThe vector of moves v should be a sequence of legal moves from the current board position of the game. If movenumbers is true, move numbers will be included in the string.\n\nExamples\n\njulia> g = Game();\n\njulia> domoves!(g, \"d4\", \"Nf6\", \"c4\", \"e6\", \"Nf3\");\n\njulia> variationtosan(g, map(movefromstring, [\"f8b4\", \"c1d2\", \"d8e7\"]))\n\"3... Bb4+ 4. Bd2 Qe7\"\n\n\n\n\n\n","category":"method"},{"location":"api/#Square-Sets-1","page":"API Reference","title":"Square Sets","text":"","category":"section"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"SquareSet\nisempty\nin\nsquares\nunion\nintersect\n-\n+\nissubset\ntoarray\nsquarecount\nfirst\nremovefirst\nissingleton\nonlyfirst\nshift_n\nshift_s\nshift_e\nshift_w\npawnshift_n\npawnshift_s\npawnshift_nw\npawnshift_ne\npawnshift_sw\npawnshift_se\npawnattacks\nknightattacks\nbishopattacks(blockers::SquareSet, ::Square)\nbishopattacksempty\nrookattacks(blockers::SquareSet, ::Square)\nrookattacksempty\nqueenattacks(blockers::SquareSet, ::Square)\nqueenattacksempty\nkingattacks\nsquaresbetween\npprint(ss::SquareSet)\nfilesquares\nranksquares\nSS_EMPTY\nSS_FILE_A\nSS_FILE_B\nSS_FILE_C\nSS_FILE_D\nSS_FILE_E\nSS_FILE_F\nSS_FILE_G\nSS_FILE_H\nSS_RANK_1\nSS_RANK_2\nSS_RANK_3\nSS_RANK_4\nSS_RANK_5\nSS_RANK_6\nSS_RANK_7\nSS_RANK_8","category":"page"},{"location":"api/#Chess.SquareSet","page":"API Reference","title":"Chess.SquareSet","text":"SquareSet\n\nA type representing a set of squares on the chess board.\n\nThe most common ways of obtaining a square set are:\n\nInitializing it with one or more squares, for instance SquareSet(SQ_D4, SQ_E4, SQ_D5, SQ_E5).\nFrom one of the predefined square set constants, like SS_FILE_C (the squares on the C file) or SS_RANK_7 (the squares on the 7th rank).\nBy extracting it from a chess board. See the Board type for details about this.\nBy performing operations transforming or combining one or more square sets to a new square set.\n\nThe union or intersection of two sets can be computed by the functions union and intersect, or by the corresponding binary operators ∪ and ∩. The complement of a square set is denoted by the unary - operator. The difference between two set is obtained by the setdiff function or by the binary - operator. Subset relationships can be tested by the issubset function or the binary operator ⊆.\n\nTo add or remove a square to a square set, use the + or - operators with the square set as the left operand and the square as the right operand. To test whether a square set contains a square, use s in ss or s ∈ ss.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.isempty","page":"API Reference","title":"Base.isempty","text":"isempty(ss::SquareSet)\n\nDetermine whether a square set is the empty set.\n\nExamples\n\njulia> isempty(SS_RANK_1)\nfalse\n\njulia> isempty(SS_EMPTY)\ntrue\n\njulia> isempty(SS_RANK_1 ∩ SS_RANK_2)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.in","page":"API Reference","title":"Base.in","text":"in(s::Square, ss::SquareSet)\n∈(s::Square, ss::SquareSet)\n\nDetermine whether a square is a member of a square set.\n\nExamples\n\njulia> SQ_D7 ∈ SS_RANK_8\nfalse\n\njulia> SQ_D8 ∈ SS_RANK_8\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.squares","page":"API Reference","title":"Chess.squares","text":"squares(ss::SquareSet)\n\nConvert a square set to a vector of squares.\n\nExamples\n\njulia> tostring.(squares(SS_RANK_1))\n8-element Array{String,1}:\n \"a1\"\n \"b1\"\n \"c1\"\n \"d1\"\n \"e1\"\n \"f1\"\n \"g1\"\n \"h1\"\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.union","page":"API Reference","title":"Base.union","text":"union(ss1::SquareSet, ss2::SquareSet)\n∪(ss1::SquareSet, ss2::SquareSet)\n\nCompute the union of two square sets.\n\nThe binary operator ∪ can be used instead of the named function.\n\nExamples\n\njulia> SS_FILE_C ∪ SS_RANK_3\nSquareSet:\n -  -  #  -  -  -  -  -\n -  -  #  -  -  -  -  -\n -  -  #  -  -  -  -  -\n -  -  #  -  -  -  -  -\n -  -  #  -  -  -  -  -\n #  #  #  #  #  #  #  #\n -  -  #  -  -  -  -  -\n -  -  #  -  -  -  -  -\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.intersect","page":"API Reference","title":"Base.intersect","text":"intersect(ss1::SquareSet, ss2::SquareSet)\n∩(ss1::SquareSet, ss2::SquareSet)\n\nCompute the intersection of two square sets.\n\nThe binary operator ∩ can be used instead of the named function.\n\nExamples\n\njulia> SS_FILE_D ∩ SS_RANK_7\nSquareSet:\n -  -  -  -  -  -  -  -\n -  -  -  #  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.:-","page":"API Reference","title":"Base.:-","text":"-(ss::SquareSet)\n\nThe complement of a square set.\n\nExamples\n\njulia> ss = SquareSet(SQ_C4);\n\njulia> SQ_C4 ∈ ss\ntrue\n\njulia> SQ_D4 ∈ ss\nfalse\n\njulia> SQ_C4 ∈ -ss\nfalse\n\njulia> SQ_D4 ∈ -ss\ntrue\n\n\n\n\n\nsetdiff(ss1::SquareSet, ss2::SquareSet)\n-(ss1::SquareSet, ss2::SquareSet)\n\nThe set of all squares that are in ss1, but not in ss2.\n\nExamples\n\njulia> SquareSet(SQ_A1, SQ_A2, SQ_A3, SQ_B1, SQ_B2, SQ_B3) - SS_RANK_2\nSquareSet:\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n #  #  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n #  #  -  -  -  -  -  -\n\n\n\n\n\n-(ss::SquareSet, s::Square)\n\nRemove a square from a square set.\n\nIf a non-member square is removed, the set is returned unchanged.\n\nExamples\n\njulia> SquareSet(SQ_A1, SQ_B1) - SQ_B1 == SquareSet(SQ_A1)\ntrue\n\njulia> SS_FILE_A - SQ_H8 == SS_FILE_A\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.:+","page":"API Reference","title":"Base.:+","text":"+(ss::SquareSet, s::Square)\n\nAdd a square to a square set.\n\nIf a square is added that is already a member is added to the set, the set is returned unchanged.\n\nExamples\n\njulia> SquareSet(SQ_A1) + SQ_H8 == SquareSet(SQ_A1, SQ_H8)\ntrue\n\njulia> SS_FILE_A + SQ_A1 == SS_FILE_A\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.issubset","page":"API Reference","title":"Base.issubset","text":"issubset(ss1::SquareSet, ss2::SquareSet)\n⊆(ss1::SquareSet, ss2::SquareSet)\n\nDetermine whether ss1 is a subset of ss2.\n\nExamples\n\njulia> SquareSet(SQ_A1, SQ_A2) ⊆ SS_FILE_A\ntrue\n\njulia> SquareSet(SQ_A1, SQ_B1) ⊆ SS_FILE_A\nfalse\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.toarray","page":"API Reference","title":"Chess.toarray","text":"toarray(ss::SquareSet, T::Type{<:Number}=Float32)\n\nConvert a square set to a two-dimensional array of the specified element type.\n\nThe returned array's columns corresponds to the files, and the rows to the ranks. The array entries are 1 for the members of the square set, and 0 for non-members.\n\nExamples\n\njulia> toarray(SS_FILE_C ∪ SS_RANK_5, Int)\n8×8 Array{Int64,2}:\n 0  0  1  0  0  0  0  0\n 0  0  1  0  0  0  0  0\n 0  0  1  0  0  0  0  0\n 1  1  1  1  1  1  1  1\n 0  0  1  0  0  0  0  0\n 0  0  1  0  0  0  0  0\n 0  0  1  0  0  0  0  0\n 0  0  1  0  0  0  0  0\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.squarecount","page":"API Reference","title":"Chess.squarecount","text":"squarecount(ss::SquareSet)\n\nThe number of members of a square set.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.first","page":"API Reference","title":"Base.first","text":"first(ss::SquareSet)\n\nThe first square in a square set.\n\nReturns SQ_NONE for an empty square set.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.removefirst","page":"API Reference","title":"Chess.removefirst","text":"removefirst(ss::SquareSet)\n\nRemove the first member of a square set.\n\nExamples\n\njulia> removefirst(SquareSet(SQ_A4, SQ_D5, SQ_F6)) == SquareSet(SQ_D5, SQ_F6)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.issingleton","page":"API Reference","title":"Chess.issingleton","text":"issingleton(ss::SquareSet)\n\nDetermine whether ss contains exactly one square.\n\nExamples\n\njulia> issingleton(SquareSet(SQ_D5))\ntrue\n\njulia> issingleton(SquareSet(SQ_D5, SQ_C5))\nfalse\n\njulia> issingleton(SS_EMPTY)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.onlyfirst","page":"API Reference","title":"Chess.onlyfirst","text":"onlyfirst(ss::SquareSet)\n\nReturn a square set with all squares excep the first removed.\n\nExamples\n\njulia> onlyfirst(SquareSet(SQ_A4, SQ_D5, SQ_F6)) == SquareSet(SQ_A4)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.shift_n","page":"API Reference","title":"Chess.shift_n","text":"shift_n(ss::SquareSet)\n\nShift the square set one step in the 'north' direction.\n\nSquares that are shifted off the edge of the board disappear.\n\njulia> shift_n(SS_RANK_2) == SS_RANK_3\ntrue\n\njulia> shift_n(SquareSet(SQ_D3, SQ_E4, SQ_F8)) == SquareSet(SQ_D4, SQ_E5)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.shift_s","page":"API Reference","title":"Chess.shift_s","text":"shift_s(ss::SquareSet)\n\nShift the square set one step in the 'south' direction.\n\nSquares that are shifted off the edge of the board disappear.\n\nExamples\n\njulia> shift_s(SS_RANK_3) == SS_RANK_2\ntrue\n\njulia> shift_s(SquareSet(SQ_C3, SQ_D2, SQ_E1)) == SquareSet(SQ_C2, SQ_D1)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.shift_e","page":"API Reference","title":"Chess.shift_e","text":"shift_e(ss::SquareSet)\n\nShift the square set one step in the 'east' direction.\n\nSquares that are shifted off the edge of the board disappear.\n\nExamples\n\njulia> shift_e(SS_FILE_F) == SS_FILE_G\ntrue\n\njulia> shift_e(SquareSet(SQ_F5, SQ_G6, SQ_H7)) == SquareSet(SQ_G5, SQ_H6)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.shift_w","page":"API Reference","title":"Chess.shift_w","text":"shift_w(ss::SquareSet)\n\nShift the square set one step in the 'west' direction.\n\nSquares that are shifted off the edge of the board disappear.\n\njulia> shift_w(SS_FILE_C) == SS_FILE_B\ntrue\n\njulia> shift_w(SquareSet(SQ_C5, SQ_B6, SQ_A7)) == SquareSet(SQ_B5, SQ_A6)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.pawnshift_n","page":"API Reference","title":"Chess.pawnshift_n","text":"pawnshift_n(ss::SquareSet)\n\nShift a square set of pawns one step in the 'north' direction.\n\nThis is identical to the shift_n function except that pawnshift_n is a little faster, but will not work for square sets containing squares on the 1st or 8th rank.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.pawnshift_s","page":"API Reference","title":"Chess.pawnshift_s","text":"pawnshift_s(ss::SquareSet)\n\nShift a square set of pawns one step in the 'south' direction.\n\nThis is identical to the shift_s function except that pawnshift_s is a little faster, but will not work for square sets containing squares on the 1st or 8th rank.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.pawnshift_nw","page":"API Reference","title":"Chess.pawnshift_nw","text":"pawnshift_nw(ss::SquareSet)\n\nShift a square set of pawns one step in the 'north west' direction.\n\nThis is identical to calling shift_n followed by shift_w, except that pawnshift_nw is a little faster, but will not work for square sets containing squares on the 1st or 8th rank.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.pawnshift_ne","page":"API Reference","title":"Chess.pawnshift_ne","text":"pawnshift_ne(ss::SquareSet)\n\nShift a square set of pawns one step in the 'north east' direction.\n\nThis is identical to calling shift_n followed by shift_e, except that pawnshift_ne is a little faster, but will not work for square sets containing squares on the 1st or 8th rank.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.pawnshift_sw","page":"API Reference","title":"Chess.pawnshift_sw","text":"pawnshift_sw(ss::SquareSet)\n\nShift a square set of pawns one step in the 'south west' direction.\n\nThis is identical to calling shift_s followed by shift_w, except that pawnshift_sw is a little faster, but will not work for square sets containing squares on the 1st or 8th rank.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.pawnshift_se","page":"API Reference","title":"Chess.pawnshift_se","text":"pawnshift_se(ss::SquareSet)\n\nShift a square set of pawns one step in the 'south east' direction.\n\nThis is identical to calling shift_s followed by shift_e, except that pawnshift_se is a little faster, but will not work for square sets containing squares on the 1st or 8th rank.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.pawnattacks","page":"API Reference","title":"Chess.pawnattacks","text":"pawnttacks(c::PieceColor, s::square)\n\nthe set of squares attacked by a pawn of color c on the square s.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.knightattacks","page":"API Reference","title":"Chess.knightattacks","text":"knightattacks(s::Square)\n\nThe set of squares attacked by a knight on the square s.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.bishopattacks-Tuple{SquareSet,Square}","page":"API Reference","title":"Chess.bishopattacks","text":"bishopattacks(blockers::SquareSet, s::Square)\n\nThe squares attacked by a bishop on s, with blockers being the occupied squares.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.bishopattacksempty","page":"API Reference","title":"Chess.bishopattacksempty","text":"bishopattacksempty(s::Square)\n\nThe set of squares a bishop on s would attack on an otherwise empty board.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.rookattacks-Tuple{SquareSet,Square}","page":"API Reference","title":"Chess.rookattacks","text":"rookattacks(blockers::SquareSet, s::Square)\n\nThe squares attacked by a rook on s, with blockers being the occupied squares.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.rookattacksempty","page":"API Reference","title":"Chess.rookattacksempty","text":"rookattacksempty(s::Square)\n\nThe set of squares a rook on s would attack on an otherwise empty board.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.queenattacks-Tuple{SquareSet,Square}","page":"API Reference","title":"Chess.queenattacks","text":"queenattacks(blockers::SquareSet, s::Square)\n\nThe squares attacked by a queen on s, with blockers being the occupied squares.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.queenattacksempty","page":"API Reference","title":"Chess.queenattacksempty","text":"queenattacksempty(s::Square)\n\nThe set of squares a queen on s would attack on an otherwise empty board.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.kingattacks","page":"API Reference","title":"Chess.kingattacks","text":"kingattacks(s::square)\n\nthe set of squares attacked by a king on the square s.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.squaresbetween","page":"API Reference","title":"Chess.squaresbetween","text":"squaresbetween(s1::Square, s2::Square)\n\nThe set of squares on the line, file or diagonal between s1 and s2.\n\nWhen a queen on s1 would attack s2 on an otherwise empty board, this function returns the set of squares where a piece would block the queen on s1 from attacking s2.\n\nExamples\n\njulia> squaresbetween(SQ_A4, SQ_D4) == SquareSet(SQ_B4, SQ_C4)\ntrue\n\njulia> squaresbetween(SQ_F7, SQ_A2)\nSquareSet:\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  #  -  -  -\n -  -  -  #  -  -  -  -\n -  -  #  -  -  -  -  -\n -  #  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.pprint-Tuple{SquareSet}","page":"API Reference","title":"Chess.pprint","text":"pprint(ss::SquareSet)\n\nPretty-print a square set to the standard output.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.filesquares","page":"API Reference","title":"Chess.filesquares","text":"filesquares(f::SquareFile)\n\nThe set of all squares on the provided file.\n\nExamples\n\njulia> filesquares(FILE_G) == SS_FILE_G\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.ranksquares","page":"API Reference","title":"Chess.ranksquares","text":"ranksquares(r::SquareRank)\n\nThe set of all squares on the provided rank.\n\nExamples\n\njulia> ranksquares(RANK_2) == SS_RANK_2\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.SS_EMPTY","page":"API Reference","title":"Chess.SS_EMPTY","text":"SS_EMPTY\n\nAn empty square set, containing no squares.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Chess.SS_FILE_A","page":"API Reference","title":"Chess.SS_FILE_A","text":"SS_FILE_A\n\nThe square set containing all the squares along the A file.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Chess.SS_FILE_B","page":"API Reference","title":"Chess.SS_FILE_B","text":"SS_FILE_B\n\nThe square set containing all the squares along the B file.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Chess.SS_FILE_C","page":"API Reference","title":"Chess.SS_FILE_C","text":"SS_FILE_C\n\nThe square set containing all the squares along the C file.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Chess.SS_FILE_D","page":"API Reference","title":"Chess.SS_FILE_D","text":"SS_FILE_D\n\nThe square set containing all the squares along the D file.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Chess.SS_FILE_E","page":"API Reference","title":"Chess.SS_FILE_E","text":"SS_FILE_E\n\nThe square set containing all the squares along the E file.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Chess.SS_FILE_F","page":"API Reference","title":"Chess.SS_FILE_F","text":"SS_FILE_F\n\nThe square set containing all the squares along the F file.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Chess.SS_FILE_G","page":"API Reference","title":"Chess.SS_FILE_G","text":"SS_FILE_G\n\nThe square set containing all the squares along the G file.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Chess.SS_FILE_H","page":"API Reference","title":"Chess.SS_FILE_H","text":"SS_FILE_H\n\nThe square set containing all the squares along the H file.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Chess.SS_RANK_1","page":"API Reference","title":"Chess.SS_RANK_1","text":"SS_RANK_1\n\nThe square set containing all the squares along the 1st rank.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Chess.SS_RANK_2","page":"API Reference","title":"Chess.SS_RANK_2","text":"SS_RANK_2\n\nThe square set containing all the squares along the 2nd rank.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Chess.SS_RANK_3","page":"API Reference","title":"Chess.SS_RANK_3","text":"SS_RANK_3\n\nThe square set containing all the squares along the 3rd rank.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Chess.SS_RANK_4","page":"API Reference","title":"Chess.SS_RANK_4","text":"SS_RANK_4\n\nThe square set containing all the squares along the 4th rank.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Chess.SS_RANK_5","page":"API Reference","title":"Chess.SS_RANK_5","text":"SS_RANK_5\n\nThe square set containing all the squares along the 5th rank.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Chess.SS_RANK_6","page":"API Reference","title":"Chess.SS_RANK_6","text":"SS_RANK_6\n\nThe square set containing all the squares along the 6th rank.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Chess.SS_RANK_7","page":"API Reference","title":"Chess.SS_RANK_7","text":"SS_RANK_7\n\nThe square set containing all the squares along the 7th rank.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Chess.SS_RANK_8","page":"API Reference","title":"Chess.SS_RANK_8","text":"SS_RANK_8\n\nThe square set containing all the squares along the 8th rank.\n\n\n\n\n\n","category":"constant"},{"location":"api-index/#Index-1","page":"Index","title":"Index","text":"","category":"section"},{"location":"api-index/#","page":"Index","title":"Index","text":"Modules = [Chess, Chess.PGN, Chess.Book, Chess.UCI]\nOrder   = [:function, :type]","category":"page"},{"location":"manual/#Manual-1","page":"User Guide","title":"Manual","text":"","category":"section"},{"location":"manual/#Boards-1","page":"User Guide","title":"Boards","text":"","category":"section"},{"location":"manual/#Creating-Boards-1","page":"User Guide","title":"Creating Boards","text":"","category":"section"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"A chess board is represented by the Board type. A board is usually obtained in one of four ways:","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"By calling the startboard() function, which returns a board initialized to the standard chess opening position.\nBy calling the fromfen(fen::String) function, which takes a board string in Forsyth-Edwards Notation and returns the corresponding board.\nBy making a move or a sequence of moves on an existing chess board, using a function like domove() or domoves().\nBy calling the board() function on a Game or a SimpleGame, obtaining the current board position in a game. See the section about games below for a discussion of this.","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"Boards are printed in a readable ASCII notation:","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"julia> startboard()\nBoard (rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq -):\n r  n  b  q  k  b  n  r\n p  p  p  p  p  p  p  p\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n P  P  P  P  P  P  P  P\n R  N  B  Q  K  B  N  R","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"If you are using Chess.jl through a Pluto or Jupyter notebook, you'll see a graphical board, along with a link for opening the board in lichess.","category":"page"},{"location":"manual/#Making-and-Unmaking-Moves-1","page":"User Guide","title":"Making and Unmaking Moves","text":"","category":"section"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"Given a chess board, you will usually want to modify the board by making some moves. The most straightforward way to do this is with the domove function, which takes two parameters: A chess board and a move. The move can be either a value of the Move type or a string representing a move in UCI or SAN notation.","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"The Move type is described in more detail in the API reference. For now, let's see how to use domove to make a move given in short algebraic notation (SAN):","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"julia> domove(b, \"e4\")\nBoard (rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq -):\n r  n  b  q  k  b  n  r\n p  p  p  p  p  p  p  p\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  P  -  -  -\n -  -  -  -  -  -  -  -\n P  P  P  P  -  P  P  P\n R  N  B  Q  K  B  N  R","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"There is also a function domoves that takes a series of several moves and executes all of them:","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"julia> b = startboard();\n\njulia> domoves(b, \"e4\", \"e5\", \"Nf3\", \"Nc6\", \"Bb5\")\nBoard (r1bqkbnr/pppp1ppp/2n5/1B2p3/4P3/5N2/PPPP1PPP/RNBQK2R b KQkq -):\n r  -  b  q  k  b  n  r\n p  p  p  p  -  p  p  p\n -  -  n  -  -  -  -  -\n -  B  -  -  p  -  -  -\n -  -  -  -  P  -  -  -\n -  -  -  -  -  N  -  -\n P  P  P  P  -  P  P  P\n R  N  B  Q  K  -  -  R","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"Note that both of these functions return new boards: The original board b is left untouched. This is often convenient, but also results in a considerable amount of copying, and for some types of applications, excessive heap allocations. When this is a problem, there are alternative functions domove! and domoves! that do modify the input board.","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"The domove! function destructively modifies the input board by making a move, but returns an UndoInfo value that can later be used to retract the move, using the undomove! function:","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"julia> b = startboard();\n\njulia> u = domove!(b, \"d4\");\n\njulia> b\nBoard (rnbqkbnr/pppppppp/8/8/3P4/8/PPP1PPPP/RNBQKBNR b KQkq -):\n r  n  b  q  k  b  n  r\n p  p  p  p  p  p  p  p\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  P  -  -  -  -\n -  -  -  -  -  -  -  -\n P  P  P  -  P  P  P  P\n R  N  B  Q  K  B  N  R\n\njulia> undomove!(b, u);\n\njulia> b\nBoard (rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq -):\n r  n  b  q  k  b  n  r\n p  p  p  p  p  p  p  p\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n P  P  P  P  P  P  P  P\n R  N  B  Q  K  B  N  R","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"Similarly, domoves! takes a board and a sequence of moves and executes them all, destructively modifying the board. Unlike domove!, this operation is irreversible. There is no way to retract the moves and return to the original board.","category":"page"},{"location":"manual/#Extracting-Information-from-a-Board-1","page":"User Guide","title":"Extracting Information from a Board","text":"","category":"section"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"For the purposes of this section, we'll construct an early opening position from a popular Ruy Lopez line:","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"julia> b = domoves(startboard(), \"e4\", \"e5\", \"Nf3\", \"Nc6\", \"Bb5\", \"Nf6\", \"O-O\")\nBoard (r1bqkb1r/pppp1ppp/2n2n2/1B2p3/4P3/5N2/PPPP1PPP/RNBQ1RK1 b kq -):\n r  -  b  q  k  b  -  r\n p  p  p  p  -  p  p  p\n -  -  n  -  -  n  -  -\n -  B  -  -  p  -  -  -\n -  -  -  -  P  -  -  -\n -  -  -  -  -  N  -  -\n P  P  P  P  -  P  P  P\n R  N  B  Q  -  R  K  -","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"To ask what piece occupies a given square, use the pieceon function, which takes two arguments: A board and a square. The square can be either a Square value (discussed in the API reference) or a string. The return value is a Piece, which can have one of the values EMPTY (for an empty square), PIECE_WP, PIECE_WN, PIECE_WB, PIECE_WR, PIECE_WQ, PIECE_WK, PIECE_BP, PIECE_BN, PIECE_BB, PIECE_BR, PIECE_BQ or PIECE_BK:","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"julia> pieceon(b, \"e4\")\nPIECE_WP\n\njulia> pieceon(b, \"b8\")\nEMPTY","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"It is also possible to ask for the set of all squares occupied by pieces of a given color and/or type. Here is an example that returns the set of all squares occupied by white pawns:","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"julia> pawns(b, WHITE)\nSquareSet:\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  #  -  -  -\n -  -  -  -  -  -  -  -\n #  #  #  #  -  #  #  #\n -  -  -  -  -  -  -  -","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"The return value is of type SquareSet, which is discussed in depth in the API reference. If you are using a Pluto or Jupyter notebook, the square set will be displayed graphically.","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"Here is a similar example that returns all squares occupied by black pieces:","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"julia> pieces(b, BLACK)\nSquareSet:\n #  -  #  #  #  #  -  #\n #  #  #  #  -  #  #  #\n -  -  #  -  -  #  -  -\n -  -  -  -  #  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"A few other functions returning square sets are knights, bishops, rooks, queens, kings, emptysquares and occupiedsquares.","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"The function sidetomove returns the current side to move, in the form of a PieceColor value that can be either WHITE or BLACK:","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"julia> sidetomove(b)\nBLACK","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"A few other functions that are frequently useful when inspecting boards are ischeck (is the side to move in check?), ischeckmate (is the side to move checkmated?) and isdraw (is the position an immediate draw?).","category":"page"},{"location":"manual/#Generating-Legal-Moves-1","page":"User Guide","title":"Generating Legal Moves","text":"","category":"section"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"The legal moves for a board can be obtained with the moves function:","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"julia> b = fromfen(\"8/5P2/3k4/8/8/6N1/3B4/4KR2 w - -\")\nBoard (8/5P2/3k4/8/8/6N1/3B4/4KR2 w - -):\n -  -  -  -  -  -  -  -\n -  -  -  -  -  P  -  -\n -  -  -  k  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  N  -\n -  -  -  B  -  -  -  -\n -  -  -  -  K  R  -  -\n\njulia> moves(b)\n27-element MoveList:\n Move(f7f8q)\n Move(f7f8r)\n Move(f7f8b)\n Move(f7f8n)\n Move(g3e4)\n Move(g3e2)\n Move(g3f5)\n Move(g3h5)\n ⋮\n Move(f1f4)\n Move(f1f3)\n Move(f1f2)\n Move(f1g1)\n Move(f1h1)\n Move(e1d1)\n Move(e1e2)\n Move(e1f2)","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"The return value is a MoveList, a subtype of AbstractArray. It contains all the legal moves for the position.","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"Here is an example of a simple way to find all moves that give check for the above board:","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"julia> filter(m -> ischeck(domove(b, m)), moves(b))\n7-element Array{Move,1}:\n Move(f7f8q)\n Move(f7f8b)\n Move(g3e4)\n Move(g3f5)\n Move(d2b4)\n Move(d2f4)\n Move(f1f6)","category":"page"},{"location":"manual/#Games-1","page":"User Guide","title":"Games","text":"","category":"section"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"There are two types for representing chess games: SimpleGame is a basic type that contains little more than PGN headers (player names, game result, etc.) and a sequence of moves. Game is a more full-featured type that supports annotated, tree-like games with comments and variations. If you don't need these features, SimpleGame is usually a better choice, because it performs much better.","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"For the rest of this section, we will only discuss the more complex Game type. With a few exceptions (that will be pointed out), methods with identical names and behavior exist for the SimpleGame type.","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"To create a game from the standard chess position, use the parameterless Game constructor:","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"julia> g = Game()\nGame:\n  *","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"The printed representation of the game consists of the moves in short algebraic notation (in this case, because we just constructed a game, there are no moves) and an asterisk (*) showing our current position in the game.","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"There is also a version of this constructor that takes a string representing a board in Forsyth-Edwards Notation, and uses that instead of the standard chess starting position as the root position of the game.","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"You can obtain the current position board position of the game with the board function, which returns a value of type Board:","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"julia> board(g)\nBoard (rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq -):\n r  n  b  q  k  b  n  r\n p  p  p  p  p  p  p  p\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n P  P  P  P  P  P  P  P\n R  N  B  Q  K  B  N  R","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"To update the game with a new move, use the domove! function:","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"julia> domove!(g, \"Nf3\")\nGame:\n Nf3 *\n\njulia> domove!(g, \"d5\")\nGame:\n Nf3 d5 *\n\njulia> domove!(g, \"d4\")\nGame:\n Nf3 d5 d4 *","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"A move can be taken back by the back! function:","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"julia> back!(g)\nGame:\n Nf3 d5 * d4","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"Note that the last move, d4, is not removed from the game. It's still there, the only result of calling back! is that our current location in the game (indicated by the asterisk) moved one step back. The current board position is the one before the move d4 was made:","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"julia> board(g)\nBoard (rnbqkbnr/ppp1pppp/8/3p4/8/5N2/PPPPPPPP/RNBQKB1R w KQkq -):\n r  n  b  q  k  b  n  r\n p  p  p  -  p  p  p  p\n -  -  -  -  -  -  -  -\n -  -  -  p  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  N  -  -\n P  P  P  P  P  P  P  P\n R  N  B  Q  K  B  -  R","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"It's possible to step forward again by executing forward!(g):","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"julia> forward!(g)\nGame:\n Nf3 d5 d4 *\n\njulia> board(g)\nBoard (rnbqkbnr/ppp1pppp/8/3p4/3P4/5N2/PPP1PPPP/RNBQKB1R b KQkq -):\n r  n  b  q  k  b  n  r\n p  p  p  -  p  p  p  p\n -  -  -  -  -  -  -  -\n -  -  -  p  -  -  -  -\n -  -  -  P  -  -  -  -\n -  -  -  -  -  N  -  -\n P  P  P  -  P  P  P  P\n R  N  B  Q  K  B  -  R","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"There are also functions tobeginning! and toend! that jump all the way to the beginning or the end of the game (notice the position of the asterisk indicating the current location in the game in both cases):","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"julia> tobeginning!(g)\nGame:\n * Nf3 d5 d4\n\njulia> toend!(g)\nGame:\n Nf3 d5 d4 *","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"If you call domove! at any point other than the end of the game, the previous game continuation will be deleted:","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"julia> toend!(g)\nGame:\n Nf3 d5 d4 *\n\njulia> back!(g)\nGame:\n Nf3 d5 * d4\n\njulia> domove!(g, \"c4\")\nGame:\n Nf3 d5 c4 *","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"This is not always desirable. Sometimes what we want to do is not to overwrite the existing continuation, but to insert a new variation. When this is what we want, the solution is to use addmove! instead of domove!. The two functions behave identically when at the end of the game, but at any earlier point of the game, addmove! inserts the new move as an alternative variation, keeping the existing move (and any previously added variations).","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"Let's add 1... Nf6 as an alternative to 1... d5 in our existing game. We first have to navigate to the place in the game where we want to insert the move, and then call addmove!:","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"julia> tobeginning!(g)\nGame:\n * Nf3 d5 c4\n\njulia> forward!(g)\nGame:\n Nf3 * d5 c4\n\njulia> addmove!(g, \"Nf6\")\nGame:\n Nf3 d5 (Nf6 *) c4","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"Alternative variations are printed in parens. Of course, variations can be nested.","category":"page"},{"location":"manual/#PGN-Import-and-Export-1","page":"User Guide","title":"PGN Import and Export","text":"","category":"section"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"This section describes import and export of chess games in the popular PGN format. PGN is a rather awkward and complicated format, and a lot of the \"PGN files\" out there on the Internet don't quite follow the standard, and are broken in various ways. The functions described in this section does a fairly good job of handling correct PGNs (although bugs are possible), but will often fail on the various not-quite-PGNs found on the Internet.","category":"page"},{"location":"manual/#Creating-a-game-from-a-PGN-string-1","page":"User Guide","title":"Creating a game from a PGN string","text":"","category":"section"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"Given a PGN string, the gamefrompgn function creates a game object from the string (throwing a PGNException on failure). By default, the return value is a SimpleGame containing only the moves of the game, without any comments, variations or numeric annotatin glyphs. If the optional named parameter annotations is true, the return value is a Game with all annotations included:","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"julia> pgnstring = \"\"\"\n       [Event \"F/S Return Match\"]\n       [Site \"Belgrade, Serbia JUG\"]\n       [Date \"1992.11.04\"]\n       [Round \"29\"]\n       [White \"Fischer, Robert J.\"]\n       [Black \"Spassky, Boris V.\"]\n       [Result \"1/2-1/2\"]\n\n       1. e4 e5 2. Nf3 Nc6 3. Bb5 a6 4. Ba4 Nf6 5. O-O Be7 6. Re1 b5 7. Bb3 d6 8. c3\n       O-O 9. h3 Nb8 10. d4 Nbd7 11. c4 c6 12. cxb5 axb5 13. Nc3 Bb7 14. Bg5 b4 15.\n       Nb1 h6 16. Bh4 c5 17. dxe5 Nxe4 18. Bxe7 Qxe7 19. exd6 Qf6 20. Nbd2 Nxd6 21.\n       Nc4 Nxc4 22. Bxc4 Nb6 23. Ne5 Rae8 24. Bxf7+ Rxf7 25. Nxf7 Rxe1+ 26. Qxe1 Kxf7\n       27. Qe3 Qg5 28. Qxg5 hxg5 29. b3 Ke6 30. a3 Kd6 31. axb4 cxb4 32. Ra5 Nd5 33.\n       f3 Bc8 34. Kf2 Bf5 35. Ra7 g6 36. Ra6+ Kc5 37. Ke1 Nf4 38. g3 Nxh3 39. Kd2 Kb5\n       40. Rd6 Kc5 41. Ra6 Nf2 42. g4 Bd3 43. Re6 1/2-1/2\n       \"\"\";\n\njulia> sg = gamefromstring(pgnstring)\nSimpleGame:\n * e4 e5 Nf3 Nc6 Bb5 a6 Ba4 Nf6 O-O Be7 Re1 b5 Bb3 d6 c3 O-O h3 Nb8 d4 Nbd7 c4 c6 cxb5 axb5 Nc3 Bb7 Bg5 b4 Nb1 h6 Bh4 c5 dxe5 Nxe4 Bxe7 Qxe7 exd6 Qf6 Nbd2 Nxd6 Nc4 Nxc4 Bxc4 Nb6 Ne5 Rae8 Bxf7+ Rxf7 Nxf7 Rxe1+ Qxe1 Kxf7 Qe3 Qg5 Qxg5 hxg5 b3 Ke6 a3 Kd6 axb4 cxb4 Ra5 Nd5 f3 Bc8 Kf2 Bf5 Ra7 g6 Ra6+ Kc5 Ke1 Nf4 g3 Nxh3 Kd2 Kb5 Rd6 Kc5 Ra6 Nf2 g4 Bd3 Re6\n\njulia> g = gamefromstring(pgnstring, annotations=true)\nGame:\n * e4 e5 Nf3 Nc6 Bb5 a6 Ba4 Nf6 O-O Be7 Re1 b5 Bb3 d6 c3 O-O h3 Nb8 d4 Nbd7 c4 c6 cxb5 axb5 Nc3 Bb7 Bg5 b4 Nb1 h6 Bh4 c5 dxe5 Nxe4 Bxe7 Qxe7 exd6 Qf6 Nbd2 Nxd6 Nc4 Nxc4 Bxc4 Nb6 Ne5 Rae8 Bxf7+ Rxf7 Nxf7 Rxe1+ Qxe1 Kxf7 Qe3 Qg5 Qxg5 hxg5 b3 Ke6 a3 Kd6 axb4 cxb4 Ra5 Nd5 f3 Bc8 Kf2 Bf5 Ra7 g6 Ra6+ Kc5 Ke1 Nf4 g3 Nxh3 Kd2 Kb5 Rd6 Kc5 Ra6 Nf2 g4 Bd3 Re6","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"Unless you really need the annotations, importing to a SimpleGame is the preferred choice. A SimpleGame is much faster to create and consumes less memory.","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"Converting a game to a PGN string is done by the gametopgn function. This works for both SimpleGame and Game objects:","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"julia> gametopgn(sg)\n\"[Event \\\"F/S Return Match\\\"]\\n[Site \\\"Belgrade, Serbia JUG\\\"]\\n[Date \\\"1992.11.04\\\"]\\n[Round \\\"29\\\"]\\n[White \\\"Fischer, Robert J.\\\"]\\n[Black \\\"Spassky, Boris V.\\\"]\\n[Result \\\"1/2-1/2\\\"]\\n\\n1. e4 e5 2. Nf3 Nc6 3. Bb5 a6 4. Ba4 Nf6 5. O-O Be7 6. Re1 b5 7. Bb3 d6 8. c3 O-O 9. h3 Nb8 10. d4 Nbd7 11. c4 c6 12. cxb5 axb5 13. Nc3 Bb7 14. Bg5 b4 15. Nb1 h6 16. Bh4 c5 17. dxe5 Nxe4 18. Bxe7 Qxe7 19. exd6 Qf6 20. Nbd2 Nxd6 21. Nc4 Nxc4 22. Bxc4 Nb6 23. Ne5 Rae8 24. Bxf7+ Rxf7 25. Nxf7 Rxe1+ 26. Qxe1 Kxf7 27. Qe3 Qg5 28. Qxg5 hxg5 29. b3 Ke6 30. a3 Kd6 31. axb4 cxb4 32. Ra5 Nd5 33. f3 Bc8 34. Kf2 Bf5 35. Ra7 g6 36. Ra6+ Kc5 37. Ke1 Nf4 38. g3 Nxh3 39. Kd2 Kb5 40. Rd6 Kc5 41. Ra6 Nf2 42. g4 Bd3 43. Re6 1/2-1/2\\n\"\n\njulia> gametopgn(g)\n\"[Event \\\"F/S Return Match\\\"]\\n[Site \\\"Belgrade, Serbia JUG\\\"]\\n[Date \\\"1992.11.04\\\"]\\n[Round \\\"29\\\"]\\n[White \\\"Fischer, Robert J.\\\"]\\n[Black \\\"Spassky, Boris V.\\\"]\\n[Result \\\"1/2-1/2\\\"]\\n\\n1. e4 e5 2. Nf3 Nc6 3. Bb5 a6 4. Ba4 Nf6 5. O-O Be7 6. Re1 b5 7. Bb3 d6 8. c3 O-O 9. h3 Nb8 10. d4 Nbd7 11. c4 c6 12. cxb5 axb5 13. Nc3 Bb7 14. Bg5 b4 15. Nb1 h6 16. Bh4 c5 17. dxe5 Nxe4 18. Bxe7 Qxe7 19. exd6 Qf6 20. Nbd2 Nxd6 21. Nc4 Nxc4 22. Bxc4 Nb6 23. Ne5 Rae8 24. Bxf7+ Rxf7 25. Nxf7 Rxe1+ 26. Qxe1 Kxf7 27. Qe3 Qg5 28. Qxg5 hxg5 29. b3 Ke6 30. a3 Kd6 31. axb4 cxb4 32. Ra5 Nd5 33. f3 Bc8 34. Kf2 Bf5 35. Ra7 g6 36. Ra6+ Kc5 37. Ke1 Nf4 38. g3 Nxh3 39. Kd2 Kb5 40. Rd6 Kc5 41. Ra6 Nf2 42. g4 Bd3 43. Re6 1/2-1/2\\n\"","category":"page"},{"location":"manual/#Working-with-PGN-files-1","page":"User Guide","title":"Working with PGN files","text":"","category":"section"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"Given a file with one or more PGN games, the function gamesinfile returns a Channel of game objects, one for each game in the file. Like gamefromstring, gamesinfile takes an optional named parameter annotations. If annotations is false (the default), you get a channel of SimpleGames. If it's true, you get a channel of Games with the annotations (comments, variations and numeric annotation glyphs) included in the PGN games.","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"As an example, here's a function that scans a PGN file and returns a vector of all games that end in checkmate:","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"function checkmategames(pgnfilename::String)\n    result = SimpleGame[]\n    for g in gamesinfile(pgnfilename)\n        toend!(g)\n        if ischeckmate(g)\n            push!(result, g)\n        end\n    end\n    result\nend","category":"page"},{"location":"manual/#Opening-Books-1","page":"User Guide","title":"Opening Books","text":"","category":"section"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"The Chess.Book module contains utilities for processing PGN game files and building opening trees with move statistics, and for looking up board positions in an opening tree.","category":"page"},{"location":"manual/#Creating-Book-Files-1","page":"User Guide","title":"Creating Book Files","text":"","category":"section"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"To create an opening book, use the createbook function, and supply it with one or more PGN files:","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"julia> using Chess, Chess.Book\n\njulia> bk = createbook(\"/path/to/SomeGameDatabase.pgn\");","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"createbook also accepts a number of optional named parameters that configure the scoring of the book moves and what moves are included and excluded. See the function documentation for details.","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"Please note that while Chess.jl's PGN parser works pretty well for processing correct PGN, it's not very robust when it comes to parsing \"PGN files\" that fail to follow the standard. Annoyingly, even popular software like ChessBase sometimes generate broken PGN files (failing to escape quotes in strings is a particularly frequent problem). If you feed createbook with a non-standard PGN file, it will often fail.","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"For large databases with millions of games, creating a book consumes a lot of memory, since all the data is stored in RAM.","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"The first thing you want to do after creating an opening book is probably to write it to disk. Assuming that we stored the result of createbook in a variable bk, like above, we save the book like this:","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"julia> writebooktofile(bk, \"/path/to/mybook.obk\")","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"Opening book files can be very large, because they contain every move that has been played even once in the input PGN databases. The function purgebook can create a smaller book from a large book by only including moves which have been played several times and/or have high scores (the score of a move is computed based on how well it has been formed and by how popular it is, with more weight being given to recent games and games played by strong players). purgebook has two required parameters, an input file name and an output file name. The optional named parameters minscore (default 0) and mingamecount (default 5) control what moves are included in the output file.","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"Example usage:","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"julia> purgebook(\"/path/to/mybook.obk\", \"/path/to/mybook-small.obk\", minscore=0.01, mingamecount=10)","category":"page"},{"location":"manual/#Looking-Up-Positions-in-a-Book-File-1","page":"User Guide","title":"Looking Up Positions in a Book File","text":"","category":"section"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"Given a Board value and an opening book file, the function findbookentries find all the opening book entries for that board position. For instance, this gives us all book moves for the standard opening position:","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"julia> b = startboard();\n\njulia> entries = findbookentries(b, \"/path/to/mybook.obk\");","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"The return value is a vector of BookEntry structs. This struct contains the following slots:","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"move: The move played. For space reasons, the move is stored as an Int32 value. To get the actual Move, do Move(entry.move).\nwins: The number of times the player who played this move won the game.\ndraws: The number of times the game was drawn when this move was played.\nlosses: The number of times the player who played this move lost the game.\nelo: The Elo rating of the highest rated player who played this move.\noppelo: The Elo rating of the highest rated opponent against whom this move was played.\nfirstyear: The first year this move was played.\nlastyear: The last year this move was played.\nscore: The score of the move, used to decide the probability that this move is played when picking a book move to play. The score is computed based on the move's win/loss/draw statistics and its popularity, especially in recent games and games with strong players.","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"To print out the stats for all moves for a position, use printbookentries:","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"julia> printbookentries(startboard(), \"/path/to/mybook.obk\")\ne4 0.479 53.5% (+359254, =342397, -290198) 2881 2881 1990 2018\nd4 0.343 55.1% (+283148, =280733, -204292) 2881 2881 1990 2018\nNf3 0.092 55.9% (+79513, =82970, -54128) 2881 2881 1990 2018\nc4 0.064 55.6% (+53691, =52039, -37534) 2881 2881 1990 2018\ng3 0.007 56.0% (+6639, =5986, -4584) 2868 2851 1990 2018\nb3 0.006 51.9% (+3532, =3060, -3154) 2857 2881 1990 2018\nf4 0.004 45.0% (+2093, =1974, -2775) 2837 2843 1990 2018\nNc3 0.002 49.1% (+1247, =991, -1309) 2834 2851 1990 2018\nb4 0.001 44.9% (+535, =431, -704) 2834 2795 1990 2018\ne3 0.001 43.6% (+269, =219, -381) 2857 2843 1990 2018\nd3 0.000 47.3% (+242, =216, -282) 2843 2819 1990 2018\na3 0.000 48.2% (+223, =182, -246) 2834 2771 1991 2018\nc3 0.000 44.0% (+98, =100, -138) 2773 2767 1991 2018\ng4 0.000 38.6% (+55, =43, -100) 2795 2795 1991 2018\nh3 0.000 48.4% (+47, =30, -51) 2834 2782 1990 2018\nh4 0.000 32.6% (+10, =8, -25) 2545 2722 1994 2018\nNh3 0.000 47.5% (+13, =12, -15) 2834 2653 1993 2018\nNa3 0.000 68.8% (+9, =4, -3) 2834 2528 1992 2018\na4 0.000 59.4% (+7, =5, -4) 2843 2788 1996 2018\nf3 0.000 36.7% (+4, =3, -8) 2834 2843 1999 2018","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"On each output line, we see the move, the probability that this move will be picked (by pickbookmove, described below), the percentage score from the point of view of the side to move, the number of wins, draws and losses, the maximum rating, the maximum opponent rating, the first year played, and the last year played.","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"To pick a book move, use pickbookmove:","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"julia> b = domoves(startboard(), \"e4\", \"c5\");\n\njulia> pickbookmove(b, \"/path/to/mybook.obk\", minscore=0.01, mingamecount=10)\nMove(g1f3)","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"The optional parameters minscore and mingamecount are used when you want to prevent moves that have almost never been played or have a very low score from being picked.","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"If no book moves is found for the input position, pickbookmove returns nothing.","category":"page"},{"location":"manual/#Interacting-with-UCI-Engines-1","page":"User Guide","title":"Interacting with UCI Engines","text":"","category":"section"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"This section describes how to run and interact with chess engines using the Universal Chess Interface protocol. There are hundreds of UCI chess engines out there. A free, strong and popular choice is Stockfish. Stockfish is used as an example in this section, but any other engine should work just as well.","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"For the remainder of this section, it is assumed that you know the basics of how the UCI protocol works, and that stockfish is found somewhere in your PATH environment variable","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"An engine is started by calling the runengine command, which takes the path to the engine as a parameter:","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"julia> using Chess, Chess.UCI\n\njulia> sf = runengine(\"stockfish\");","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"The first thing you want to do after starting a chess engine is probably to set some UCI parameter values. This can be done with setoption:","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"julia> setoption(sf, \"Hash\", 256)","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"You can send a game to the engine with setboard:","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"julia> g = SimpleGame();\n\njulia> domoves!(g, \"f4\", \"e5\", \"fxe5\", \"d6\", \"exd6\", \"Bxd6\", \"Nc3\")\n\njulia> setboard(sf, g)","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"The second parameter to setboard can also be a Board or a Game.","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"To ask the engine to search the position you just sent to it, use the search function. search has two required parameters: The engine and the UCI go command we want to send to it. There is also an optional named parameter infoaction. This parameter is a function that takes each of the engine's info output lines and does something to them. Here's an example where we just print the engine output with println as our infoaction:","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"julia> search(sf, \"go depth 10\", infoaction=println)\ninfo depth 1 seldepth 1 multipv 1 score cp 275 nodes 42 nps 21000 tbhits 0 time 2 pv d6c5\ninfo depth 2 seldepth 2 multipv 1 score cp 93 nodes 118 nps 59000 tbhits 0 time 2 pv d6c5 g2g3\ninfo depth 3 seldepth 3 multipv 1 score cp 83 nodes 207 nps 103500 tbhits 0 time 2 pv a7a6 g2g3 d6c5\ninfo depth 4 seldepth 4 multipv 1 score cp 23 nodes 809 nps 404500 tbhits 0 time 2 pv g8h6 d2d4 h6g4 g2g3\ninfo depth 5 seldepth 6 multipv 1 score cp -22 nodes 1669 nps 556333 tbhits 0 time 3 pv g8e7 e2e3 e8g8 g1f3 f8e8 d2d4\ninfo depth 6 seldepth 7 multipv 1 score mate 3 nodes 2293 nps 764333 tbhits 0 time 3 pv d8h4 g2g3 d6g3 h2g3\ninfo depth 7 seldepth 6 multipv 1 score mate 3 nodes 2337 nps 779000 tbhits 0 time 3 pv d8h4 g2g3 d6g3 h2g3 h4g3\ninfo depth 8 seldepth 6 multipv 1 score mate 3 nodes 2387 nps 795666 tbhits 0 time 3 pv d8h4 g2g3 d6g3 h2g3 h4g3\ninfo depth 9 seldepth 6 multipv 1 score mate 3 nodes 2436 nps 812000 tbhits 0 time 3 pv d8h4 g2g3 d6g3 h2g3 h4g3\ninfo depth 10 seldepth 6 multipv 1 score mate 3 nodes 2502 nps 625500 tbhits 0 time 4 pv d8h4 g2g3 d6g3 h2g3 h4g3\nBestMoveInfo (best=d8h4, ponder=g2g3)","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"The return value is a BestMoveInfo, a struct containing the two slots bestmove (the best move returned by the engine, a Move) and ponder (the ponder move returned by the engine, a Move or nothing).","category":"page"},{"location":"manual/#","page":"User Guide","title":"User Guide","text":"In most cases, we want something more easily manipulatable than the raw string values sent by the engine's info lines in our infoaction function. The function parseinfoline takes care of this. It takes an info string as input and returns a SearchInfo value, a struct that contains the various components of the info line as its slots. See the documentation for SearchInfo in the API reference for details.","category":"page"},{"location":"#Chess.jl-1","page":"Home","title":"Chess.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A Julia chess programming library.","category":"page"},{"location":"#Introduction-1","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This package contains various utilities for computer chess programming. There are functions for creating and manipulating chess games, chess positions and sets of squares on the board, for reading and writing chess games in the popular PGN format (including support for comments and variations), for creating opening trees, and for interacting with UCI chess engines.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The library was designed for the purpose of doing machine learning experiments in computer chess, but it should also be suitable for most other types of chess software.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Chess.jl can be installed from the package manager i Julia's REPL:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(@v1.5) pkg> add Chess","category":"page"}]
}
