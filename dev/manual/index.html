<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · Chess.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Chess.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>Tutorial</a><ul class="internal"><li><a class="toctext" href="#Boards-1">Boards</a></li><li><a class="toctext" href="#Pieces,-Piece-Colors,-and-Piece-Types-1">Pieces, Piece Colors, and Piece Types</a></li><li><a class="toctext" href="#Squares-1">Squares</a></li><li><a class="toctext" href="#Moves-1">Moves</a></li><li><a class="toctext" href="#Square-Sets-1">Square Sets</a></li><li><a class="toctext" href="#Games-1">Games</a></li><li><a class="toctext" href="#PGN-Import-and-Export-1">PGN Import and Export</a></li><li><a class="toctext" href="#Opening-Books-1">Opening Books</a></li><li><a class="toctext" href="#Interacting-with-UCI-Engines-1">Interacting with UCI Engines</a></li></ul></li><li><a class="toctext" href="../api/">API Reference</a></li><li><a class="toctext" href="../api-index/">Index</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Tutorial</a></li></ul><a class="edit-page" href="https://github.com/romstad/Chess.jl/blob/master/docs/src/manual.md#L"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Tutorial</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Tutorial-1" href="#Tutorial-1">Tutorial</a></h1><p>Chess.jl is designed to work well with <a href="https://plutojl.org">Pluto</a>. For interactive use, working with Chess.jl under Pluto is much nicer than from the Julia REPL. A slightly modified version of this tutorial also exists as a Pluto notebook, available from <a href="https://romstad.github.io/Chess.jl/tutorial/tutorial.jl">this link</a>. In order to run it, follow these steps:</p><ol><li>Make sure you have Julia 1.6 or later installed.</li><li>Add the packages Chess, Pluto and PlutoUI to your environment.</li><li>From the Julia REPL, do:</li></ol><pre><code class="language-julia-repl">julia&gt; using PlutoUI

julia&gt; Pluto.run()</code></pre><p>Pluto will now open in a browser window. In the &quot;Open from file&quot; textbox, navigate to the location of the downloaded <code>tutorial.jl</code> file, and press &quot;Open&quot;.</p><p>There is also a <a href="https://romstad.github.io/Chess.jl/tutorial/">static HTML version of the tutorial notebook</a>.</p><h2><a class="nav-anchor" id="Boards-1" href="#Boards-1">Boards</a></h2><h3><a class="nav-anchor" id="Creating-boards-1" href="#Creating-boards-1">Creating boards</a></h3><p>A chess board is represented by the <code>Board</code> type. A board is usually obtained in one of five ways:</p><ol><li>By calling the <code>startboard()</code> function, which returns a board initialized to the standard chess opening position.</li><li>By using the <code>@startboard</code> macro, which allows you to provide a sequence of moves from the starting position.</li><li>By calling the <code>fromfen()</code> function, which takes a board string in <a href="https://en.wikipedia.org/wiki/Forsyth–Edwards_Notation">Forsyth-Edwards Notation</a> and returns the corresponding board.</li><li>By making a move or a sequence of moves on an existing chess board, using a function like <code>domove()</code> or <code>domoves()</code>.</li><li>By calling the <code>board()</code> function on a <code>Game</code> or a <code>SimpleGame</code>, obtaining the current board position in a game. See the section on games later in this tutorial for a discussion of these types)</li></ol><p>Let&#39;s begin with the most basic way of creating a chess board: The <code>startboard()</code> function.</p><pre><code class="language-julia-repl">julia&gt; startboard()
Board (rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq -):
 r  n  b  q  k  b  n  r
 p  p  p  p  p  p  p  p
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 P  P  P  P  P  P  P  P
 R  N  B  Q  K  B  N  R</code></pre><p>If you are using Chess.jl through a Pluto or Jupyter notebook, you&#39;ll see a graphical board, along with a link for opening the board in <a href="http://lichess.org">lichess</a>.</p><p>Sometimes you want to set up a board position by making some moves from the starting position. You could do this by first calling <code>startboard()</code> and then calling the <code>domoves()</code> or <code>domoves!()</code> function (more about those later in this tutorial), but that quickly becomes tedious for interactive use. The <code>@startboard</code> macro can be used as a convenient shortcut:</p><pre><code class="language-julia-repl">julia&gt; @startboard e4 e5 Nf3 Nc6 Bb5
Board (r1bqkbnr/pppp1ppp/2n5/1B2p3/4P3/5N2/PPPP1PPP/RNBQK2R b KQkq -):
 r  -  b  q  k  b  n  r
 p  p  p  p  -  p  p  p
 -  -  n  -  -  -  -  -
 -  B  -  -  p  -  -  -
 -  -  -  -  P  -  -  -
 -  -  -  -  -  N  -  -
 P  P  P  P  -  P  P  P
 R  N  B  Q  K  -  -  R</code></pre><p>Annoyingly, the minus sign in standard castling notation (<code>O-O</code> for kingside castling and <code>O-O-O</code> for queenside castling) confuses Julia&#39;s parser. For castling moves, just skip the minus sign and write <code>OO</code> or <code>OOO</code>, as in the following example.</p><pre><code class="language-julia-repl">julia&gt; @startboard e4 c5 Nf3 d6 d4 cxd4 Nxd4 Nf6 Nc3 g6 Be3 Bg7 f3 OO Qd2 Nc6 OOO
Board (r1bq1rk1/pp2ppbp/2np1np1/8/3NP3/2N1BP2/PPPQ2PP/2KR1B1R b - -):
 r  -  b  q  -  r  k  -
 p  p  -  -  p  p  b  p
 -  -  n  p  -  n  p  -
 -  -  -  -  -  -  -  -
 -  -  -  N  P  -  -  -
 -  -  N  -  B  P  -  -
 P  P  P  Q  -  -  P  P
 -  -  K  R  -  B  -  R</code></pre><p>Setting up an arbitrary board position without entering a move sequence can be done with the <code>fromfen()</code> function:</p><pre><code class="language-julia-repl">julia&gt; fromfen(&quot;5rk1/p1pb2pp/2p5/3p3q/2P3n1/1Q4BN/PP1Np1KP/R3R3 b - -&quot;)
Board (5rk1/p1pb2pp/2p5/3p3q/2P3n1/1Q4BN/PP1Np1KP/R3R3 b - -):
 -  -  -  -  -  r  k  -
 p  -  p  b  -  -  p  p
 -  -  p  -  -  -  -  -
 -  -  -  p  -  -  -  q
 -  -  P  -  -  -  n  -
 -  Q  -  -  -  -  B  N
 P  P  -  N  p  -  K  P
 R  -  -  -  R  -  -  -</code></pre><p>FEN strings are quite easy to understand. The first component (<code>5rk1/p1pb2pp/2p5/3p3q/2P3n1/1Q4BN/PP1Np1KP/R3R3</code> in the above example) is the board setup. The ranks of the board are listed from top to bottom (beginning with rank 8), separated by the <code>/</code> character. For each rank, lowercase letters (p, n, b, r, q or k) denote black pieces, while uppercase letters (P, N, B, R, Q or K) denote white pieces. Digits represents empty squares. In the above example, the 8th rank is <code>5rk1</code>, meaning five empty squares followed by a black rook and a black king, and finally one empty square.</p><p>The second component (<code>b</code> in the above example) is the side to move. It is always one of the two characters <code>w</code> or <code>b</code>, depending on the side to move. In this case, it&#39;s black.</p><p>The third component (<code>-</code> in the example) is the current castle rights. The dash means that neither side has the right to castle. If one or both sides still have the right to castle, the letters <code>K</code>, <code>Q</code>, <code>k</code> and <code>q</code> are used. The uppercase letters mean that white can castle kingside or queenside, while the lowercase letters mean that black can castle. For instance, in a position when both sides can still castle in either direction, the third component would be <code>KQkq</code>. In a position where white can only castle queenside and black only kingside, it would be <code>Qk</code>.</p><p>The fourth coponent (<code>-</code> in the example) is the square on which an en passant capture is possible. The dash means that no en passant capture is possible in our case. If an en passant capture had been possible on e3, the fourth component would have been <code>e3</code>.</p><p>For additional examples and explanations, visit the <a href="https://en.wikipedia.org/wiki/Forsyth–Edwards_Notation">Wikipedia article on FEN strings</a>.</p><h3><a class="nav-anchor" id="Making-and-Unmaking-Moves-1" href="#Making-and-Unmaking-Moves-1">Making and Unmaking Moves</a></h3><p>Given a chess board, you will often want to modify the board by making some moves. The most straightforward way to do this is with the <code>domove</code> function, which takes two parameters: A chess board and a move. The move can be either a value of the <code>Move</code> type (you&#39;ll learn about this type later in this tutorial) or a string representing a move in UCI or SAN notation.</p><p>Here&#39;s an example of using <code>domove</code> to make a move given by a string in short algebraic notation (SAN):</p><pre><code class="language-julia-repl"></code></pre><p>Given a chess board, you will usually want to modify the board by making some moves. The most straightforward way to do this is with the <code>domove</code> function, which takes two parameters: A chess board and a move. The move can be either a value of the <code>Move</code> type or a string representing a move in UCI or SAN notation.</p><p>The <code>Move</code> type is described in more detail in the API reference. For now, let&#39;s see how to use <code>domove</code> to make a move given in short algebraic notation (SAN):</p><pre><code class="language-julia-repl">julia&gt; b = startboard();

julia&gt; domove(b, &quot;d4&quot;)
Board (rnbqkbnr/pppppppp/8/8/3P4/8/PPP1PPPP/RNBQKBNR b KQkq -):
 r  n  b  q  k  b  n  r
 p  p  p  p  p  p  p  p
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  P  -  -  -  -
 -  -  -  -  -  -  -  -
 P  P  P  -  P  P  P  P
 R  N  B  Q  K  B  N  R</code></pre><p>There is also a function <code>domoves</code> that takes a series of several moves and executes all of them:</p><pre><code class="language-julia">julia&gt; b = startboard();

julia&gt; domoves(b, &quot;e4&quot;, &quot;e5&quot;, &quot;Nf3&quot;, &quot;Nc6&quot;, &quot;Bb5&quot;)
Board (r1bqkbnr/pppp1ppp/2n5/1B2p3/4P3/5N2/PPPP1PPP/RNBQK2R b KQkq -):
 r  -  b  q  k  b  n  r
 p  p  p  p  -  p  p  p
 -  -  n  -  -  -  -  -
 -  B  -  -  p  -  -  -
 -  -  -  -  P  -  -  -
 -  -  -  -  -  N  -  -
 P  P  P  P  -  P  P  P
 R  N  B  Q  K  -  -  R</code></pre><p>Note that both of these functions return new boards: The original board <code>b</code> is left unchanged, as illustrated by this example:</p><pre><code class="language-julia-repl">julia&gt; b = startboard();

julia&gt; domove(b, &quot;c4&quot;);

julia&gt; b
Board (rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq -):
 r  n  b  q  k  b  n  r
 p  p  p  p  p  p  p  p
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 P  P  P  P  P  P  P  P
 R  N  B  Q  K  B  N  R</code></pre><p>This is convenient when writing code in a functional style, or when using a reactive notebook environment like Pluto. Unfortunately, it also results in a lot of copying of data, and heap allocations that may have signifcant performance impacts for certain types of applications. When this is a problem, there are alternative functions <code>domove!</code> and <code>domoves!</code> that destructively modify the input board.</p><p>Here is the result of the previous example when modified to use <code>domove!</code>:</p><pre><code class="language-julia-repl">julia&gt; b = startboard();

julia&gt; domove!(b, &quot;c4&quot;);

julia&gt; b
Board (rnbqkbnr/pppppppp/8/8/2P5/8/PP1PPPPP/RNBQKBNR b KQkq -):
 r  n  b  q  k  b  n  r
 p  p  p  p  p  p  p  p
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  P  -  -  -  -  -
 -  -  -  -  -  -  -  -
 P  P  -  P  P  P  P  P
 R  N  B  Q  K  B  N  R</code></pre><p><code>domove!</code> returns a value of type <code>UndoInfo</code>. This can be used to undo the move and go back to the board position before the move was made:</p><pre><code class="language-julia-repl">julia&gt; b = startboard();

julia&gt; u = domove!(b, &quot;e4&quot;);

julia&gt; b
Board (rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq -):
 r  n  b  q  k  b  n  r
 p  p  p  p  p  p  p  p
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  P  -  -  -
 -  -  -  -  -  -  -  -
 P  P  P  P  -  P  P  P
 R  N  B  Q  K  B  N  R

julia&gt; undomove!(b, u);

julia&gt; b
Board (rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq -):
 r  n  b  q  k  b  n  r
 p  p  p  p  p  p  p  p
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 P  P  P  P  P  P  P  P
 R  N  B  Q  K  B  N  R</code></pre><p>There is also a function <code>domoves!()</code> that can be used to destructively update a board with a sequence of several moves. Unlike <code>domove!</code>, this operation is irreversible. No <code>UndoInfo</code> is generated, and there is no way to undo the moves and return to the original board.</p><p>Similarly, <code>domoves!</code> takes a board and a sequence of moves and executes them all, destructively modifying the board. Unlike <code>domove!</code>, this operation is irreversible. There is no way to retract the moves and return to the original board.</p><pre><code class="language-julia-repl">julia&gt; b = startboard();

julia&gt; domoves!(b, &quot;d4&quot;, &quot;Nf6&quot;, &quot;c4&quot;, &quot;g6&quot;, &quot;Nc3&quot;, &quot;Bg7&quot;, &quot;e4&quot;, &quot;d6&quot;, &quot;Nf3&quot;, &quot;O-O&quot;)
Board (rnbq1rk1/ppp1ppbp/3p1np1/8/2PPP3/2N2N2/PP3PPP/R1BQKB1R w KQ -):
 r  n  b  q  -  r  k  -
 p  p  p  -  p  p  b  p
 -  -  -  p  -  n  p  -
 -  -  -  -  -  -  -  -
 -  -  P  P  P  -  -  -
 -  -  N  -  -  N  -  -
 P  P  -  -  -  P  P  P
 R  -  B  Q  K  B  -  R</code></pre><p>Remember that there is also a macro <code>@startboard</code> that allows you to do this more conveniently. The above example could also be written like this:</p><pre><code class="language-julia-repl">julia&gt; @startboard d4 Nf6 c4 g6 Nc3 Bg7 e4 d6 Nf3 OO
Board (rnbq1rk1/ppp1ppbp/3p1np1/8/2PPP3/2N2N2/PP3PPP/R1BQKB1R w KQ -):
 r  n  b  q  -  r  k  -
 p  p  p  -  p  p  b  p
 -  -  -  p  -  n  p  -
 -  -  -  -  -  -  -  -
 -  -  P  P  P  -  -  -
 -  -  N  -  -  N  -  -
 P  P  -  -  -  P  P  P
 R  -  B  Q  K  B  -  R</code></pre><h2><a class="nav-anchor" id="Pieces,-Piece-Colors,-and-Piece-Types-1" href="#Pieces,-Piece-Colors,-and-Piece-Types-1">Pieces, Piece Colors, and Piece Types</a></h2><p>Chess pieces are represented by the <code>Piece</code> type (internally, a simple wrapper around an integer). There are constants <code>PIECE_WP</code>, <code>PIECE_WN</code>, <code>PIECE_WB</code>, <code>PIECE_WR</code>, <code>PIECE_WQ</code>, <code>PIECE_WK</code>, <code>PIECE_BP</code>, <code>PIECE_BN</code>, <code>PIECE_BB</code>, <code>PIECE_BR</code>, <code>PIECE_BQ</code> and <code>PIECE_BK</code> for each of the possible white or black pieces, and a special piece value <code>EMPTY</code> for the contents of an empty square on the board.</p><p>There are also <em>piece colors</em>, represented by the <code>PieceColor</code> type (possible values <code>WHITE</code>, <code>BLACK</code> and <code>COLOR_NONE</code>), as well as <em>piece types</em>, represented by the <code>PieceType</code> type (possible values <code>PAWN</code>, <code>KNIGHT</code>, <code>BISHOP</code>, <code>ROOK</code>, <code>QUEEN</code>, <code>KING</code> and <code>PIECE_TYPE_NONE</code>).</p><p>Given a piece, you can ask for its color and type by using <code>pcolor</code> and <code>ptype</code>:</p><pre><code class="language-julia-repl">julia&gt; pcolor(PIECE_BN)
BLACK

julia&gt; ptype(PIECE_BN)
KNIGHT</code></pre><p>Conversely, if you have a <code>PieceColor</code> and a <code>PieceType</code>, you can create a <code>Piece</code> value by calling the <code>Piece</code> constructor:</p><pre><code class="language-julia-repl">julia&gt; Piece(WHITE, ROOK)
PIECE_WR</code></pre><p>The special <code>Piece</code> value <code>EMPTY</code> has piece color <code>COLOR_NONE</code> and piece type <code>PIECE_TYPE_NONE</code>:</p><pre><code class="language-julia-repl">julia&gt; pcolor(EMPTY)
COLOR_NONE

julia&gt; ptype(EMPTY)
PIECE_TYPE_NONE</code></pre><p>The current side to move of a board is obtained by calling <code>sidetomove</code>:</p><pre><code class="language-julia-repl">julia&gt; sidetomove(startboard())
WHITE

julia&gt; sidetomove(@startboard Nf3)
BLACK</code></pre><p>Use the unary minus operator or the function <code>coloropp</code> to invert a color:</p><pre><code class="language-julia-repl">julia&gt; -WHITE
BLACK

julia&gt; coloropp(BLACK)
WHITE</code></pre><h2><a class="nav-anchor" id="Squares-1" href="#Squares-1">Squares</a></h2><p>Squares are represented by the <code>Square</code> data type. Just as for pieces, piece colors, and piece types, this type is internally just a simple wrapper around an integer. There are constants <code>SQ_A1</code>, <code>SQ_A2</code>, ..., <code>SQ_H8</code> for the 64 squares of the board.</p><p>One of the common uses of <code>Square</code> values is to ask about the contents of a square on a chess board. This is done with the <code>pieceon</code> function:</p><pre><code class="language-julia-repl">julia&gt; pieceon(startboard(), SQ_B1)
PIECE_WN

julia&gt; pieceon(startboard(), SQ_E8)
PIECE_BK

julia&gt; pieceon(startboard(), SQ_A3)
EMPTY</code></pre><p>There are also two types <code>SquareFile</code> and <code>SquareRank</code> for representing the files and ranks of a board. Given a square, we can get its file or rank by calling <code>file</code> or <code>rank</code>:</p><pre><code class="language-julia-repl">julia&gt; file(SQ_E5)
FILE_E

julia&gt; rank(SQ_E5)
RANK_5</code></pre><p>Conversely, it is possible to create a <code>Square</code> from a <code>SquareFile</code> and a <code>SquareRank</code>:</p><pre><code class="language-julia-repl">julia&gt; Square(FILE_C, RANK_4)
SQ_C4</code></pre><p>We can use the functions <code>tostring</code> and <code>squarefromstring</code> to convert between <code>Square</code> values and strings:</p><pre><code class="language-julia-repl">julia&gt; tostring(SQ_D4)
&quot;d4&quot;

julia&gt; squarefromstring(&quot;g6&quot;)
SQ_G6</code></pre><h2><a class="nav-anchor" id="Moves-1" href="#Moves-1">Moves</a></h2><p>Moves are represented by the type <code>Move</code>. A <code>Move</code> value can be obtained by calling one of two possible constructors:</p><pre><code class="language-julia-repl">julia&gt; Move(SQ_E2, SQ_E4) # Normal move
Move(e2e4)

julia&gt; Move(SQ_A7, SQ_A8, QUEEN) # Promotion move
Move(a7a8q)</code></pre><p>We can also convert a move to/from strings in UCI notation:</p><pre><code class="language-julia-repl">julia&gt; tostring(Move(SQ_G8, SQ_F6))
&quot;g8f6&quot;

julia&gt; movefromstring(&quot;b2c1r&quot;)
Move(b2c1r)</code></pre><p>Parsing move strings in short algebraic notation (SAN) requires a board. Without a board, there is no way to know the source square of a move string like <code>&quot;Nf3&quot;</code>. Given a board, we can convert to/from SAN move strings using <code>movetosan</code> and <code>movefromsan</code>:</p><pre><code class="language-julia-repl">julia&gt; movetosan(startboard(), Move(SQ_G1, SQ_F3))
&quot;Nf3&quot;

julia&gt; movefromsan(startboard(), &quot;e4&quot;)
Move(e2e4)</code></pre><p>One of the most common ways to obtain a move is to call the <code>moves</code> function on a board. This returns a <code>MoveList</code>, a list of all legal moves for the board:</p><pre><code class="language-julia-repl">julia&gt; b = @startboard e4 c5 Nf3 d6;

julia&gt; moves(b)
28-element MoveList:
 Move(a2a3)
 Move(b2b3)
 Move(c2c3)
 Move(d2d3)
 Move(e4e5)
 Move(g2g3)
 Move(h2h3)
 Move(a2a4)
 Move(b2b4)
 Move(c2c4)
 ⋮
 Move(f3g1)
 Move(f3h4)
 Move(f1a6)
 Move(f1b5)
 Move(f1c4)
 Move(f1d3)
 Move(f1e2)
 Move(h1g1)
 Move(d1e2)
 Move(e1e2)</code></pre><p>Most of the usual Julia sequence functions should work with <code>MoveList</code> values. For instance, we can filter out only those moves that give check:</p><pre><code class="language-julia-repl">julia&gt; filter(m -&gt; ischeck(domove(b, m)), moves(b))
1-element Vector{Move}:
 Move(f1b5)</code></pre><h2><a class="nav-anchor" id="Square-Sets-1" href="#Square-Sets-1">Square Sets</a></h2><p>The <code>SquareSet</code> type represents a set of squares on the chess board. We can do set-theoretic operations like union, intersection and complement on square sets, and test for set membership. Internally, a <code>SquareSet</code> is represented by a 64-bit integer, with set operations performed through bitwise operations. This makes square sets very fast to manipulate.</p><h3><a class="nav-anchor" id="Creating-Square-Sets-1" href="#Creating-Square-Sets-1">Creating Square Sets</a></h3><p>There is a <code>SquareSet</code> constructor that takes a sequence of squares as input and returns the corresponding square set:</p><pre><code class="language-julia-repl">julia&gt; SquareSet(SQ_A1, SQ_A2, SQ_A3)
SquareSet:
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 #  -  -  -  -  -  -  -
 #  -  -  -  -  -  -  -
 #  -  -  -  -  -  -  -</code></pre><p>There are also pre-defined constants <code>SS_FILE_A</code>, ..., <code>SS_FILE_H</code> for the eight files of the board, and <code>SS_RANK_1</code>, ..., <code>SS_RANK_8</code> for the eight ranks.</p><pre><code class="language-julia-repl">julia&gt; SS_FILE_B
SquareSet:
 -  #  -  -  -  -  -  -
 -  #  -  -  -  -  -  -
 -  #  -  -  -  -  -  -
 -  #  -  -  -  -  -  -
 -  #  -  -  -  -  -  -
 -  #  -  -  -  -  -  -
 -  #  -  -  -  -  -  -
 -  #  -  -  -  -  -  -

julia&gt; SS_RANK_6
SquareSet:
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 #  #  #  #  #  #  #  #
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -</code></pre><h3><a class="nav-anchor" id="Extracting-Square-Sets-From-Boards-1" href="#Extracting-Square-Sets-From-Boards-1">Extracting Square Sets From Boards</a></h3><p>Given a <code>Board</code> value, there are several functions for obtaining various square sets. The <code>pieces</code> function has several methods for extracting sets of squares occupied by various pieces.</p><p>The squares occupied by white pieces:</p><pre><code class="language-julia-repl">julia&gt; pieces(startboard(), WHITE)
SquareSet:
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 #  #  #  #  #  #  #  #
 #  #  #  #  #  #  #  #</code></pre><p>The set of all squares occupied by pawns of either color (you can also do <code>pawns(startboard())</code>, with the same effect):</p><pre><code class="language-julia-repl">julia&gt; pieces(startboard(), PAWN)
SquareSet:
 -  -  -  -  -  -  -  -
 #  #  #  #  #  #  #  #
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 #  #  #  #  #  #  #  #
 -  -  -  -  -  -  -  -</code></pre><p>The set of squares occupied by black knights (you can also do <code>knights(startboard(), BLACK)</code>:</p><pre><code class="language-julia-repl">julia&gt; pieces(startboard(), PIECE_BN)
SquareSet:
 -  #  -  -  -  -  #  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -</code></pre><p>The set of all occupied squares on the board:</p><pre><code class="language-julia-repl">julia&gt; occupiedsquares(startboard())
SquareSet:
 #  #  #  #  #  #  #  #
 #  #  #  #  #  #  #  #
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 #  #  #  #  #  #  #  #
 #  #  #  #  #  #  #  #</code></pre><p>The set of all empty squares on the board:</p><pre><code class="language-julia-repl">julia&gt; emptysquares(startboard())
SquareSet:
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 #  #  #  #  #  #  #  #
 #  #  #  #  #  #  #  #
 #  #  #  #  #  #  #  #
 #  #  #  #  #  #  #  #
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -</code></pre><h3><a class="nav-anchor" id="Set-Operations-1" href="#Set-Operations-1">Set Operations</a></h3><p>It is possible to do various basic set theoretic operations likecomplement, union, increment, and membership tests on square sets, using standard mathematical notation. This sections gives a few examples.</p><p>Set membership tests (type <code>\in &lt;TAB&gt;</code> and <code>\notin &lt;TAB&gt;</code> for the <code>∈</code> and <code>∉</code> characters):</p><pre><code class="language-julia-repl">julia&gt; SQ_D1 ∈ SS_FILE_D
true

julia&gt; SQ_D1 ∈ SS_RANK_2
false

julia&gt; SQ_E4 ∉ SS_RANK_8
true</code></pre><p>Set complement:</p><pre><code class="language-julia-repl">julia&gt; -SS_RANK_4
SquareSet:
 #  #  #  #  #  #  #  #
 #  #  #  #  #  #  #  #
 #  #  #  #  #  #  #  #
 #  #  #  #  #  #  #  #
 -  -  -  -  -  -  -  -
 #  #  #  #  #  #  #  #
 #  #  #  #  #  #  #  #
 #  #  #  #  #  #  #  #</code></pre><p>Set union (type <code>\cup &lt;TAB&gt;</code> for the <code>∪</code> character):</p><pre><code class="language-julia-repl">julia&gt; SS_RANK_2 ∪ SS_FILE_F
SquareSet:
 -  -  -  -  -  #  -  -
 -  -  -  -  -  #  -  -
 -  -  -  -  -  #  -  -
 -  -  -  -  -  #  -  -
 -  -  -  -  -  #  -  -
 -  -  -  -  -  #  -  -
 #  #  #  #  #  #  #  #
 -  -  -  -  -  #  -  -</code></pre><p>Set intersection (type <code>\cap &lt;TAB&gt;</code> for the <code>∩</code> character):</p><pre><code class="language-julia-repl">julia&gt; SS_FILE_D ∩ SquareSet(SQ_D4, SQ_D5, SQ_E4, SQ_E5)
SquareSet:
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  #  -  -  -  -
 -  -  -  #  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -</code></pre><p>Set subtraction:</p><pre><code class="language-julia-repl">julia&gt; SS_FILE_G - (SS_RANK_3 ∪ SS_RANK_4)
SquareSet:
 -  -  -  -  -  -  #  -
 -  -  -  -  -  -  #  -
 -  -  -  -  -  -  #  -
 -  -  -  -  -  -  #  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  #  -
 -  -  -  -  -  -  #  -</code></pre><h3><a class="nav-anchor" id="Attack-Square-Sets-1" href="#Attack-Square-Sets-1">Attack Square Sets</a></h3><p>Chess.jl contains several functions for generating attacks to/from squares on the chess board.</p><p>Attacks by knights, kings or pawns from a given square on the board are the most straightforward.</p><p>The squares attacked by a knight on e5:</p><pre><code class="language-julia-repl">julia&gt; knightattacks(SQ_E5)
SquareSet:
 -  -  -  -  -  -  -  -
 -  -  -  #  -  #  -  -
 -  -  #  -  -  -  #  -
 -  -  -  -  -  -  -  -
 -  -  #  -  -  -  #  -
 -  -  -  #  -  #  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -</code></pre><p>The squares attacked by a king on g2:</p><pre><code class="language-julia-repl">julia&gt; kingattacks(SQ_G2)
SquareSet:
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  #  #  #
 -  -  -  -  -  #  -  #
 -  -  -  -  -  #  #  #</code></pre><p>The squares attacked by a black pawn on c5 (the color is necessary here, because white and black pawns move in the opposite direction):</p><pre><code class="language-julia-repl">julia&gt; pawnattacks(BLACK, SQ_C5)
SquareSet:
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  #  -  #  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -</code></pre><p>Sliding pieces (bishops, rooks and queens) are a little more complicated, because we need the set of occupied squares on the board in order to identify possible blockers before we can know what squares they attack.</p><p>The most common way of providing a set of occupied squares is to use an actual chess board. Let&#39;s first create a board position a little more interesting than the starting position.</p><pre><code class="language-julia-repl">julia&gt; b = @startboard e4 e5 Nf3 Nc6 d4 exd4 Nxd4 Bc5
Board (r1bqk1nr/pppp1ppp/2n5/2b5/3NP3/8/PPP2PPP/RNBQKB1R w KQkq -):
 r  -  b  q  k  -  n  r
 p  p  p  p  -  p  p  p
 -  -  n  -  -  -  -  -
 -  -  b  -  -  -  -  -
 -  -  -  N  P  -  -  -
 -  -  -  -  -  -  -  -
 P  P  P  -  -  P  P  P
 R  N  B  Q  K  B  -  R</code></pre><p>The set of squares attacked by the white queen on d1:</p><pre><code class="language-julia-repl">julia&gt; queenattacks(b, SQ_D1)
SquareSet:
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  #
 -  -  -  #  -  -  #  -
 -  -  -  #  -  #  -  -
 -  -  #  #  #  -  -  -
 -  -  #  -  #  -  -  -</code></pre><p>The set of squares a bishop on c4 would have attacked (there is no bishop on c4 at the moment, but this does not stop us from asking which squares a hypothetical bishop there would attack):</p><pre><code class="language-julia-repl">julia&gt; bishopattacks(b, SQ_C4)
SquareSet:
 -  -  -  -  -  -  -  -
 -  -  -  -  -  #  -  -
 #  -  -  -  #  -  -  -
 -  #  -  #  -  -  -  -
 -  -  -  -  -  -  -  -
 -  #  -  #  -  -  -  -
 #  -  -  -  #  -  -  -
 -  -  -  -  -  #  -  -</code></pre><p>There is also an <code>attacksfrom</code> function, that returns the set of squares attacked by the piece on a given non-empty square, and an <code>attacksto</code> function, that returns all squares that contains pieces of either side that attacks a given square:</p><pre><code class="language-julia-repl">julia&gt; attacksfrom(b, SQ_H8)
SquareSet:
 -  -  -  -  -  -  #  -
 -  -  -  -  -  -  -  #
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -

julia&gt; attacksto(b, SQ_D4)
SquareSet:
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  #  -  -  -  -  -
 -  -  #  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  #  -  -  -  -</code></pre><p>It is possible to identify pieces that can be captured by intersecting attack square sets with sets of pieces of a given color:`</p><pre><code class="language-julia-repl">julia&gt; attacksfrom(b, SQ_D4) ∩ pieces(b, BLACK)
SquareSet:
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  #  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -</code></pre><p>Here is a more complicated example: A function that finds all pieces of a given side that are attacked, but undefended:</p><pre><code class="language-julia">function attacked_but_undefended(board, color)
    attacker = -color  # The opposite color

    # Find all attacked squares
    attacked = SS_EMPTY  # The empty square set
    for s ∈ pieces(board, attacker)
        attacked = attacked ∪ attacksfrom(board, s)
    end

    # Find all defended squares
    defended = SS_EMPTY
    for s ∈ pieces(b, color)
        defended = defended ∪ attacksfrom(board, s)
    end

    # Return all attacked, but undefended squares containing pieces of
    # the desired color:
    attacked ∩ -defended ∩ pieces(board, color)
end</code></pre><h3><a class="nav-anchor" id="Iterating-Through-Square-Sets-1" href="#Iterating-Through-Square-Sets-1">Iterating Through Square Sets</a></h3><p>The <code>squares</code> function can be used to convert a <code>SquareSet</code> to a vector of squares:</p><pre><code class="language-julia-repl">julia&gt; squares(SS_FILE_A)
8-element Vector{Square}:
 SQ_A8
 SQ_A7
 SQ_A6
 SQ_A5
 SQ_A4
 SQ_A3
 SQ_A2
 SQ_A1</code></pre><p>The <code>squares</code> function is not necessary for most tasks. It is possible – and much more efficient – to iterate through a <code>SquareSet</code> directly:</p><pre><code class="language-julia-repl">julia&gt; for s ∈ SS_RANK_5
           println(tostring(s))
       end
a5
b5
c5
d5
e5
f5
g5
h5</code></pre><h2><a class="nav-anchor" id="Games-1" href="#Games-1">Games</a></h2><p>There are two types for representing chess games: <code>SimpleGame</code> and <code>Game</code>. <code>SimpleGame</code> is a basic type that contains little more than the PGN headers (player names, game result, etc.) and a sequence of moves. <code>Game</code> is a more complicated type that support annotated, tree-like games with comments and variations. If you don&#39;t need these features, <code>SimpleGame</code> is always a better choice, as manipulating a <code>SimpleGame</code> is much faster.</p><p>For the rest of this section, most of our examples use the more complicated <code>Game</code> type. With a few exceptions (that will be pointed out), methods with identical names and behavior exist for the <code>SimpleGame</code> type. Remember again that <code>SimpleGame</code> is really the preferred type in practice, unless you <em>really</em> need the extra functionality of the <code>Game</code> type.</p><h3><a class="nav-anchor" id="Creating-Games-and-Adding-Moves-1" href="#Creating-Games-and-Adding-Moves-1">Creating Games and Adding Moves</a></h3><p>To create an empty game from the standard chess position, use the parameterless <code>Game()</code> constructor:</p><pre><code class="language-julia-repl">julia&gt; g = Game()
Game:
  *</code></pre><p>The printed representation of the game consists of the moves in short algebraic notation (in this case, because we just constructed a game, there are no moves) and an asterisk (<code>*</code>) showing our current position in the game.</p><p>Moves can be added to the game with the <code>domove!</code> function:</p><pre><code class="language-julia-repl">julia&gt; g = Game();

julia&gt; domove!(g, &quot;c4&quot;);

julia&gt; domove!(g, &quot;e5&quot;);

julia&gt; domove!(g, &quot;Nc3&quot;);

julia&gt; domove!(g, &quot;Nf6&quot;);

julia&gt; g
Game:
 1. c4 e5 2. Nc3 Nf6 *</code></pre><p>Constructing games this way quickly becomes tedious. For interactive use, there is a macro <code>@game</code> (and a similar macro <code>@simplegame</code> for the <code>SimpleGame</code> type) for constructing a game from the regular starting position with a sequence of moves. The following is equivalent to the above example:</p><pre><code class="language-julia-repl">julia&gt; g = @game c4 e5 Nc3 Nf6
Game:
 1. c4 e5 2. Nc3 Nf6 *</code></pre><p>There is now a list of moves in the printed representation of the game. The <code>*</code> symbol still indicates our current position in the game. We can go back one move by calling <code>back!</code>, forward one move by calling <code>forward!</code>, or jump to the beginning or the end of the game by calling <code>tobeginning!</code> or <code>toend!</code>.</p><pre><code class="language-julia-repl">julia&gt; back!(g)
Game:
 1. c4 e5 2. Nc3 * Nf6

julia&gt; tobeginning!(g)
Game:
 * 1. c4 e5 2. Nc3 Nf6

julia&gt; forward!(g)
Game:
 1. c4 * e5 2. Nc3 Nf6

julia&gt; toend!(g)
Game:
 1. c4 e5 2. Nc3 Nf6 *</code></pre><p>You can obtain the current position board position of the game with the <code>board</code> function, which returns a value of type <code>Board</code>:</p><pre><code class="language-julia-repl">julia&gt; board(g)
Board (rnbqkb1r/pppp1ppp/5n2/4p3/2P5/2N5/PP1PPPPP/R1BQKBNR w KQkq -):
 r  n  b  q  k  b  -  r
 p  p  p  p  -  p  p  p
 -  -  -  -  -  n  -  -
 -  -  -  -  p  -  -  -
 -  -  P  -  -  -  -  -
 -  -  N  -  -  -  -  -
 P  P  -  P  P  P  P  P
 R  -  B  Q  K  B  N  R</code></pre><h3><a class="nav-anchor" id="Example:-Playing-Random-Games-1" href="#Example:-Playing-Random-Games-1">Example: Playing Random Games</a></h3><p>By putting together things we&#39;ve learned earlier in this tutorial, we can now generate random games. This function generates a <code>SimpleGame</code> containing random moves:</p><pre><code class="language-julia">function randomgame()
    game = SimpleGame()
    while !isterminal(game)
        move = rand(moves(board(game)))
        domove!(game, move)
    end
    game
end</code></pre><p>The only new function in the above code is <code>isterminal</code>, which tests for a game over condition (checkmate or some type of immediate draw).</p><p>Approximately how often do completely random games end in checkmate? Let&#39;s find out. The following function takes an optional number of games as input (by default, one thousand), generates the deseired number of random games, and returns the fraction of the games that (accidentally) ends in checkmate.</p><pre><code class="language-julia">function checkmate_fraction(game_count = 1000)
    checkmate_count = 0
    for _ in 1:game_count
        g = randomgame()
        if ischeckmate(board(g))
            checkmate_count += 1
        end
    end
    checkmate_count / game_count
end</code></pre><p>The above code introduces the new function <code>ischeckmate</code>, which tests if a board is a checkmate position.</p><p>Let&#39;s test it:</p><pre><code class="language-julia-repl">julia&gt; checkmate_fraction(10_000)
0.1546</code></pre><p>It seems that about 15% of all random games end in an accidental checkmate. To me, this is a suprisingly high number.</p><p>What will happen if we make random moves, except that we always play the mating move if there is a mate in one? Let&#39;s find out. As a first step, let&#39;s write a function that checks whether a move is a mate in one.</p><pre><code class="language-julia">move_is_mate_slow(board, move) = ischeckmate(domove(board, move))</code></pre><p>This is simple, elegant and readable. Unfortunately, as the name indicates, it is also kind of slow. The reason is that <code>domove</code> copies the board. Using the destructive <code>domove!</code> function performs much better, at the price of longer and less readable code.</p><p>The function below is functionally equivalent to the one above, but performs much better.</p><pre><code class="language-julia">function move_is_mate(board, move)
    # Do the move
    u = domove!(board, move)

    # Check if the resulting board is checkmate
    result = ischeckmate(board)

    # Undo the move
    undomove!(board, u)

    # Return result
    result
end</code></pre><p>Using the function we just wrote, we can make a function that takes a board as input and returns a mate in 1 move if there is one, or a random move otherwise.</p><pre><code class="language-julia">function mate_or_random(board)
    ms = moves(board)
    for move ∈ ms
        if move_is_mate(board, move)
            return move
        end
    end
    rand(ms)
end</code></pre><p>The function below is identical to the <code>randomgame</code> function above, except that it uses <code>mate_or_random</code> instead of totally random moves:</p><pre><code class="language-julia">function almost_random_game()
    game = SimpleGame()
    while !isterminal(game)
        move = mate_or_random(board(game))
        domove!(game, move)
    end
    game
end</code></pre><p>What percentage of the games end in checkmate now? Here&#39;s a function to find out:</p><pre><code class="language-julia">function checkmate_fraction_2(game_count = 1000)
    checkmate_count = 0
    for _ in 1:game_count
        g = almost_random_game()
        if ischeckmate(board(g))
            checkmate_count += 1
        end
    end
    checkmate_count / game_count
end</code></pre><p>If you try to run this function, you should get a number around 0.81. About 81% of all completely random games include at least one opportunity to deliver mate in 1!</p><h3><a class="nav-anchor" id="Variations-1" href="#Variations-1">Variations</a></h3><p>If we create a game with some moves, go back to an earlier place in the game, and call <code>domove!</code> again with a new move, the previous game continuation is overwritten:</p><pre><code class="language-julia-repl">julia&gt; g = @game d4 d5 c4 e6 Nc3 Nf6 Bg5
Game:
 1. d4 d5 2. c4 e6 3. Nc3 Nf6 4. Bg5 *

julia&gt; back!(g); back!(g); back!(g)
Game:
 1. d4 d5 2. c4 e6 * 3. Nc3 Nf6 4. Bg5

julia&gt; domove!(g, &quot;Nf3&quot;)
Game:
 1. d4 d5 2. c4 e6 3. Nf3 *</code></pre><p>This is not always desirable. Sometimes we want to add an <em>alternative</em> move, and to view the game as a <em>tree of variations</em>.</p><p>Games of type <code>Game</code> (but not <code>SimpleGame</code>!) are able to handle variations.</p><p>To add an alternative variation at some point in the game, first make the main line, then go back to the place where you want to add the alternative move, and then do <code>addmove!</code>. The following example is identical to the one above, except that <code>domove!</code> has been replaced by <code>addmove!</code>:</p><pre><code class="language-julia-repl">julia&gt; g = @game d4 d5 c4 e6 Nc3 Nf6 Bg5;

julia&gt; back!(g); back!(g); back!(g)
Game:
 1. d4 d5 2. c4 e6 * 3. Nc3 Nf6 4. Bg5

julia&gt; addmove!(g, &quot;Nf3&quot;)
Game:
 1. d4 d5 2. c4 e6 3. Nc3 (3. Nf3 *) Nf6 4. Bg5</code></pre><p>Alternative variations are printed in parens in the text representation of a game; the <code>(3. Nf3 *)</code> in the above example. As before, the <code>*</code> indicates the current location in the game tree.</p><p>The function <code>forward!</code> takes an optional second argument: Which move to follow when going forward at a branching point in the tree. If this argument is ommited, the main (i.e. first) move is followed.</p><p>Here is how you would go back to the point after 3. Nc3 in the above example:</p><pre><code class="language-julia-repl">julia&gt; back!(g)
Game:
 1. d4 d5 2. c4 e6 * 3. Nc3 (3. Nf3) Nf6 4. Bg5

julia&gt; forward!(g, &quot;Nc3&quot;)
Game:
 1. d4 d5 2. c4 e6 3. Nc3 (3. Nf3) * Nf6 4. Bg5</code></pre><p>Two other functions that are useful for navigating games with variations are <code>tobeginningofvariation!</code> and <code>toendofvariation!</code>. See the documentation of these functions for details.</p><p>Of course, variations can be nested:</p><pre><code class="language-julia-repl">julia&gt; g = @game e4 c5 Nf3 Nc6;

julia&gt; back!(g)
Game:
 1. e4 c5 2. Nf3 * Nc6

julia&gt; g = @game e4 c5 Nf3 Nc6;

julia&gt; back!(g); back!(g);

julia&gt; addmove!(g, &quot;c3&quot;); addmove!(g, &quot;Nf6&quot;); addmove!(g, &quot;e5&quot;);

julia&gt; back!(g); back!(g);

julia&gt; addmove!(g, &quot;d5&quot;); addmove!(g, &quot;exd5&quot;);

julia&gt; g
Game:
 1. e4 c5 2. Nf3 (2. c3 Nf6 (2... d5 3. exd5 *) 3. e5) Nc6</code></pre><h3><a class="nav-anchor" id="Comments-1" href="#Comments-1">Comments</a></h3><p>Games of type <code>Game</code> (again, not <code>SimpleGame</code>) can also be annotated with textual comments, by using the <code>addcomment!</code> function:</p><pre><code class="language-julia-repl">julia&gt;  g = @game d4 f5;

julia&gt; addcomment!(g, &quot;This opening is known as the Dutch Defense&quot;);

julia&gt; g
Game:
 1. d4 f5 {This opening is known as the Dutch Defense} *</code></pre><p>Comments are printed in curly braces in the textual representation of games, as can be seen above.</p><h3><a class="nav-anchor" id="Numeric-Annotation-Glyphs-1" href="#Numeric-Annotation-Glyphs-1">Numeric Annotation Glyphs</a></h3><p>It is also possible to add <em>numeric annotation glyphs</em> (NAGs) to the game. NAGs are a standard way of adding symbolic annotations to a chess game. All integers in the range 0 to 139 have a pre-defined meaning, as described in <a href="https://en.wikipedia.org/wiki/Numeric_Annotation_Glyphs">this Wikipedia article</a>.</p><p>Here is how to add the NAG <code>$4</code> (&quot;very poor move or blunder&quot;) to the move 2... g4 in the game 1. f4 e5 2. g4 Qh4#:</p><pre><code class="language-julia-repl">julia&gt; g = @game f4 e5 g4 Qh4;

julia&gt; back!(g);

julia&gt; addnag!(g, 4);

julia&gt; g
Game:
 1. f4 e5 2. g4 $4 * Qh4#</code></pre><h2><a class="nav-anchor" id="PGN-Import-and-Export-1" href="#PGN-Import-and-Export-1">PGN Import and Export</a></h2><p>This section describes import and export of chess games in the popular <a href="https://www.chessclub.com/help/PGN-spec">PGN format</a>. PGN is a rather awkward and complicated format, and a lot of the &quot;PGN files&quot; out there on the Internet don&#39;t quite follow the standard, and are broken in various ways. The functions described in this section do a fairly good job of handling correct PGNs (although bugs are possible), but will often fail on the various not-quite-PGNs found on the Internet.</p><p>The PGN functions are found in the submodule <code>Chess.PGN</code>. Please do</p><pre><code class="language-julia-repl">using Chess, Chess.PGN</code></pre><p>before trying the examples in this section.</p><h3><a class="nav-anchor" id="Creating-a-Game-From-a-PGN-String-1" href="#Creating-a-Game-From-a-PGN-String-1">Creating a Game From a PGN String</a></h3><p>Given a PGN string, the <code>gamefromstring</code> function creates a game object from the string (throwing a <code>PGNException</code> on failure). Here&#39;s a PGN string for us to experiment with:</p><pre><code class="language-julia-repl">julia&gt; pgnstring = &quot;&quot;&quot;
       [Event &quot;Important Tournament&quot;]
       [Site &quot;Somewhere&quot;]
       [Date &quot;2021.04.29&quot;]
       [Round &quot;42&quot;]
       [White &quot;Sixpack, Joe&quot;]
       [Black &quot;Public, John Q&quot;]
       [Result &quot;0-1&quot;]

       1. f4 e5 2. fxe5 d6 3. exd6 Bxd6 4. Nc3 \$4 {A terrible blunder. White should
       play} (4. Nf3 {, and Black has insufficient compensation for the pawn.}) Qh4+
       5. g3 Qxg3+ {Black could also have played} (5... Bxg3+ 6. hxg3 Qxg3#) 6. hxg3
       Bxg3# 0-1
       &quot;&quot;&quot;;</code></pre><p>Let&#39;s try to import it:</p><pre><code class="language-julia-repl">julia&gt; sg = gamefromstring(pgnstring)
SimpleGame (Sixpack, Joe vs Public, John Q, Somewhere 2021):
 * 1. f4 e5 2. fxe5 d6 3. exd6 Bxd6 4. Nc3 Qh4+ 5. g3 Qxg3+ 6. hxg3 Bxg3#</code></pre><p>The result is a <code>SimpleGame</code>. All comments, variations and NAGs in the PGN string were ignored. If we instead want a <code>Game</code> with all annotations included, we can supply the value <code>true</code> to the optional parameter <code>annotations</code>:</p><pre><code class="language-julia-repl">julia&gt; g = gamefromstring(pgnstring, annotations=true)
Game (Sixpack, Joe vs Public, John Q, Somewhere 2021):
 * 1. f4 e5 2. fxe5 d6 3. exd6 Bxd6 4. Nc3 $4 {A terrible blunder. White should
play} (4. Nf3 {, and Black has insufficient compensation for the pawn.}) Qh4+ 5. g3 Qxg3+ {Black could also have played} (5... Bxg3+ 6. hxg3 Qxg3#) 6. hxg3 Bxg3#</code></pre><p>Unless you really need the annotations, importing to a <code>SimpleGame</code> is the preferred choice. A <code>SimpleGame</code> is much faster to create and consumes less memory.</p><p>Converting a game to a PGN string is done by the <code>gametopgn</code> function. This works for both <code>SimpleGame</code> and <code>Game</code> objects:</p><pre><code class="language-julia-repl">julia&gt; println(gametopgn(sg))
[Event &quot;Important Tournament&quot;]
[Site &quot;Somewhere&quot;]
[Date &quot;2021.04.29&quot;]
[Round &quot;42&quot;]
[White &quot;Sixpack, Joe&quot;]
[Black &quot;Public, John Q&quot;]
[Result &quot;0-1&quot;]

1. f4 e5 2. fxe5 d6 3. exd6 Bxd6 4. Nc3 Qh4+ 5. g3 Qxg3+ 6. hxg3 Bxg3# 0-1

julia&gt; println(gametopgn(g))
[Event &quot;Important Tournament&quot;]
[Site &quot;Somewhere&quot;]
[Date &quot;2021.04.29&quot;]
[Round &quot;42&quot;]
[White &quot;Sixpack, Joe&quot;]
[Black &quot;Public, John Q&quot;]
[Result &quot;0-1&quot;]

1. f4 e5 2. fxe5 d6 3. exd6 Bxd6 4. Nc3 $4 {A terrible blunder. White should
play} (4. Nf3 {, and Black has insufficient compensation for the pawn.}) Qh4+ 5. g3 Qxg3+ {Black could also have played} (5... Bxg3+ 6. hxg3 Qxg3#) 6. hxg3 Bxg3# 0-1</code></pre><h3><a class="nav-anchor" id="Working-With-PGN-Files-1" href="#Working-With-PGN-Files-1">Working With PGN Files</a></h3><p>Given a file with one or more PGN games, the function <code>gamesinfile</code> returns a <code>Channel</code> of game objects, one for each game in the file. Like <code>gamefromstring</code>, <code>gamesinfile</code> takes an optional named parameter <code>annotations</code>. If <code>annotations</code> is <code>false</code> (the default), you get a channel of <code>SimpleGame</code>s. If it&#39;s <code>true</code>, you get a channel of <code>Game</code>s with the annotations (comments, variations and numeric annotation glyphs) included in the PGN games.</p><p>As an example, here&#39;s a function that scans a PGN file and returns a vector of all games that end in checkmate:</p><pre><code class="language-julia">function checkmategames(pgnfilename::String)
    result = SimpleGame[]
    for g in gamesinfile(pgnfilename)
        toend!(g)
        if ischeckmate(g)
            push!(result, g)
        end
    end
    result
end</code></pre><h2><a class="nav-anchor" id="Opening-Books-1" href="#Opening-Books-1">Opening Books</a></h2><p>The opening book function are located not in the main <code>Chess</code> module, but in the submodule <code>Chess.Book</code>.</p><pre><code class="language-julia-repl">using Chess.Book</code></pre><p>The <code>Chess.Book</code> module contains functions for processing large PGN files and creating opening book files. There is also a small built-in opening book. The rest of the examples in this section will use the built-in opening book. For information about generating your own books, consult the documentation for the <code>Chess.Book</code> module.</p><h3><a class="nav-anchor" id="Finding-Book-Moves-1" href="#Finding-Book-Moves-1">Finding Book Moves</a></h3><p>Given a <code>Board</code>, the function <code>findbookentries</code> finds all the opening book moves for that board position. For instance, this gives us all book moves for the standard opening position:</p><pre><code class="language-julia-repl">julia&gt; b = startboard();

julia&gt; entries = findbookentries(b);</code></pre><p>The return value is a vector of <code>BookEntry</code> structs. This struct contains the following slots:</p><ul><li><code>move</code>: The move played. For space reasons, the move is stored as an <code>Int32</code> value. To get the actual <code>Move</code>, do <code>Move(entry.move)</code>.</li><li><code>wins</code>: The number of times the player who played this move won the game.</li><li><code>draws</code>: The number of times the game was drawn when this move was played.</li><li><code>losses</code>: The number of times the player who played this move lost the game.</li><li><code>elo</code>: The Elo rating of the highest rated player who played this move.</li><li><code>oppelo</code>: The Elo rating of the highest rated opponent against whom this move was played.</li><li><code>firstyear</code>: The first year this move was played.</li><li><code>lastyear</code>: The last year this move was played.</li><li><code>score</code>: The score of the move, used to decide the probability that this move is played when picking a book move to play. The score is computed based on the move&#39;s win/loss/draw statistics and its popularity, especially in recent games and games with strong players.</li></ul><p>To print out the stats for all moves for a position, use <code>printbookentries</code>:</p><pre><code class="language-julia-repl">julia&gt; printbookentries(@startboard d4 Nf6 c4 e6 Nc3)
move     prob   score     won   drawn    lost    elo oelo  first last
Bb4    71.92%  48.18%   32327   35691   36120   3936 3936   1854 2020
d5     20.82%  40.46%    4481    6545    8137   3796 3796   1880 2020
c5      4.20%  43.13%    1560    1192    2247   3794 3851   1922 2020
b6      2.16%  34.51%     217     170     488   2652 2762   1902 2020
Be7     0.51%  27.47%      28      33     101   2585 2640   1911 2020
c6      0.20%  36.05%      13       5      25   2448 2670   1932 2020
g6      0.12%  31.94%       9       5      22   2289 2405   1943 2020
Nc6     0.06%  33.33%       6      10      17   3809 3809   1938 2020</code></pre><p>The output columns have the following meanings:</p><ul><li><code>move</code>: The move.</li><li><code>prob</code>: Probability that this move will be played when calling <code>pickbookmove</code>.</li><li><code>score</code>: Percentage score of this move in the games used to produce this book file.</li><li><code>won</code>: Number of games won with this move.</li><li><code>drawn</code>: Number of games drawn with this move.</li><li><code>lost</code>: Number of games lost with this move.</li><li><code>elo</code>: Maximum Elo of players that played this move.</li><li><code>oelo</code>: Maximum Elo of opponents against which this move was played.</li><li><code>first</code>: The first year this move was played.</li><li><code>last</code>: The last year this move was played.</li></ul><p>To pick a book move, use <code>pickbookmove</code>:</p><pre><code class="language-julia-repl">julia&gt; pickbookmove(@startboard e4 c5)
Move(b1c3)</code></pre><p><code>pickbookmove</code> also takes some optional named parameter for selecting a book file to use and to eliminate moves that have only been played very rarely. See the function documentation for details.</p><p>If no book moves are found for the input position, <code>pickbookmove</code> returns <code>nothing</code>.</p><h3><a class="nav-anchor" id="Example:-Playing-Random-Openings-1" href="#Example:-Playing-Random-Openings-1">Example: Playing Random Openings</a></h3><p>Here&#39;s a function that generates a game (or rather, the beginning of a game) by picking and playing book moves until it reaches a position where no book move is found:</p><pre><code class="language-julia">function random_opening()
    g = Game()
    while true
        move = pickbookmove(board(g))
        if isnothing(move)
            break
        end
        domove!(g, move)
    end
    g
end</code></pre><p>Let&#39;s try:</p><pre><code class="language-julia-repl">julia&gt; random_opening()
Game:
 Nf3 c5 c4 Nc6 Nc3 Nf6 e3 g6 d4 cxd4 exd4 d5 cxd5 Nxd5 Qb3 Nxc3 bxc3 Bg7 Be2 O-O O-O Qc7 *</code></pre><h3><a class="nav-anchor" id="Creating-Book-Files-1" href="#Creating-Book-Files-1">Creating Book Files</a></h3><p>To create an opening book, use the <code>createbook</code> function, and supply it with one or more PGN files:</p><pre><code class="language-julia-repl">julia&gt; bk = createbook(&quot;/path/to/SomeGameDatabase.pgn&quot;);</code></pre><p><code>createbook</code> also accepts a number of optional named parameters that configure the scoring of the book moves and what moves are included and excluded. See the function documentation for details.</p><p>Please note that while Chess.jl&#39;s PGN parser works pretty well for processing correct PGN, it&#39;s not very robust when it comes to parsing &quot;PGN files&quot; that fail to follow the standard. Annoyingly, even popular software like ChessBase sometimes generate broken PGN files (failing to escape quotes in strings is a particularly frequent problem). If you feed <code>createbook</code> with a non-standard PGN file, it will often fail.</p><p>For large databases with millions of games, creating a book consumes a lot of memory, since all the data is stored in RAM.</p><p>The first thing you want to do after creating an opening book is probably to write it to disk. Assuming that we stored the result of <code>createbook</code> in a variable <code>bk</code>, like above, we save the book like this:</p><pre><code class="language-julia-repl">julia&gt; writebooktofile(bk, &quot;/path/to/mybook.obk&quot;)</code></pre><p>Opening book files can be very large, because they contain every move that has been played even once in the input PGN databases. The function <code>purgebook</code> can create a smaller book from a large book by only including moves which have been played several times and/or have high scores (the <em>score</em> of a move is computed based on how well it has been formed and by how popular it is, with more weight being given to recent games and games played by strong players). <code>purgebook</code> has two required parameters, an input file name and an output file name. The optional named parameters <code>minscore</code> (default 0) and <code>mingamecount</code> (default 5) control what moves are included in the output file.</p><p>Example usage:</p><pre><code class="language-julia-repl">julia&gt; purgebook(&quot;/path/to/mybook.obk&quot;, &quot;/path/to/mybook-small.obk&quot;, minscore=0.01, mingamecount=10)</code></pre><h2><a class="nav-anchor" id="Interacting-with-UCI-Engines-1" href="#Interacting-with-UCI-Engines-1">Interacting with UCI Engines</a></h2><p>This section describes how to run and interact with chess engines using the <a href="http://wbec-ridderkerk.nl/html/UCIProtocol.html">Universal Chess Interface</a> protocol. There are hundreds of UCI chess engines out there. A free, strong and popular choice is <a href="https://stockfishchess.org">Stockfish</a>. Stockfish is used as an example in this section, but any other engine should work just as well.</p><p>For running the examples in this section, it is assumed that you have an executable <code>stockfish</code> somewhere in your <code>PATH</code> environment variable.</p><p>The code for interacting with UCI engines is found in the submodule <code>Chess.UCI</code>:</p><pre><code class="language-julia-repl">julia&gt; using Chess.UCI</code></pre><h3><a class="nav-anchor" id="Starting-and-Initializing-Engines-1" href="#Starting-and-Initializing-Engines-1">Starting and Initializing Engines</a></h3><p>An engine is started by calling the runengine function, which takes the path to the engine as a parameter:</p><p>An engine is started by calling the <code>runengine</code> command, which takes the path to the engine as a parameter:</p><pre><code class="language-julia-repl">julia&gt; sf = runengine(&quot;stockfish&quot;)
Engine: Stockfish 160421</code></pre><p>The first thing you want to do after starting a chess engine is probably to set some UCI parameter values. This can be done with <code>setoption</code>:</p><pre><code class="language-julia-repl">julia&gt; setoption(sf, &quot;Hash&quot;, 256);</code></pre><h3><a class="nav-anchor" id="Searching-1" href="#Searching-1">Searching</a></h3><p>You can send a game to the engine with <code>setboard</code>:</p><pre><code class="language-julia-repl">julia&gt; g = @simplegame f4 e5 fxe5 d6 exd6 Bxd6 Nc3;

julia&gt; setboard(sf, g)</code></pre><p>The second parameter to <code>setboard</code> can also be a <code>Board</code> or a <code>Game</code>.</p><p>To ask the engine to search the position you just sent to it, use the <code>search</code> function. <code>search</code> has two required parameters: The engine and the UCI <code>go</code> command we want to send to it.</p><p>Here is the most basic example of using <code>search</code>:</p><pre><code class="language-julia-repl">julia&gt; search(sf, &quot;go depth 10&quot;)
BestMoveInfo (best=d8h4, ponder=g2g3)</code></pre><p>The return value is a <code>BestMoveInfo</code>, a struct containing the two slots <code>bestmove</code> (the best move returned by the engine, a <code>Move</code>) and <code>ponder</code> (the ponder move returned by the engine, a <code>Move</code> or <code>nothing</code>).</p><p>The <code>search</code> function also takes an optional named parameter <code>infoaction</code>. This parameter is a function that takes each of the engine&#39;s <code>info</code> output lines and does something to them. Here&#39;s an example where we just print the engine output with <code>println</code> as our <code>infoaction</code>:</p><pre><code class="language-julia-repl">julia&gt; g = @simplegame d4 Nf6 c4 g6 Nc3 d5 cxd5 Nxd5;

julia&gt; setboard(sf, g)

julia&gt; search(sf, &quot;go depth 10&quot;, infoaction = println)
info string NNUE evaluation using nn-62ef826d1a6d.nnue enabled
info depth 1 seldepth 1 multipv 1 score cp 113 nodes 49 nps 24500 tbhits 0 time 2 pv g1f3
info depth 2 seldepth 2 multipv 1 score cp 114 nodes 170 nps 85000 tbhits 0 time 2 pv g1f3 d5c3
info depth 3 seldepth 3 multipv 1 score cp 114 nodes 246 nps 123000 tbhits 0 time 2 pv g1f3 d5c3 b2c3
info depth 4 seldepth 4 multipv 1 score cp 195 nodes 301 nps 150500 tbhits 0 time 2 pv g1f3 d5c3
info depth 5 seldepth 5 multipv 1 score cp 224 nodes 886 nps 295333 tbhits 0 time 3 pv g1f3 d5c3 b2c3
info depth 6 seldepth 6 multipv 1 score cp 113 nodes 1264 nps 316000 tbhits 0 time 4 pv g1f3 d5c3 b2c3 f8g7 e2e4 e8g8
info depth 7 seldepth 7 multipv 1 score cp 87 nodes 2326 nps 465200 tbhits 0 time 5 pv g1f3 d5c3 b2c3 f8g7 e2e4 e8g8 f1d3
info depth 8 seldepth 11 multipv 1 score cp 43 nodes 6660 nps 740000 tbhits 0 time 9 pv e2e4 d5c3 b2c3 c7c5 f1b5 c8d7 d1b3 f8g7 b5d7 b8d7
info depth 9 seldepth 14 multipv 1 score cp 61 nodes 9085 nps 698846 tbhits 0 time 13 pv e2e4 d5c3 b2c3 c7c5 g1f3 c5d4 d1d4
info depth 10 seldepth 14 multipv 1 score cp 30 nodes 24385 nps 762031 tbhits 0 time 32 pv e2e4 d5c3 b2c3 c7c5 f1b5 c8d7 b5d7 b8d7 g1f3 f8g7 e1g1 e8g8 c1e3
BestMoveInfo (best=e2e4, ponder=d5c3)</code></pre><h3><a class="nav-anchor" id="Parsing-Search-Output-1" href="#Parsing-Search-Output-1">Parsing Search Output</a></h3><p>In most cases, we want something more easily to manipulate than the raw string values sent by the engines <code>info</code> lines in our <code>infoaction</code> function. The function <code>parsesearchinfo</code> takes care of this. It takes an <code>info</code> string as input and returns a <code>SearchInfo</code> value, a struct that contains the various components of the <code>info</code> line as its slots.</p><p>Let&#39;s see how this works:</p><pre><code class="language-julia-repl">julia&gt; parsesearchinfo(&quot;info depth 10 seldepth 14 multipv 1 score cp 30 nodes 24385 nps 762031 tbhits 0 time 32 pv e2e4 d5c3 b2c3 c7c5 f1b5 c8d7 b5d7 b8d7 g1f3 f8g7 e1g1 e8g8 c1e3&quot;)
SearchInfo:
 depth: 10
 seldepth: 14
 time: 32
 nodes: 24385
 nps: 762031
 score: Score(30, false, Chess.UCI.exact)
 tbhits: 0
 multipv: 1
 pv: e2e4 d5c3 b2c3 c7c5 f1b5 c8d7 b5d7 b8d7 g1f3 f8g7 e1g1 e8g8 c1e3</code></pre><p>The meaning of most of the slots in this struct should be evident if you are familiar with the UCI protocol. If you are not, the two most important slots are the <code>score</code> and the <code>pv</code>.</p><p>The <code>score</code> is a value of type <code>Score</code>. The definition of the <code>Score</code> struct looks like this:</p><pre><code class="language-julia">struct Score
    value::Int
    ismate::Bool
    bound::BoundType
end</code></pre><p>There are two types of score: <em>Centipawn scores</em> are an evaluation where advantages is measured on a scale where 100 means an advantage corresponding to the value of one pawn. <em>Mate scores</em> are scores of the type &quot;mate in X moves&quot;. The type of score is indicated by the <code>ismate</code> slot, while the numerical value is indicated by the <code>value</code> slot.</p><p>For instance, when <code>value</code> is 50 and <code>ismate</code> is <code>false</code>, it means that the side to move has an advantage worth about half a pawn. If <code>value</code> is 5 and <code>ismate</code> is true, it means that the side to move has a forced checkmate in 5 half moves or less.</p><p>The final slot, <code>bound</code>, indicates whether the score is just an upper bound, a lower bound, or an exact score. The three possible values are <code>upper</code>, <code>lower</code> and <code>exact</code>.</p><p>The other interesting slot of <code>SearchInfo</code> is the <code>pv</code>. This is a vector of moves, what the engine considers the best line of play, assuming optimal play from both sides.</p><h3><a class="nav-anchor" id="Example:-Engine-vs-Engine-Games-1" href="#Example:-Engine-vs-Engine-Games-1">Example: Engine vs Engine Games</a></h3><p>Using what we have learned, we can easily make a function that generates engine vs engine games. Let&#39;s use the <code>random_opening</code> function we wrote earlier (in the section about opening books) to initialize the game with some opening position, and let the engine play out the game from there. We&#39;ll let the engine think 10 thousand nodes per move.</p><pre><code class="language-julia">function engine_game(engine)
    g = random_opening()
    while !isterminal(g)
        setboard(engine, g)
        move = search(engine, &quot;go nodes 10000&quot;).bestmove
        domove!(g, move)
    end
    g
end</code></pre><p>Let&#39;s try generating a game using Stockfish:</p><pre><code class="language-julia-repl">julia&gt; engine_game(sf)
Game:
 1. d4 d5 2. e3 Bf5 3. Bd3 Bxd3 4. Qxd3 c6 5. Nf3 e6 6. Nbd2 Nf6 7. O-O c5 8. dxc5 Nbd7 9. b4 a5 10. c3 Be7 11. h3 O-O 12. e4 Qc7 13. a4 Rfd8 14. Nd4 Ne5 15. Qe3 Ng6 16. Nb5 Qb8 17. Bb2 dxe4 18. Nxe4 Nd5 19. Qe1 h6 20. Ned6 Bf6 21. Rb1 Be7 22. c4 Ndf4 23. g3 Nxh3+ 24. Kg2 Ng5 25. f4 Nh7 26. bxa5 Bxd6 27. cxd6 Rxd6 28. Nxd6 Qxd6 29. Qe4 Qd2+ 30. Rf2 Qxa5 31. f5 exf5 32. Rxf5 Qd2+ 33. Rf2 Qd7 34. Qd5 Qe8 35. Re1 Qf8 36. c5 Ng5 37. Bc1 Rxa4 38. Bxg5 hxg5 39. Qxb7 Qxc5 40. Qxf7+ Kh7 41. Qf3 Rh4 42. Rfe2 Kh6 43. Re6 Qc2+ 44. R1e2 Qxe2+ 45. Qxe2 Kh7 46. Rxg6 Rb4 47. Rxg5 Rh4 48. Qe7 Rh2+ 49. Kxh2 Kh8 50. Qxg7# *</code></pre><p>Let&#39;s try to make a slightly more sophisticated version of this function, that also includes the engine evaluation for each move as a comment in the game.</p><p>As a first step, here&#39;s a function that creates a human readable string from a <code>Score</code> value:</p><pre><code class="language-julia">function scorestring(score, white_to_move)
    value = white_to_move ? score.value : -score.value
    if score.ismate &amp;&amp; value &gt; 0
        &quot;+#$(value)&quot;
    elseif score.ismate
        &quot;-#$(abs(value))&quot;
    elseif value &gt; 0
        &quot;+$(value * 0.01)&quot;
    else
        &quot;$(value * 0.01)&quot;
    end
end</code></pre><p>The function also takes a boolean white<em>to</em>move parameter, because we want to present the scores always from white&#39;s point of view, rather than from the side to move&#39;s point of view (which is what we get from the engine).</p><p>In our improved engine vs engine function, we need to supply an <code>infoaction</code> in the call to <code>search</code>, in order to obtain the engine evaluation. It can be done like this:</p><pre><code class="language-julia">function engine_vs_engine_with_evals(engine)
    # A variable for keeping track of the score:
    score = Score(0, true, Chess.UCI.exact)

    # An infoaction function that updates the score:
    function infoaction(infoline)
        info = parsesearchinfo(infoline)
        if !isnothing(info.score)
            score = info.score
        end
    end

    g = random_opening()
    while !isterminal(g)
        whitetomove = sidetomove(board(g)) == WHITE
        setboard(engine, g)
        # Use the infoaction defined above when calling search:
        move = search(engine, &quot;go nodes 10000&quot;, infoaction=infoaction).bestmove
        # Add the move to the game:
        domove!(g, move)
        # Add the score as a comment:
        addcomment!(g, scorestring(score, whitetomove))
    end
    g
end</code></pre><p>A test game:</p><pre><code class="language-julia-repl">julia&gt; engine_vs_engine_with_evals()
Game:
 1. Nf3 d5 2. g3 Nf6 3. Bg2 e6 4. O-O Be7 5. d3 O-O 6. Nbd2 c5 7. e4 Nc6 8. e5 Nd7 9. Re1 f6 10. exf6 Nxf6 11. b3 {+1.1} Bd7 {+0.67} 12. Bb2 {+0.68} Ng4 {+0.7000000000000001} 13. h3 {+0.54} Bf6 {+0.65} 14. Bxf6 {+0.62} Nxf6 {+0.85} 15. Ne5 {+0.87} Nxe5 {+1.06} 16. Rxe5 {+0.8} h6 {+0.89} 17. Nf3 {+1.01} a5 {+1.16} 18. a4 {+1.2} Ra6 {+1.32} 19. Re2 {+1.27} Be8 {+1.1500000000000001} 20. Qe1 {+1.07} Bf7 {+1.16} 21. Qd2 {+1.02} Nd7 {+1.3800000000000001} 22. Rae1 {+1.35} Ra8 {+1.3800000000000001} 23. Ne5 {+1.6400000000000001} Nxe5 {+1.9000000000000001} 24. Rxe5 {+1.74} b6 {+1.42} 25. h4 {+1.53} Qd6 {+1.55} 26. Bh3 {+2.02} Rae8 {+1.62} 27. f4 {+1.8900000000000001} Re7 {+1.6400000000000001} 28. f5 {+2.21} Be8 {+1.97} 29. g4 {+2.59} Bd7 {+2.68} 30. g5 {+3.3200000000000003} h5 {+3.3200000000000003} 31. g6 {+4.94} Rf6 {+6.01} 32. Qe2 {+5.98} exf5 {+6.5200000000000005} 33. Rxe7 {+6.72} Rxg6+ {+6.05} 34. Bg2 {+7.32} d4 {+5.89} 35. Kf1 {+7.28} Bc6 {+7.66} 36. Bxc6 {+7.8100000000000005} Qxc6 {+7.9} 37. Re8+ {+7.890000000000001} Kh7 {+8.13} 38. Qxh5+ {+8.15} Rh6 {+8.15} 39. Qxf5+ {+8.32} Rg6 {+8.540000000000001} 40. R1e6 {+8.5} Qg2+ {+8.73} 41. Ke1 {+8.74} Qg1+ {+8.76} 42. Kd2 {+8.88} Qg4 {+8.89} 43. Qf7 {+9.15} Rxe6 {+9.4} 44. Qg8+ {+9.6} Kh6 {+9.57} 45. Rxe6+ {+9.55} Qxe6 {+9.63} 46. Qxe6+ {+9.67} Kh5 {+9.72} 47. Qxb6 {+9.8} Kxh4 {+9.78} 48. Qxa5 {+9.870000000000001} Kh5 {+9.870000000000001} 49. Qxc5+ {+9.870000000000001} g5 {+9.870000000000001} 50. Qxd4 {+10.01} Kg6 {+64.0} 51. Qe4+ {+64.25} Kf6 {+64.26} 52. a5 {+25.27} Kg7 {+75.27} 53. a6 {+#12} Kf7 {+149.45000000000002} 54. a7 {+#5} g4 {+#3} 55. a8=Q {+#3} g3 {+#2} 56. Qf5+ {+#2} Kg7 {+#1} 57. Qaf8# {+#1} *</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../api/"><span class="direction">Next</span><span class="title">API Reference</span></a></footer></article></body></html>
