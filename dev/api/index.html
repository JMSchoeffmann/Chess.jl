<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · Chess.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Chess.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../manual/">User Guide</a></li><li class="current"><a class="toctext" href>API Reference</a><ul class="internal"><li><a class="toctext" href="#Boards-1">Boards</a></li><li><a class="toctext" href="#Games-1">Games</a></li><li><a class="toctext" href="#Opening-Books-1">Opening Books</a></li><li><a class="toctext" href="#PGN-Files-1">PGN Files</a></li><li><a class="toctext" href="#UCI-Chess-Engines-1">UCI Chess Engines</a></li><li><a class="toctext" href="#Pieces,-Piece-Types-and-Piece-Colors-1">Pieces, Piece Types and Piece Colors</a></li><li><a class="toctext" href="#Squares-1">Squares</a></li><li><a class="toctext" href="#Moves-1">Moves</a></li><li><a class="toctext" href="#Square-Sets-1">Square Sets</a></li></ul></li><li><a class="toctext" href="../api-index/">Index</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>API Reference</a></li></ul><a class="edit-page" href="https://github.com/romstad/Chess.jl/blob/master/docs/src/api.md#L"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>API Reference</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-Reference-1" href="#API-Reference-1">API Reference</a></h1><h2><a class="nav-anchor" id="Boards-1" href="#Boards-1">Boards</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.Board" href="#Chess.Board"><code>Chess.Board</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Board</code></pre><p>Type representing a chess board.</p><p>A chess board is most commonly obtained from a FEN string (using the <code>fromfen()</code> function), from the <code>startboard()</code> function (which returns a board in the usual chess starting position), or by making a move on some other chess board.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL40-L49">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.startboard" href="#Chess.startboard"><code>Chess.startboard</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">startboard()</code></pre><p>Gives a <code>Board</code> object with the standard chess initial position.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL2899-L2903">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.fromfen" href="#Chess.fromfen"><code>Chess.fromfen</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">fromfen(fen::String)</code></pre><p>Try to create a <code>Board</code> value from a FEN string.</p><p>If the supplied string doesn&#39;t represent a valid board position, this function returns <code>nothing</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL2780-L2787">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.fen" href="#Chess.fen"><code>Chess.fen</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">fen(b::Board)</code></pre><p>Convert a board to a FEN string.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL2852-L2856">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.pprint-Tuple{Board}" href="#Chess.pprint-Tuple{Board}"><code>Chess.pprint</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">pprint(b::Board, color = false, highlight = SS_EMPTY, unicode = false)</code></pre><p>Pretty-print a <code>Board</code> to the standard output.</p><p>On terminals with 24-bit color support, use <code>color = true</code> for a colored board. Use the parameter <code>highlight</code> to include a <code>SquareSet</code> you want to be highlighted.</p><p>Use <code>unicode = true</code> for Unicode piece output, if your font and terminal supports it.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; pprint(startboard(), highlight = SquareSet(SQ_D4, SQ_E4, SQ_D5, SQ_E5))
+---+---+---+---+---+---+---+---+
| r | n | b | q | k | b | n | r |
+---+---+---+---+---+---+---+---+
| p | p | p | p | p | p | p | p |
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   | * | * |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   | * | * |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
| P | P | P | P | P | P | P | P |
+---+---+---+---+---+---+---+---+
| R | N | B | Q | K | B | N | R |
+---+---+---+---+---+---+---+---+
rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq -</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL2942-L2977">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.pieceon" href="#Chess.pieceon"><code>Chess.pieceon</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">pieceon(b::Board, s::Square)
pieceon(b::Board, f::SquareFile, r::SquareRank)
pieceon(b::Board, s::String)</code></pre><p>Find the piece on the given square of the board.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b = startboard();

julia&gt; pieceon(b, SQ_E1)
PIECE_WK

julia&gt; pieceon(b, FILE_B, RANK_8)
PIECE_BN

julia&gt; pieceon(b, SQ_B5)
EMPTY

julia&gt; pieceon(b, &quot;d8&quot;)
PIECE_BQ</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL125-L149">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.sidetomove" href="#Chess.sidetomove"><code>Chess.sidetomove</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sidetomove(b::Board)</code></pre><p>The current side to move, <code>WHITE</code> or <code>BLACK</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b = startboard();

julia&gt; b2 = domove(b, &quot;e4&quot;);

julia&gt; sidetomove(b)
WHITE

julia&gt; sidetomove(b2)
BLACK</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL163-L181">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.epsquare" href="#Chess.epsquare"><code>Chess.epsquare</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">epsquare(b::Board)</code></pre><p>The square on which an en passant capture is possible, or <code>SQ_NONE</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL187-L191">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.kingsquare" href="#Chess.kingsquare"><code>Chess.kingsquare</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">kingsquare(b::Board, c::PieceColor)</code></pre><p>The square of the king for the given side.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b = startboard();

julia&gt; kingsquare(b, WHITE)
SQ_E1

julia&gt; kingsquare(b, BLACK)
SQ_E8</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL197-L213">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.pieces" href="#Chess.pieces"><code>Chess.pieces</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">pieces(b::Board, c::PieceColor)
pieces(b::Board, t::PieceType)
pieces(b::Board, c::PieceColor, t::PieceType)
pieces(b::Board, p::Piece)</code></pre><p>Obtain the set of squares containing various kinds of pieces.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b = startboard();

julia&gt; pieces(b, WHITE) == SS_RANK_1 ∪ SS_RANK_2
true

julia&gt; pieces(b, ROOK) == SquareSet(SQ_A1, SQ_H1, SQ_A8, SQ_H8)
true

julia&gt; pieces(b, BLACK, PAWN) == SS_RANK_7
true

julia&gt; pieces(b, PIECE_WB)
SquareSet:
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  #  -  -  #  -  -</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL219-L252">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.pawns" href="#Chess.pawns"><code>Chess.pawns</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">pawns(b::Board)</code></pre><p>The set of squares containing pawns of either color.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b = startboard();

julia&gt; pawns(b) == SS_RANK_2 ∪ SS_RANK_7
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL270-L283">source</a><div><div><pre><code class="language-none">pawns(b::Board, c::PieceColor)</code></pre><p>The set of squares containing pawns of the given color.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b = startboard();

julia&gt; pawns(b, WHITE) == SS_RANK_2
true

julia&gt; pawns(b, BLACK) == SS_RANK_7
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL289-L305">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.knights" href="#Chess.knights"><code>Chess.knights</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">knights(b::Board)</code></pre><p>The set of squares containing knights of either color.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b = startboard();

julia&gt; knights(b) == SquareSet(SQ_B1, SQ_G1, SQ_B8, SQ_G8)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL311-L324">source</a><div><div><pre><code class="language-none">knights(b::Board, c::PieceColor)</code></pre><p>The set of squares containing knights of the given color.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b = startboard();

julia&gt; knights(b, WHITE) == SquareSet(SQ_B1, SQ_G1)
true

julia&gt; knights(b, BLACK) == SquareSet(SQ_B8, SQ_G8)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL330-L346">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.bishops" href="#Chess.bishops"><code>Chess.bishops</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">bishops(b::Board)</code></pre><p>The set of squares containing bishops of either color.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b = startboard();

julia&gt; bishops(b) == SquareSet(SQ_C1, SQ_F1, SQ_C8, SQ_F8)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL352-L365">source</a><div><div><pre><code class="language-none">bishops(b::Board, c::PieceColor)</code></pre><p>The set of squares containing bishops of the given color.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b = startboard();

julia&gt; bishops(b, WHITE) == SquareSet(SQ_C1, SQ_F1)
true

julia&gt; bishops(b, BLACK) == SquareSet(SQ_C8, SQ_F8)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL371-L387">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.rooks" href="#Chess.rooks"><code>Chess.rooks</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">rooks(b::Board)</code></pre><p>The set of squares containing rooks of either color.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b = startboard();

julia&gt; rooks(b) == SquareSet(SQ_A1, SQ_H1, SQ_A8, SQ_H8)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL393-L406">source</a><div><div><pre><code class="language-none">rooks(b::Board, c::PieceColor)</code></pre><p>The set of squares containing rooks of the given color.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b = startboard();

julia&gt; rooks(b, WHITE) == SquareSet(SQ_A1, SQ_H1)
true

julia&gt; rooks(b, BLACK) == SquareSet(SQ_A8, SQ_H8)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL412-L428">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.queens" href="#Chess.queens"><code>Chess.queens</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">queens(b::Board)</code></pre><p>The set of squares containing queens of either color.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b = startboard();

julia&gt; queens(b) == SquareSet(SQ_D1, SQ_D8)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL434-L447">source</a><div><div><pre><code class="language-none">queens(b::Board, c::PieceColor)</code></pre><p>The set of squares containing queens of the given color.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b = startboard();

julia&gt; queens(b, WHITE) == SquareSet(SQ_D1)
true

julia&gt; queens(b, BLACK) == SquareSet(SQ_D8)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL453-L469">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.kings" href="#Chess.kings"><code>Chess.kings</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">kings(b::Board)</code></pre><p>The set of squares containing kings of either color.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b = startboard();

julia&gt; kings(b) == SquareSet(SQ_E1, SQ_E8)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL475-L488">source</a><div><div><pre><code class="language-none">kings(b::Board, c::PieceColor)</code></pre><p>The set of squares containing kings of the given color.</p><p>Unless something is very wrong, this set should always contain exactly one square.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b = startboard();

julia&gt; kings(b, WHITE) == SquareSet(SQ_E1)
true

julia&gt; kings(b, BLACK) == SquareSet(SQ_E8)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL494-L513">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.bishoplike" href="#Chess.bishoplike"><code>Chess.bishoplike</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">bishoplike(b::Board)</code></pre><p>The set of squares containing bishoplike pieces of either color.</p><p>The bishoplike pieces are the pieces that can move like a bishop, i.e. bishops and queens.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b = startboard();

julia&gt; bishoplike(b) == SquareSet(SQ_C1, SQ_D1, SQ_F1, SQ_C8, SQ_D8, SQ_F8)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL519-L535">source</a><div><div><pre><code class="language-none">bishoplike(b::Board, c::PieceColor)</code></pre><p>The set of squares containing bishoplike pieces of the given color.</p><p>The bishoplike pieces are the pieces that can move like a bishop, i.e. bishops and queens.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b = startboard();

julia&gt; bishoplike(b, WHITE) == SquareSet(SQ_C1, SQ_D1, SQ_F1)
true

julia&gt; bishoplike(b, BLACK) == SquareSet(SQ_C8, SQ_D8, SQ_F8)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL541-L560">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.rooklike" href="#Chess.rooklike"><code>Chess.rooklike</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">rooklike(b::Board)</code></pre><p>The set of squares containing rooklike pieces of either color.</p><p>The rooklike pieces are the pieces that can move like a rook, i.e. rooks and queens.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b = startboard();

julia&gt; rooklike(b) == SquareSet(SQ_A1, SQ_D1, SQ_H1, SQ_A8, SQ_D8, SQ_H8)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL566-L582">source</a><div><div><pre><code class="language-none">rooklike(b::Board, c::PieceColor)</code></pre><p>The set of squares containing rooklike pieces of the given color.</p><p>The rooklike pieces are the pieces that can move like a rook, i.e. rooks and queens.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b = startboard();

julia&gt; rooklike(b, WHITE) == SquareSet(SQ_A1, SQ_D1, SQ_H1)
true

julia&gt; rooklike(b, BLACK) == SquareSet(SQ_A8, SQ_D8, SQ_H8)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL588-L607">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.occupiedsquares" href="#Chess.occupiedsquares"><code>Chess.occupiedsquares</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">occupiedsquares(b::Board)
emptysquares(b::Board)</code></pre><p>The set of all occupied or empty squares on the board.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b = startboard();

julia&gt; occupiedsquares(b) == pieces(b, WHITE) ∪ pieces(b, BLACK)
true

julia&gt; emptysquares(b) == SS_RANK_3 ∪ SS_RANK_4 ∪ SS_RANK_5 ∪ SS_RANK_6
true

julia&gt; isempty(emptysquares(b) ∩ occupiedsquares(b))
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL613-L633">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.emptysquares" href="#Chess.emptysquares"><code>Chess.emptysquares</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">occupiedsquares(b::Board)
emptysquares(b::Board)</code></pre><p>The set of all occupied or empty squares on the board.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b = startboard();

julia&gt; occupiedsquares(b) == pieces(b, WHITE) ∪ pieces(b, BLACK)
true

julia&gt; emptysquares(b) == SS_RANK_3 ∪ SS_RANK_4 ∪ SS_RANK_5 ∪ SS_RANK_6
true

julia&gt; isempty(emptysquares(b) ∩ occupiedsquares(b))
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL613-L633">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.cancastlekingside" href="#Chess.cancastlekingside"><code>Chess.cancastlekingside</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">cancastlekingside(b::Board, c::PieceColor)</code></pre><p>Determine whether the given side still has the right to castle kingside.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL643-L647">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.cancastlequeenside" href="#Chess.cancastlequeenside"><code>Chess.cancastlequeenside</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">cancastlequeenside(b::Board, c::PieceColor)</code></pre><p>Determine whether the given side still has the right to castle queenside.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL653-L657">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.bishopattacks-Tuple{Board,Square}" href="#Chess.bishopattacks-Tuple{Board,Square}"><code>Chess.bishopattacks</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">bishopattacks(b::Board, s::Square)</code></pre><p>The set of squares a bishop on square <code>s</code> would attack on this board.</p><p>Both empty squares and squares occupied by enemy or friendly pieces are included in the set.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b = fromfen(&quot;5k2/8/4q3/8/2B5/8/4P3/3K4 w - -&quot;);

julia&gt; pprint(b, highlight=bishopattacks(b, SQ_C4))
+---+---+---+---+---+---+---+---+
|   |   |   |   |   | k |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
| * |   |   |   |*q*|   |   |   |
+---+---+---+---+---+---+---+---+
|   | * |   | * |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   | B |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   | * |   | * |   |   |   |   |
+---+---+---+---+---+---+---+---+
| * |   |   |   |*P*|   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   | K |   |   |   |   |
+---+---+---+---+---+---+---+---+
5k2/8/4q3/8/2B5/8/4P3/3K4 w - -</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL663-L696">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.rookattacks-Tuple{Board,Square}" href="#Chess.rookattacks-Tuple{Board,Square}"><code>Chess.rookattacks</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rookattacks(b::Board, s::Square)</code></pre><p>The set of squares a rook on square <code>s</code> would attack on this board.</p><p>Both empty squares and squares occupied by enemy or friendly pieces are included in the set.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b = fromfen(&quot;2r2k2/8/8/8/2R3P1/8/4P3/3K4 w - -&quot;);

julia&gt; pprint(b, highlight=rookattacks(b, SQ_C4))
+---+---+---+---+---+---+---+---+
|   |   |*r*|   |   | k |   |   |
+---+---+---+---+---+---+---+---+
|   |   | * |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   | * |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   | * |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
| * | * | R | * | * | * |*P*|   |
+---+---+---+---+---+---+---+---+
|   |   | * |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   | * |   | P |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   | * | K |   |   |   |   |
+---+---+---+---+---+---+---+---+
2r2k2/8/8/8/2R3P1/8/4P3/3K4 w - -</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL702-L735">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.queenattacks-Tuple{Board,Square}" href="#Chess.queenattacks-Tuple{Board,Square}"><code>Chess.queenattacks</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">queenattacks(b::Board, s::Square)</code></pre><p>The set of squares a queen on square <code>s</code> would attack on this board.</p><p>Both empty squares and squares occupied by enemy or friendly pieces are included in the set.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b = fromfen(&quot;2r2k2/8/8/8/2Q3P1/8/4P3/3K4 w - -&quot;);

julia&gt; pprint(b, highlight=queenattacks(b, SQ_C4))
+---+---+---+---+---+---+---+---+
|   |   |*r*|   |   | k | * |   |
+---+---+---+---+---+---+---+---+
|   |   | * |   |   | * |   |   |
+---+---+---+---+---+---+---+---+
| * |   | * |   | * |   |   |   |
+---+---+---+---+---+---+---+---+
|   | * | * | * |   |   |   |   |
+---+---+---+---+---+---+---+---+
| * | * | Q | * | * | * |*P*|   |
+---+---+---+---+---+---+---+---+
|   | * | * | * |   |   |   |   |
+---+---+---+---+---+---+---+---+
| * |   | * |   |*P*|   |   |   |
+---+---+---+---+---+---+---+---+
|   |   | * | K |   |   |   |   |
+---+---+---+---+---+---+---+---+
2r2k2/8/8/8/2Q3P1/8/4P3/3K4 w - -</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL741-L774">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.isattacked" href="#Chess.isattacked"><code>Chess.isattacked</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">isattacked(b::Board, s::Square, side::PieceColor)</code></pre><p>Determine whether the given square is attacked by the given side.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b = startboard();

julia&gt; isattacked(b, SQ_F3, WHITE)
true

julia&gt; isattacked(b, SQ_F3, BLACK)
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL780-L796">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.attacksto" href="#Chess.attacksto"><code>Chess.attacksto</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">attacksto(b::Board, s::Square)</code></pre><p>The set of squares containing pieces of either color which attack square <code>s</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b = fromfen(&quot;r1bqkbnr/pppp1ppp/2n5/4p3/3PP3/5N2/PPP2PPP/RNBQKB1R b KQkq - 0 3&quot;);

julia&gt; pprint(b, highlight=attacksto(b, SQ_D4))
+---+---+---+---+---+---+---+---+
| r |   | b | q | k | b | n | r |
+---+---+---+---+---+---+---+---+
| p | p | p | p |   | p | p | p |
+---+---+---+---+---+---+---+---+
|   |   |*n*|   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   |*p*|   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   | P | P |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |*N*|   |   |
+---+---+---+---+---+---+---+---+
| P | P | P |   |   | P | P | P |
+---+---+---+---+---+---+---+---+
| R | N | B |*Q*| K | B |   | R |
+---+---+---+---+---+---+---+---+
r1bqkbnr/pppp1ppp/2n5/4p3/3PP3/5N2/PPP2PPP/RNBQKB1R b KQkq -</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL806-L836">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.lastmove" href="#Chess.lastmove"><code>Chess.lastmove</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">lastmove(b::Board)</code></pre><p>The last move that was played to reach this board position.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL847-L851">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.ischeck" href="#Chess.ischeck"><code>Chess.ischeck</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">ischeck(b::Board)</code></pre><p>Determine whether the current side to move is in check.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL857-L861">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.ischeckmate-Tuple{Board}" href="#Chess.ischeckmate-Tuple{Board}"><code>Chess.ischeckmate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ischeckmate(b::Board)::Bool</code></pre><p>Returns <code>true</code> if the side to move is checkmated.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL2660-L2664">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.isstalemate" href="#Chess.isstalemate"><code>Chess.isstalemate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">isstalemate(b::Board)::Bool</code></pre><p>Returns <code>true</code> if the board is a stalemate position.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL2670-L2674">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.ismaterialdraw" href="#Chess.ismaterialdraw"><code>Chess.ismaterialdraw</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">ismaterialdraw(b::Board)::Bool</code></pre><p>Returns <code>true</code> if the position is a draw by material.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL2680-L2684">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.isrule50draw" href="#Chess.isrule50draw"><code>Chess.isrule50draw</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">isrule50draw(b::Board)::Bool</code></pre><p>Returns <code>true</code> if the position is drawn by the 50 moves rule.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL2691-L2695">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.isdraw-Tuple{Board}" href="#Chess.isdraw-Tuple{Board}"><code>Chess.isdraw</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isdraw(b::Board)::Bool</code></pre><p>Returns <code>true</code> if the position is an immediate draw.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL2701-L2705">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.isterminal-Tuple{Board}" href="#Chess.isterminal-Tuple{Board}"><code>Chess.isterminal</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isterminal(b::Board)::Bool</code></pre><p>Returns <code>true</code> if the game position is terminal, i.e. mate or immediate draw.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL2711-L2715">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.pinned" href="#Chess.pinned"><code>Chess.pinned</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">pinned(b::Board)</code></pre><p>The set of squares containing pinned pieces for the current side to move.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b = fromfen(&quot;2r4b/1kp5/8/2P1Q3/1P6/2K1P2r/8/8 w - -&quot;);

julia&gt; pprint(b, highlight=pinned(b))
+---+---+---+---+---+---+---+---+
|   |   | r |   |   |   |   | b |
+---+---+---+---+---+---+---+---+
|   | k | p |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   | P |   |*Q*|   |   |   |
+---+---+---+---+---+---+---+---+
|   | P |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   | K |   |*P*|   |   | r |
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
2r4b/1kp5/8/2P1Q3/1P6/2K1P2r/8/8 w - -</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL867-L897">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.domove-Tuple{Board,Move}" href="#Chess.domove-Tuple{Board,Move}"><code>Chess.domove</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">domove(b::Board, m::Move)
domove(b::Board, m::String)</code></pre><p>Do the move <code>m</code> on the board <code>b</code>, and return the new board.</p><p>The board <code>b</code> itself is left unchanged, a new board is returned. There is a much faster destructive function <code>domove!()</code> that should be called instead when high performance is required.</p><p>If the supplied move is a string, this function tries to parse the move as a UCI move first, then as a SAN move.</p><p>It&#39;s the caller&#39;s responsibility to make sure <code>m</code> is a legal move on this board.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b = startboard();

julia&gt; domove(b, &quot;Nf3&quot;)
Board (rnbqkbnr/pppppppp/8/8/8/5N2/PPPPPPPP/RNBQKB1R b KQkq -):
 r  n  b  q  k  b  n  r
 p  p  p  p  p  p  p  p
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  N  -  -
 P  P  P  P  P  P  P  P
 R  N  B  Q  K  B  -  R</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL1018-L1049">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.domove!-Tuple{Board,Move}" href="#Chess.domove!-Tuple{Board,Move}"><code>Chess.domove!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">domove!(b::Board, m::Move)
domove!(b::Board, m::String)</code></pre><p>Destructively modify the board <code>b</code> by making the move <code>m</code>.</p><p>If the supplied move is a string, this function tries to parse the move as a UCI move first, then as a SAN move.</p><p>It&#39;s the caller&#39;s responsibility to make sure the move <code>m</code> is legal.</p><p>The function returns a value of type <code>UndoInfo</code>. You&#39;ll need this if you want to later call <code>undomove!()</code> to take back the move and get the original position back.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b = startboard();

julia&gt; domove!(b, &quot;d4&quot;);

julia&gt; b
Board (rnbqkbnr/pppppppp/8/8/3P4/8/PPP1PPPP/RNBQKBNR b KQkq -):
 r  n  b  q  k  b  n  r
 p  p  p  p  p  p  p  p
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  P  -  -  -  -
 -  -  -  -  -  -  -  -
 P  P  P  -  P  P  P  P
 R  N  B  Q  K  B  N  R</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL1130-L1163">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.undomove!" href="#Chess.undomove!"><code>Chess.undomove!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">undomove!(b::Board, u::UndoInfo)</code></pre><p>Undo a move earlier done by <code>domove!()</code>.</p><p>The second parameter is the <code>UndoInfo</code> value returned by the earlier call to <code>domove!()</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b = startboard();

julia&gt; u = domove!(b, &quot;c4&quot;);

julia&gt; b
Board (rnbqkbnr/pppppppp/8/8/2P5/8/PP1PPPPP/RNBQKBNR b KQkq -):
 r  n  b  q  k  b  n  r
 p  p  p  p  p  p  p  p
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  P  -  -  -  -  -
 -  -  -  -  -  -  -  -
 P  P  -  P  P  P  P  P
 R  N  B  Q  K  B  N  R

julia&gt; undomove!(b, u);

julia&gt; b
Board (rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq -):
 r  n  b  q  k  b  n  r
 p  p  p  p  p  p  p  p
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 P  P  P  P  P  P  P  P
 R  N  B  Q  K  B  N  R</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL1235-L1273">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.domoves-Tuple{Board,Vararg{Move,N} where N}" href="#Chess.domoves-Tuple{Board,Vararg{Move,N} where N}"><code>Chess.domoves</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">domoves(b::Board, moves::Vararg{Move})
domoves(b::Board, moves::Vararg{String})</code></pre><p>Return the board achieved from a starting board <code>b</code> by making a sequence of moves.</p><p>The input board <code>b</code> is left unchanged.</p><p>If the supplied moves are strings, this function tries to parse the moves as UCI moves first, and as SAN moves if UCI move parsing fails.</p><p>It&#39;s the caller&#39;s responsibility to make sure all moves are legal. If a plain move is illegal, the consequences are undefined. If a move string cannot be parsed as an unambiguous legal move, the function throws an exception.</p><p>There is also a destructive version of this version, named <code>domoves!</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b = startboard();

julia&gt; domoves(b, &quot;d4&quot;, &quot;Nf6&quot;, &quot;c4&quot;, &quot;e6&quot;, &quot;Nc3&quot;, &quot;Bb4&quot;)
Board (rnbqk2r/pppp1ppp/4pn2/8/1bPP4/2N5/PP2PPPP/R1BQKBNR w KQkq -):
 r  n  b  q  k  -  -  r
 p  p  p  p  -  p  p  p
 -  -  -  -  p  n  -  -
 -  -  -  -  -  -  -  -
 -  b  P  P  -  -  -  -
 -  -  N  -  -  -  -  -
 P  P  -  -  P  P  P  P
 R  -  B  Q  K  B  N  R

julia&gt; domoves(b, &quot;d4&quot;, &quot;Nf6&quot;, &quot;c5&quot;)
ERROR: &quot;Illegal or ambiguous move: c5&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL1380-L1416">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.domoves!-Tuple{Board,Vararg{Move,N} where N}" href="#Chess.domoves!-Tuple{Board,Vararg{Move,N} where N}"><code>Chess.domoves!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">domoves!(b::Board, moves::Vararg{Move})
domoves!(b::Board, moves::Vararg{String})</code></pre><p>Destructively modify the board b by making a sequence of moves.</p><p>If the supplied moves are strings, this function tries to parse the moves as UCI moves first, and as SAN moves if UCI move parsing fails.</p><p>It&#39;s the caller&#39;s responsibility to make sure all moves are legal. If a plain move is illegal, the consequences are undefined. If a move string cannot be parsed as an unambiguous legal move, the function throws an exception.</p><p>There is also a non-destructive version of this version, named <code>domoves</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b = startboard();

julia&gt; domoves!(b, &quot;e4&quot;, &quot;c5&quot;, &quot;Nf3&quot;, &quot;d6&quot;, &quot;d4&quot;, &quot;cxd4&quot;, &quot;Nxd4&quot;, &quot;Nf6&quot;, &quot;Nc3&quot;);

julia&gt; b
Board (rnbqkb1r/pp2pppp/3p1n2/8/3NP3/2N5/PPP2PPP/R1BQKB1R b KQkq -):
 r  n  b  q  k  b  -  r
 p  p  -  -  p  p  p  p
 -  -  -  p  -  n  -  -
 -  -  -  -  -  -  -  -
 -  -  -  N  P  -  -  -
 -  -  N  -  -  -  -  -
 P  P  P  -  -  P  P  P
 R  -  B  Q  K  B  -  R

julia&gt; b = startboard();

julia&gt; domoves!(b, &quot;e4&quot;, &quot;Qxe4+&quot;)
ERROR: &quot;Illegal or ambiguous move: Qxe4+&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL1320-L1357">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.MoveList" href="#Chess.MoveList"><code>Chess.MoveList</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MoveList</code></pre><p>An iterable type containing a a list of moves, as produced by legal move generators.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL1429-L1434">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.push!-Tuple{MoveList,Move}" href="#Base.push!-Tuple{MoveList,Move}"><code>Base.push!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">push!(list::MoveList, m::Move)</code></pre><p>Add a new move to the move list.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL1480-L1484">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.recycle!" href="#Chess.recycle!"><code>Chess.recycle!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">recycle!(list::MoveList)</code></pre><p>Recycle the move list in order to re-use for generating new moves.</p><p>This is useful when you want to avoid allocating too much heap memory. If you have a <code>MoveList</code> lying around that you no longer need, consider reusing it instead of creating a new one the next time you need to generate some moves.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL1491-L1499">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.moves" href="#Chess.moves"><code>Chess.moves</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">moves(b::Board, list::MoveList)
moves(b::Board)</code></pre><p>Obtain a list of all legal moves from this board.</p><p>When performance is important, consider using the two-argument method that supplies a pre-allocated move list.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL2609-L2617">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.movecount" href="#Chess.movecount"><code>Chess.movecount</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">movecount(b::Board)::Int</code></pre><p>The number of legal moves from this board.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL2631-L2635">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.haslegalmoves" href="#Chess.haslegalmoves"><code>Chess.haslegalmoves</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">haslegalmoves(b::Board)::Bool</code></pre><p>Returns <code>true</code> if the side to move has at least one legal move.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL2641-L2645">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.perft" href="#Chess.perft"><code>Chess.perft</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">perft(b::Board, depth::Int)</code></pre><p>Do a <code>perft</code> search to the given depth.</p><p>See https://www.chessprogramming.org/Perft.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL2739-L2745">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.divide" href="#Chess.divide"><code>Chess.divide</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">divide(b::Board, depth::Int)</code></pre><p>Do a <code>divide</code> search to debug the <code>perft()</code> function.</p><p>See https://www.chessprogramming.org/Perft.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL2756-L2762">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.START_FEN" href="#Chess.START_FEN"><code>Chess.START_FEN</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">START_FEN</code></pre><p>The FEN string of the standard chess opening position.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/board.jl#LL2891-L2895">source</a></section><h2><a class="nav-anchor" id="Games-1" href="#Games-1">Games</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.SimpleGame" href="#Chess.SimpleGame"><code>Chess.SimpleGame</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SimpleGame</code></pre><p>A type representing a simple game, with no support for comments or variations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL79-L83">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.SimpleGame" href="#Chess.SimpleGame"><code>Chess.SimpleGame</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SimpleGame(startboard::Board=startboard())</code></pre><p>Constructor that creates a <code>SimpleGame</code> from the provided starting position.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL113-L117">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.SimpleGame-Tuple{String}" href="#Chess.SimpleGame-Tuple{String}"><code>Chess.SimpleGame</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">SimpleGame(startfen::String)</code></pre><p>Constructor that creates a <code>SimpleGame</code> from the position given by the provided FEN string.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL132-L137">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.Game" href="#Chess.Game"><code>Chess.Game</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Game</code></pre><p>Type representing a chess game, with support for comments and variations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL210-L214">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.Game-Tuple{}" href="#Chess.Game-Tuple{}"><code>Chess.Game</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Game()</code></pre><p>Constructor that creates a new <code>Game</code> from the regular starting position.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL282-L286">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.Game-Tuple{Board}" href="#Chess.Game-Tuple{Board}"><code>Chess.Game</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Game(startboard::Board)</code></pre><p>Constructor that creates a <code>Game</code> from the provided starting position.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL256-L260">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.Game-Tuple{String}" href="#Chess.Game-Tuple{String}"><code>Chess.Game</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Game(startfen::String)</code></pre><p>Constructor that creates a <code>Game</code> from the position given by the provided FEN string.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL271-L276">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.GameHeader" href="#Chess.GameHeader"><code>Chess.GameHeader</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">GameHeader</code></pre><p>Type representing a PGN header tag.</p><p>Contains <code>name</code> and <code>value</code> slots, both of which are strings.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL31-L37">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.GameHeaders" href="#Chess.GameHeaders"><code>Chess.GameHeaders</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">GameHeaders</code></pre><p>Type representing the PGN header tags for a game.</p><p>Contains a slot for each the seven required PGN tags <code>event</code>, <code>site</code>, <code>date</code>, <code>round</code>, <code>white</code>, <code>black</code> and <code>result</code>, all of which are strings. Remaining tags are included in the <code>othertags</code> slot, which contains a vector of <code>GameHeader</code>s.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL44-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.GameNode" href="#Chess.GameNode"><code>Chess.GameNode</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">GameNode</code></pre><p>Type representing a node in a <code>Game</code>.</p><p>Game can contain variations, so this type actually represents a node in a tree-like structure.</p><p>A <code>GameNode</code> is a mutable struct with the following slots:</p><ul><li><code>parent</code>: The parent <code>GameNode</code>, or <code>nothing</code> if this node is the root of the game.</li><li><code>board</code>: The board position at this node.</li><li><code>children</code>: A vector of <code>GameNode</code>s, the children of the current node. The first entry is the main continuation, the remaining entries are alternative variations.</li><li><code>data</code>: A <code>Dict{String, Any}</code> used to store information about this node. This is used for comments and numeric annotation glyphs, but can also be used to store other data.</li><li><code>id</code>: An <code>Int</code>, used to look up this node in a <code>Game</code>, which contains a dictionary mapping ids to <code>GameNode</code>s.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL143-L164">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.headervalue" href="#Chess.headervalue"><code>Chess.headervalue</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">headervalue(ghs::GameHeaders, name::String)
headervalue(g::SimpleGame, name::String)
headervalue(g::Game, name::String)</code></pre><p>Looks up the value for the header with the given name.</p><p>Returns the value as a <code>String</code>, or <code>nothing</code> if no header with the provided name exists.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL292-L301">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.dateplayed" href="#Chess.dateplayed"><code>Chess.dateplayed</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">dateplayed(g::SimpleGame)::Union{Date, Nothing}
dateplayed(g::Game)::Union{Date, Nothing}</code></pre><p>The date at which the game was played, or <code>nothing</code>.</p><p>This function makes use of the PGN date tag, trying to behave robustly with sensible defaults when the date is incomplete or incorrectly formatted. It handles both ISO format YYYY-MM-DD dates and PGN format YYYY.MM.DD dates. If either the month or the day is missing, they are replaced with 1. On failure, returns <code>nothing</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = Game();

julia&gt; setheadervalue!(g, &quot;Date&quot;, &quot;2019.09.20&quot;);

julia&gt; dateplayed(g)
2019-09-20

julia&gt; setheadervalue!(g, &quot;Date&quot;, &quot;2019.09.??&quot;);

julia&gt; dateplayed(g)
2019-09-01

julia&gt; setheadervalue!(g, &quot;Date&quot;, &quot;2019.??.??&quot;);

julia&gt; dateplayed(g)
2019-01-01

julia&gt; setheadervalue!(g, &quot;Date&quot;, &quot;*&quot;);

julia&gt; dateplayed(g) == nothing
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL361-L398">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.whiteelo" href="#Chess.whiteelo"><code>Chess.whiteelo</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">whiteelo(g::SimpeGame)
whiteelo(g::Game)</code></pre><p>The Elo of the white player (as given by the &quot;WhiteElo&quot; tag), or <code>nothing</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL408-L413">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.blackelo" href="#Chess.blackelo"><code>Chess.blackelo</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">blackelo(g::SimpeGame)
blackelo(g::Game)</code></pre><p>The Elo of the black player (as given by the &quot;BlackElo&quot; tag), or <code>nothing</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL425-L430">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.setheadervalue!" href="#Chess.setheadervalue!"><code>Chess.setheadervalue!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">setheadervalue!(ghs::GameHeaders, name::String, value::String)
setheadervalue!(g::SimpleGame, name::String, value::String)
setheadervalue!(g::Game, name::String, value::String)</code></pre><p>Sets a header value, creating the header if it doesn&#39;t exist.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL442-L448">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.board" href="#Chess.board"><code>Chess.board</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">board(g::SimpleGame)
board(g::Game)</code></pre><p>The board position at the current node in a game.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL486-L491">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.domove!-Tuple{SimpleGame,Move}" href="#Chess.domove!-Tuple{SimpleGame,Move}"><code>Chess.domove!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">domove!(g::SimpleGame, m::Move)
domove!(g::SimpleGame, m::String)
domove!(g::Game, m::Move)
domove!(g::Game, m::String)</code></pre><p>Adds a new move at the current location in the game move list.</p><p>If the supplied move is a string, this function tries to parse the move as a UCI move first, then as a SAN move.</p><p>If we are at the end of the game, all previous moves are kept, and the new move is added at the end. If we are at any earlier point in the game (because we have taken back one or more moves), the existing game continuation will be deleted and replaced by the new move. All variations starting at this point in the game will also be deleted. If you want to add the new move as a variation instead, make sure you use the <code>Game</code> type instead of <code>SimpleGame</code>, and use <code>addmove!</code> instead of <code>domove!</code>.</p><p>The move <code>m</code> is assumed to be a legal move. It&#39;s the caller&#39;s responsibility to ensure that this is the case.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL574-L595">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.domoves!-Tuple{SimpleGame,Vararg{Union{Move, String},N} where N}" href="#Chess.domoves!-Tuple{SimpleGame,Vararg{Union{Move, String},N} where N}"><code>Chess.domoves!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">domoves!(g::SimpleGame, moves::Vararg{Union{Move, String}})
domoves!(g::Game, moves::Vararg{Union{Move, String}})</code></pre><p>Adds a sequence of new moves at the current location in the game move list.</p><p>The moves can be either <code>Move</code> values or strings. In the case of strings, the function tries to parse them first as UCI moves, then as SAN moves.</p><p>If we are at the end of the game, all previous moves are kept, and the new moves are added at the end. If we are at any earlier point in the game (because we have taken back one or more moves), the existing game continuation will be deleted and replaced by the new moves. All variations starting at this point in the game will also be deleted. If you want to add the new moves as a variation instead, make sure you use the <code>Game</code> type instead of <code>SimpleGame</code>, and use <code>addmoves!</code> instead of <code>domoves!</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL625-L641">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.addmove!" href="#Chess.addmove!"><code>Chess.addmove!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">addmove!(g::Game, m::Move)
addmove!(g::Game, m::String)</code></pre><p>Adds the move <code>m</code> to the game <code>g</code> at the current node.</p><p>If the supplied move is a string, this function tries to parse the move as a UCI move first, then as a SAN move.</p><p>The move <code>m</code> must be a legal move from the current node board position. A new game node with the board position after the move has been made is added to the end of the current node&#39;s children vector, and that node becomes the current node of the game.</p><p>The move <code>m</code> is assumed to be a legal move. It&#39;s the caller&#39;s responsibility to ensure that this is the case.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL655-L671">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.addmoves!" href="#Chess.addmoves!"><code>Chess.addmoves!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">addmoves!(g::Game, moves::Vararg{Union{Move, String}})</code></pre><p>Adds a sequence of moves to the game <code>g</code> at the current node.</p><p>The moves can be either <code>Move</code> values or strings. In the case of strings, the function tries to parse them first as UCI moves, then as SAN moves.</p><p>This function works by calling <code>addmove!</code> repeatedly for all input moves. It&#39;s the caller&#39;s responsibility to ensure that all moves are legal and unambiguous.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL690-L700">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.nextmove" href="#Chess.nextmove"><code>Chess.nextmove</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">nextmove(g::SimpleGame)
nextmove(g::Game)</code></pre><p>The next move in the game, or <code>nothing</code> if we&#39;re at the end of the game.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL709-L714">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.isatbeginning" href="#Chess.isatbeginning"><code>Chess.isatbeginning</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">isatbeginning(g::SimpleGame)::Bool
isatbeginning(g::Game)::Bool</code></pre><p>Return <code>true</code> if we are at the beginning of the game, and <code>false</code> otherwise.</p><p>We can be at the beginning of the game either because we haven&#39;t yet added any moves to the game, or because we have stepped back to the beginning.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleGame();

julia&gt; isatbeginning(g)
true

julia&gt; domove!(g, &quot;e4&quot;);

julia&gt; isatbeginning(g)
false

julia&gt; back!(g);

julia&gt; isatbeginning(g)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL727-L754">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.isatend" href="#Chess.isatend"><code>Chess.isatend</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">isatend(g::SimpleGame)::Bool
isatend(g::Game)::Bool</code></pre><p>Return <code>true</code> if we are at the end of the game, and <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleGame();

julia&gt; isatend(g)
true

julia&gt; domove!(g, &quot;Nf3&quot;);

julia&gt; isatend(g)
true

julia&gt; back!(g);

julia&gt; isatend(g)
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL764-L788">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.back!" href="#Chess.back!"><code>Chess.back!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">back!(g::SimpleGame)
back!(g::Game)</code></pre><p>Go one step back in the game by retracting a move.</p><p>If we&#39;re already at the beginning of the game, the game is unchanged.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL798-L805">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.forward!" href="#Chess.forward!"><code>Chess.forward!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">forward!(g::SimpleGame)
forward!(g::Game)
forward!(g::Game, m::Move)
forward!(g::Game, m::String)</code></pre><p>Go one step forward in the game by replaying a previously retracted move.</p><p>If we&#39;re already at the end of the game, the game is unchanged. If the current node has multiple children, we always pick the first child (i.e. the main line). If any child other than the first child is desired, supply the move leading to the child node as the second argument. It&#39;s the caller&#39;s responsibility that the move supplied leads to one of the existing child nodes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL822-L835">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.tobeginning!" href="#Chess.tobeginning!"><code>Chess.tobeginning!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">tobeginning!(g::SimpleGame)
tobeginning!(g::Game)</code></pre><p>Go back to the beginning of a game by taking back all moves.</p><p>If we&#39;re already at the beginning of the game, the game is unchanged.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL871-L878">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.toend!" href="#Chess.toend!"><code>Chess.toend!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">toend!(g::SimpleGame)
toend!(g::Game)</code></pre><p>Go forward to the end of a game by replaying all moves, following the main line.</p><p>If we&#39;re already at the end of the game, the game is unchanged.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL895-L902">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.tobeginningofvariation!" href="#Chess.tobeginningofvariation!"><code>Chess.tobeginningofvariation!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">tobeginningofvariation!(g::Game)</code></pre><p>Go to the beginning of the variation containing the current node of the game.</p><p>Steps back up the game tree until we reach the point where the first child node (i.e. the main line) is not contained in the current variation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL918-L925">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.tonode!" href="#Chess.tonode!"><code>Chess.tonode!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">tonode!(g::Game, id::Int)</code></pre><p>Go to the game tree node with the given node id, if it exists.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL938-L942">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.isleaf" href="#Chess.isleaf"><code>Chess.isleaf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">isleaf(n::GameNode)::Bool</code></pre><p>Tests whether a <code>GameNode</code> is a leaf, i.e. that it has no children.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL949-L953">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.comment" href="#Chess.comment"><code>Chess.comment</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">comment(n::GameNode)</code></pre><p>The comment after the move leading to this node, or <code>nothing</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL959-L963">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.precomment" href="#Chess.precomment"><code>Chess.precomment</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">precomment(n::GameNode)</code></pre><p>The comment before the move leading to this node, or <code>nothing</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL969-L973">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.nag" href="#Chess.nag"><code>Chess.nag</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">nag(n::GameNode)</code></pre><p>The numeric annotation glyph for the move leading to this node, or <code>nothing</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL979-L983">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.addcomment!" href="#Chess.addcomment!"><code>Chess.addcomment!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">addcomment!(g::Game, comment::String)</code></pre><p>Adds a comment to the current game node.</p><p>In PGN and other text ouput formats, the comment is printed <em>after</em> the move leading to the node.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL1075-L1082">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.addprecomment!" href="#Chess.addprecomment!"><code>Chess.addprecomment!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">addprecomment!(g::Game, comment::String)</code></pre><p>Adds a pre-comment to the current game node.</p><p>In PGN and other text ouput formats, the comment is printed <em>before</em> the move leading to the node.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL1088-L1095">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.addnag!" href="#Chess.addnag!"><code>Chess.addnag!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">addnag!(g::Game, nag::Int)</code></pre><p>Adds a Numeric Annotation Glyph (NAG) to the current game node.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL1101-L1105">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.removeallchildren!" href="#Chess.removeallchildren!"><code>Chess.removeallchildren!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">removeallchildren!(g::Game, node::GameNode = g.node)</code></pre><p>Recursively remove all children of the given node in the game.</p><p>If no node is supplied, removes the children of the current node.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL989-L995">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.removenode!" href="#Chess.removenode!"><code>Chess.removenode!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">removenode!(g::Game, node::GameNode = g.node)</code></pre><p>Remove a node (by default, the current node) in a <code>Game</code>, and go to the parent node.</p><p>All children of the node are also recursively deleted.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL1006-L1013">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.adddata!" href="#Chess.adddata!"><code>Chess.adddata!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">adddata!(n::GameNode, key::String, value)</code></pre><p>Add a piece of data to the given node&#39;s data dictionary.</p><p>This is a low-level function that is mainly used to add comments and NAGs, but can also be used to add any type of custom annotation data to a game node.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL1025-L1032">source</a><div><div><pre><code class="language-none">adddata!(g::Game, key::String, value)</code></pre><p>Add a piece of data to the current game node&#39;s data dictionary.</p><p>This is a low-level function that is mainly used to add comments and NAGs, but can also be used to add any type of custom annotation data to a game node.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL1038-L1045">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.removedata!" href="#Chess.removedata!"><code>Chess.removedata!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">removedata!(n::GameNode, key::String)</code></pre><p>Remove a piece of data from the game node&#39;s data dictionary.</p><p>This is a low-level function that is mainly used to delete comments and NAGs.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL1051-L1057">source</a><div><div><pre><code class="language-none">removedata!(n::GameNode, key::String)</code></pre><p>Remove a piece of data from the current game node&#39;s data dictionary.</p><p>This is a low-level function that is mainly used to delete comments and NAGs.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL1063-L1069">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.continuations" href="#Chess.continuations"><code>Chess.continuations</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">continuations(n::GameNode)::Vector{Move}
continuations(g::Game)::Vector{Move}</code></pre><p>All moves at this node in the game tree.</p><p>One move for each child node of the current node.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = Game();

julia&gt; addmoves!(g, &quot;e4&quot;, &quot;e5&quot;);

julia&gt; back!(g);

julia&gt; addmove!(g, &quot;c5&quot;);

julia&gt; back!(g);

julia&gt; continuations(g)
2-element Array{Move,1}:
 Move(e7e5)
 Move(c7c5)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL538-L564">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.isdraw-Tuple{SimpleGame}" href="#Chess.isdraw-Tuple{SimpleGame}"><code>Chess.isdraw</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isdraw(g::SimpleGame)
isdraw(g::Game)</code></pre><p>Checks whether the current game position is drawn.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL1145-L1150">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.ischeckmate-Tuple{SimpleGame}" href="#Chess.ischeckmate-Tuple{SimpleGame}"><code>Chess.ischeckmate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ischeckmate(g::SimpleGame)
ischeckmate(g::Game)</code></pre><p>Checks whether the current game position is a checkmate.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL1160-L1165">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.isterminal-Tuple{SimpleGame}" href="#Chess.isterminal-Tuple{SimpleGame}"><code>Chess.isterminal</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isterminal(g::SimpleGame)
isterminal(g::Game)</code></pre><p>Checks whether the current game position is terminal, i.e. mate or drawn.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/game.jl#LL1175-L1180">source</a></section><h2><a class="nav-anchor" id="Opening-Books-1" href="#Opening-Books-1">Opening Books</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.Book.BookEntry" href="#Chess.Book.BookEntry"><code>Chess.Book.BookEntry</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">BookEntry</code></pre><p>A struct representing an opening book entry.</p><p>Book entries contain the following slots:</p><ul><li><code>key</code>: The hash key of the board position this book entry represents.</li><li><code>move</code>: The move played, encoded as an <code>Int32</code>. In order to get the actual <code>Move</code> value representing the move stored in a book entry <code>e</code>, you should do <code>Move(e.move)</code>.</li><li><code>elo</code>: The highest Elo rating of a player who played this move.</li><li><code>oppelo</code>: The highest Elo of the opponent in a game where this move was played.</li><li><code>wins</code>: The number of times the player who played this move won the game.</li><li><code>draws</code>: The number of times the player who played this move drew the game.</li><li><code>losses</code>: The number of times the player who played this move lost the game.</li><li><code>firstyear</code>: The year this move was first played.</li><li><code>lastyear</code>: The year this move was last played.</li><li><code>score</code>: The score of this move, used to obtain a probability distribution when picking a book move for a position. The score is computed based on the W/L/D stats for the move, the ratings of the players who have played it, and on its popularity in more recent games.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/book.jl#LL29-L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.Book.createbook" href="#Chess.Book.createbook"><code>Chess.Book.createbook</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">createbook(pgnfiles::Vararg{String};
           scorewhitewin = 8.0,
           scorewhitedraw = 4.0,
           scorewhiteloss = 1.0,
           scoreblackwin = 8.0,
           scoreblackdraw = 5.0,
           scoreblackloss = 1.0,
           scoreunknown = 0.0,
           highelofactor = 6.0,
           yearlydecay = 0.85,
           maxply = 60,
           minelo = 0)</code></pre><p>Creates an opening book tree from one or more PGN files.</p><p>The opening tree is stored in RAM. You will probably want to save it to disk using <code>writebooktofile</code> afterwards, for instance like this:</p><pre><code class="language-julia-repl">julia&gt; bk = createbook(&quot;my-pgn-file.pgn&quot;);

julia&gt; writebooktofile(bk, &quot;my-book.obk&quot;)</code></pre><p>The createbook function takes a number of optional named parameters that can be used to control what moves are included in the opening tree, and the scoring of the moves (which is used to produce move probabilities when picking a move using <code>pickbookmove</code>). These are:</p><ul><li><code>scorewhitewin</code>: The base score for all white moves in a game won by white.</li><li><code>scorewhitedraw</code>: The base score for all white moves in a drawn game.</li><li><code>scorewhiteloss</code>: The base score for all black moves in a game won by black.</li><li><code>scoreblackwin</code>: The base score for all black moves in a game won by black.</li><li><code>scoreblackdraw</code>: The base score for all black moves in a drawn game.</li><li><code>scoreblackloss</code>: The base score for all black moves in a game won by white.</li><li><code>scoreunknown</code>: The base score for all moves in a game with an unknown result.</li><li><code>highelofactor</code>: Score multiplier for moves played by a player with high rating. The base score is multiplied by <code>max(1.0 0.01 * highelofactor * (2300 - elo))</code></li><li><code>yearlydecay</code>: Controls exponential yearly reduction of scores. If a game was played <code>n</code> years ago, all scores are multiplied by <code>n^yearlydecay</code>.</li><li><code>maxply</code>: Maximum depth of the opening tree. If <code>maxply</code> equals 60 (the default), no moves after move 30 are included in the opening tree.</li><li><code>minelo</code>: Minimum Elo for book moves. Moves played by players below this number are not included in the opening tree.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/book.jl#LL249-L295">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.Book.writebooktofile" href="#Chess.Book.writebooktofile"><code>Chess.Book.writebooktofile</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">writebooktofile(entries::Vector{BookEntry}, filename::String,
                compact = false)</code></pre><p>Writes a book (as created by <code>createbookfile</code>) to a binary file.</p><p>If the optional parameter <code>compact</code> is <code>true</code>, the book is written in a more compact format that does not include W/L/D counts, Elo numbers and years.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/book.jl#LL321-L329">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.Book.purgebook" href="#Chess.Book.purgebook"><code>Chess.Book.purgebook</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">purgebook(infilename::String, outfilename::String;
          minscore = 0, mingamecount = 5, compact = false)</code></pre><p>Creates a smaller version of an opening book file by removing unimportant lines.</p><p>Book moves with score lower than <code>minscore</code> or which have been played in fewer than <code>mingamecount</code> games are not included in the output file.</p><p>If the optional parameter <code>compact</code> is <code>true</code>, the output file is written in a more compact format that does not include W/L/D counts, Elo numbers and years.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/book.jl#LL341-L352">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.Book.findbookentries" href="#Chess.Book.findbookentries"><code>Chess.Book.findbookentries</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">findbookentries(b::Board, bookfilename::String)
findbookentries(key::UInt64, bookfilename::String)</code></pre><p>Returns all book entries for the given board or key.</p><p>The return value is a (possibly empty) <code>Vector{BookEntry}</code>, sorted by descending scores.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/book.jl#LL407-L415">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.Book.pickbookmove" href="#Chess.Book.pickbookmove"><code>Chess.Book.pickbookmove</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">pickbookmove(b::Board, bookfilename::String;
             minscore = 0, mingamecount = 1)</code></pre><p>Picks a book move for the board <code>b</code>, returning <code>nothing</code> when out of book.</p><p>The move is selected with probabilities given by the <code>score</code> slots in the <code>BookEntry</code> objects. The <code>minscore</code> and <code>mingamecount</code> parameters can be used to exclude moves with low score or low play counts.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/book.jl#LL462-L471">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.Book.printbookentries" href="#Chess.Book.printbookentries"><code>Chess.Book.printbookentries</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">printbookentries(b::Board, bookfilename::String)</code></pre><p>Pretty-print the move entries for the provided board.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/book.jl#LL442-L447">source</a></section><h2><a class="nav-anchor" id="PGN-Files-1" href="#PGN-Files-1">PGN Files</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.PGN.PGNReader" href="#Chess.PGN.PGNReader"><code>Chess.PGN.PGNReader</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">PGNReader</code></pre><p>A type for reading PGN data from a stream.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/pgn.jl#LL32-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.PGN.PGNReader-Tuple{IO}" href="#Chess.PGN.PGNReader-Tuple{IO}"><code>Chess.PGN.PGNReader</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">PGNReader(io::IO)</code></pre><p>Initializes a <code>PGNReader</code> from an <code>IO</code> object.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/pgn.jl#LL43-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.PGN.readgame" href="#Chess.PGN.readgame"><code>Chess.PGN.readgame</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">readgame(p::PGNReader; annotations=false)</code></pre><p>Attempts to parse a PGN game and use it to create a <code>Game</code> or a <code>SimpleGame</code>.</p><p>If the optional parameter <code>annotations</code> is <code>true</code>, the return value will be a <code>Game</code> containing all comments, variations and numeric annotation glyphs in the PGN. Otherwise, it will be a <code>SimpleGame</code> with only the game moves.</p><p>This function assumes that the <code>PGNReader</code> is pointed at the beginning of a game. If you are not sure this is the case, call <code>gotonextgame!</code> on the <code>PGNReader</code> first.</p><p>If parsing fails or the notation contains illegal or ambiguous moves, the function raises a <code>PGNException</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/pgn.jl#LL432-L447">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.PGN.gamefromstring" href="#Chess.PGN.gamefromstring"><code>Chess.PGN.gamefromstring</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">gamefromstring(s::String; annotations=false)</code></pre><p>Attempts to create a <code>Game</code> or <code>SimpleGame</code> object from the provided PGN string.</p><p>If the optional parameter <code>annotations</code> is <code>true</code>, the return value will be a <code>Game</code> containing all comments, variations and numeric annotation glyphs in the PGN. Otherwise, it will be a <code>SimpleGame</code> with only the game moves.</p><p>If the string does not parse as valid PGN, or if the notation contains illegal or ambiguous moves, the function raises a <code>PGNException</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/pgn.jl#LL533-L544">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.PGN.gametopgn" href="#Chess.PGN.gametopgn"><code>Chess.PGN.gametopgn</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">gametopgn(g)::String</code></pre><p>Exports a <code>Game</code> or a <code>SimpleGame</code> to a PGN string.</p><p><strong>Limitations</strong></p><ul><li>The movetext section is written in a single long line, with no line breaks.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/pgn.jl#LL658-L666">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.PGN.gamesinfile" href="#Chess.PGN.gamesinfile"><code>Chess.PGN.gamesinfile</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">gamesinfile(filename::String; annotations=false)</code></pre><p>Creates a <code>Channel</code> of <code>Game</code>/<code>SimpleGame</code> objects read from the PGN file with the provided file name.</p><p>If the optional parameter <code>annotations</code> is <code>true</code>, the return value will be a channel of <code>Game</code> objects containing all comments, variations and numeric annotation glyphs in the PGN. Otherwise, it will consist of <code>SimpleGame</code> objects with only the game moves.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/pgn.jl#LL508-L518">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.PGN.gotonextgame!" href="#Chess.PGN.gotonextgame!"><code>Chess.PGN.gotonextgame!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">gotonextgame!(p::PGNReader)::Bool</code></pre><p>Tries to go to the next game, returns <code>true</code> on success.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/pgn.jl#LL373-L377">source</a></section><h2><a class="nav-anchor" id="UCI-Chess-Engines-1" href="#UCI-Chess-Engines-1">UCI Chess Engines</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.UCI.Engine" href="#Chess.UCI.Engine"><code>Chess.UCI.Engine</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Engine</code></pre><p>Type representing a UCI chess engine.</p><p>This is a struct with the following slots:</p><ul><li><code>name</code>: The engine name, as provided by the engine in response to the <code>uci</code> command.</li><li><code>author</code>: The engine author name, as provided by the engine in response to the <code>uci</code> command.</li><li><code>options</code>: The UCI options for this engine. This is a dictionary mapping option names (<code>String</code>s) to options (instances of the <code>Option</code> type).</li><li><code>io</code>: A <code>Base.Process</code> object used to communicate with the engine.</li></ul><p>Engines are created by calling the <code>runengine</code> function, which takes a pathname for an UCI engine as input, runs the engine, and returns an <code>Engine</code> object.</p><p><strong>Examples</strong></p><p>The below is a typical interaction with a UCI engine. The example assumes that you have a UCI engine with the file name <code>stockfish</code> somewhere in your <code>PATH</code>.</p><pre><code class="language-julia-repl">julia&gt; sf = runengine(&quot;stockfish&quot;);

julia&gt; setoption(sf, &quot;Hash&quot;, 128)

julia&gt; setboard(sf, fromfen(&quot;1kbr3r/pp6/8/P1n2ppq/2N3n1/R3Q1P1/3B1P2/2R2BK1 w - -&quot;))

julia&gt; search(sf, &quot;go depth 18&quot;, infoaction=println)
info depth 1 seldepth 1 multipv 1 score cp -842 nodes 88 nps 88000 tbhits 0 time 1 pv f1g2 g4e3 d2e3
info depth 2 seldepth 2 multipv 1 score cp -842 nodes 207 nps 103500 tbhits 0 time 2 pv f1g2 g4e3
info depth 3 seldepth 3 multipv 1 score cp -844 nodes 270 nps 135000 tbhits 0 time 2 pv f1g2 g4e3 d2e3 d8d1 c1d1 h5d1 g2f1
info depth 4 seldepth 5 multipv 1 score cp -844 nodes 367 nps 183500 tbhits 0 time 2 pv f1g2 g4e3 d2e3 d8d1 c1d1
info depth 5 seldepth 7 multipv 1 score cp -953 nodes 866 nps 433000 tbhits 0 time 2 pv f1g2 h5h2 g1f1 g4e3 d2e3 c5d3 e3g5
info depth 6 seldepth 8 multipv 1 score cp -1060 nodes 1507 nps 753500 tbhits 0 time 2 pv f1g2 g4e3 d2e3 c5d3 e3d2 d3c1
info depth 7 seldepth 11 multipv 1 score cp -876 nodes 1995 nps 665000 tbhits 0 time 3 pv f1g2 g4e3
info depth 8 seldepth 10 multipv 1 score cp -882 nodes 2771 nps 923666 tbhits 0 time 3 pv f1g2 g4e3 d2e3 c8e6 e3c5 d8d1 c1d1 h5d1 g2f1 e6c4
info depth 9 seldepth 15 multipv 1 score cp -1068 nodes 12059 nps 1339888 tbhits 0 time 9 pv f1g2 g4e3 a3e3 c8e6 e3e6 c5e6 d2e1 d8d1 c1d1 h5d1
info depth 10 seldepth 15 multipv 1 score cp -1050 nodes 17558 nps 1463166 tbhits 0 time 12 pv f1g2 g4e3 a3e3 c8e6 g1f1 h5g4 e3e6 c5e6 c4e3 g4a4 d2c3
info depth 11 seldepth 17 multipv 1 score cp -1013 nodes 23543 nps 1569533 tbhits 0 time 15 pv f1g2 g4e3 a3e3 c8e6 g1f1 h5g4 e3e6 c5e6 c4e3 g4a4 d2c3
info depth 12 seldepth 20 multipv 1 score cp -995 nodes 48497 nps 1672310 tbhits 0 time 29 pv f1g2 g4e3 a3e3 c8e6 g1f1 c5e4 d2e1 d8c8 g3g4 h5g4 c4e5 g4h4 c1c8 h8c8
info depth 13 seldepth 29 multipv 1 score cp -1116 nodes 205726 nps 1959295 tbhits 0 time 105 pv f1g2 g4e3 f2e3 c5e4 a3a2 h5h2 g1f1 e4g3 f1f2 g3e4 f2f1 e4d2 c4d2 h2g3 d2f3 d8d3 f1g1 d3e3 f3d4 e3e8 a2e2
info depth 14 seldepth 28 multipv 1 score cp -148 nodes 247247 nps 1993927 tbhits 0 time 124 pv e3f4 g5f4 d2f4 b8a8 c4b6 a7b6 a5b6 c5a6
info depth 15 seldepth 16 multipv 1 score cp 120 nodes 248911 nps 1991288 tbhits 0 time 125 pv e3f4 g5f4 d2f4 g4e5 f4e5 d8d6 e5d6 b8a8 f1g2 c8e6 d6c5
info depth 16 seldepth 24 multipv 1 score cp 1117 nodes 251829 nps 1982905 tbhits 0 time 127 pv e3f4 g4e5 f4e5 d8d6 e5d6 b8a8 f1g2 h5h2 g1f1 c5e4 g2e4 f5e4 d2g5 c8h3 f1e2
info depth 17 seldepth 22 multipv 1 score cp 1500 nodes 258707 nps 1990053 tbhits 0 time 130 pv e3f4 g4e5 f4e5 d8d6 e5d6 b8a8 f1g2 h5h2 g1f1 c5e4 g2e4 h2h3 e4g2
info depth 18 seldepth 22 multipv 1 score mate 11 nodes 281736 nps 1984056 tbhits 0 time 142 pv e3f4 g5f4 d2f4 g4e5 f4e5 d8d6 e5d6 b8a8 c4b6 a7b6 a5b6 c5a6 c1c8 h8c8
BestMoveInfo (best=e3f4, ponder=g5f4)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/uci.jl#LL185-L236">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.UCI.runengine" href="#Chess.UCI.runengine"><code>Chess.UCI.runengine</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function runengine(path::String)::Engine</code></pre><p>Runs the engine at the specified path, returning an <code>Engine</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/uci.jl#LL247-L251">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.UCI.quit" href="#Chess.UCI.quit"><code>Chess.UCI.quit</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function quit(e::Engine)</code></pre><p>Sends the UCI engine <code>e</code> the <code>&quot;quit&quot;</code> command.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/uci.jl#LL325-L329">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.UCI.setoption" href="#Chess.UCI.setoption"><code>Chess.UCI.setoption</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function setoption(e::Engine, name::String, value::OptionValue = nothing)</code></pre><p>Sets the UCI option named <code>name</code> to the new value <code>value</code>.</p><p>Throws an error if the engine <code>e</code> does not have an option with the provided name, or if the value is incompatible with the type of the option.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/uci.jl#LL301-L308">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.UCI.sendcommand" href="#Chess.UCI.sendcommand"><code>Chess.UCI.sendcommand</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sendcommand(e::Engine, cmd::String)</code></pre><p>Sends the UCI command <code>cmd</code> to the engine <code>e</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/uci.jl#LL274-L278">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.UCI.setboard" href="#Chess.UCI.setboard"><code>Chess.UCI.setboard</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">setboard(e::Engine, b::Board)
setboard(e::Engine, g::SimpleGame)
setboard(e::Engine, g::Game)</code></pre><p>Set the engine&#39;s current board position to the given board/game state.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/uci.jl#LL622-L628">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.UCI.search" href="#Chess.UCI.search"><code>Chess.UCI.search</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function search(e::Engine, gocmd::String; infoaction = nothing)</code></pre><p>Tells a UCI engine to start searching.</p><p>The parameter <code>gocmd</code> is the actual command you want to send to the engine; e.g. <code>&quot;go movetime 10000&quot;</code> or <code>&quot;go infinite&quot;</code>. The named parameter <code>infoaction</code> is a function accepting the output of the engine&#39;s <code>&quot;info&quot;</code> commands and doing something with the output. Usually, it will be some function making internal use of <code>parsesearchinfo()</code>.</p><p>The return value is of type <code>BestMoveInfo</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/uci.jl#LL596-L608">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.UCI.BestMoveInfo" href="#Chess.UCI.BestMoveInfo"><code>Chess.UCI.BestMoveInfo</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">BestMoveInfo</code></pre><p>A struct representing the contents of a UCI engine&#39;s <code>bestmove</code> output.</p><p>Contains the following slots:</p><ul><li><code>bestmove</code>: The <code>Move</code> returned by the engine as the best move.</li><li><code>ponder</code>: The engine&#39;s expected reply to the best move, a <code>Move</code> or <code>nothing</code>.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/uci.jl#LL366-L376">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.UCI.parsebestmove" href="#Chess.UCI.parsebestmove"><code>Chess.UCI.parsebestmove</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">parsebestmove(line::String)::BestMoveInfo</code></pre><p>Parses a <code>bestmove</code> line printed by a UCI engine to a <code>BestMoveInfo</code> object.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/uci.jl#LL392-L396">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.UCI.SearchInfo" href="#Chess.UCI.SearchInfo"><code>Chess.UCI.SearchInfo</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SearchInfo</code></pre><p>A struct representing the contents of a UCI engine&#39;s <code>info</code> output.</p><p>Contains the following slots, all of which can be <code>nothing</code> for a given line of search output:</p><ul><li><code>depth</code>: The current search depth.</li><li><code>seldepth</code>: The current selective search depth.</li><li><code>time</code>: The time spent searching so far, in milliseconds.</li><li><code>nodes</code>: The number of nodes searched so far.</li><li><code>pv</code>: The main line, as a vector of <code>Move</code> values.</li><li><code>multipv</code>: The multipv index of the line currently printed.</li><li><code>score</code>: The score, a value of type <code>Score</code>.</li><li><code>currmove</code>: The move currently searched, a value of type <code>Move</code>.</li><li><code>currmovenumber</code>: The index of the move currently searched in the move list.</li><li><code>hashfull</code>: A number in the range 0–100, indicating the transposition table saturation percentage.</li><li><code>nps</code>: Nodes/second count.</li><li><code>tbhits</code>: Number of tablebase hits.</li><li><code>cpuload</code>: CPU load percentage.</li><li><code>string</code>: An arbitrary string sent by the engine.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/uci.jl#LL410-L433">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.UCI.parsesearchinfo" href="#Chess.UCI.parsesearchinfo"><code>Chess.UCI.parsesearchinfo</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">parsesearchinfo(line::String)::SearchInfo</code></pre><p>Parses an <code>info</code> line printed by a UCI engine to a <code>SearchInfo</code> object.</p><p>See the documentation for <code>SearchInfo</code> for information about how to inspect and use the return value.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/uci.jl#LL548-L555">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.UCI.touci" href="#Chess.UCI.touci"><code>Chess.UCI.touci</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">touci(b::Board)
touci(g::SimpleGame)
touci(g::Game)</code></pre><p>Create a UCI string representation of a board or a game.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; touci(startboard())
&quot;position fen rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq -&quot;

julia&gt; sg = SimpleGame(); domove!(sg, &quot;e4&quot;); domove!(sg, &quot;c5&quot;); domove!(sg, &quot;Nf3&quot;);

julia&gt; touci(sg)
&quot;position fen rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - moves e2e4 c7c5 g1f3&quot;

julia&gt; g = Game(); domove!(g, &quot;d4&quot;); domove!(g, &quot;Nf6&quot;); domove!(g, &quot;c4&quot;);

julia&gt; touci(g)
&quot;position fen rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - moves d2d4 g8f6 c2c4&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/uci.jl#LL642-L664">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.UCI.Score" href="#Chess.UCI.Score"><code>Chess.UCI.Score</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Score</code></pre><p>A struct type representing a score returned by a UCI engine.</p><p>The struct has the following slots:</p><ul><li><code>value</code>: An <code>Int</code> representing the score value.</li><li><code>ismate</code>: A <code>Bool</code> that tells whether this is a mate score.</li><li><code>bound</code>: A <code>BoundType</code>, indicating whether this score is a lower bound, an upper bound, or an exact value.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/uci.jl#LL347-L358">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.UCI.BoundType" href="#Chess.UCI.BoundType"><code>Chess.UCI.BoundType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">BoundType</code></pre><p>An enum type representing the score bound types <code>lower</code>, <code>upper</code> and <code>exact</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.UCI.Option" href="#Chess.UCI.Option"><code>Chess.UCI.Option</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Option</code></pre><p>Type representing a UCI option. This is a mutable struct with the following slots:</p><ul><li><code>name</code>: A <code>String</code>, the name of the option, as provided by the engine.</li><li><code>type</code>: An <code>OptionType</code>, the type of the option, as provided by the engine.</li><li><code>defaultValue</code>: An <code>OptionValue</code>, as provided by the engine.</li><li><code>value</code>: An <code>OptionValue</code>, the current value of the option.</li><li><code>min</code>: The minimum value of this option. Only used for options of type <code>spin</code>.</li><li><code>max</code>: The maximum value of this option. Only used for options of type <code>spin</code>.</li><li><code>combovals</code>: Vector of the possible values for this option. Only used for options of type <code>Combo</code>.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/uci.jl#LL57-L70">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.UCI.OptionType" href="#Chess.UCI.OptionType"><code>Chess.UCI.OptionType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">OptionType</code></pre><p>Type representing an UCI option type. This is an enum with values corresponding to the option types defined in the UCI protocol: <code>check</code>, <code>spin</code>, <code>combo</code>, <code>button</code> and <code>string</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/#L0-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.UCI.OptionValue" href="#Chess.UCI.OptionValue"><code>Chess.UCI.OptionValue</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">OptionValue</code></pre><p>Type representing the value of a UCI option. This is a union type containing the types <code>Nothing</code> (for options of type <code>button</code>), <code>Bool</code> (for options of type <code>check</code>, <code>Int</code> (for options of type <code>spin</code>) and <code>String</code> (for options of type <code>combo</code> or <code>string</code>).)</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/uci.jl#LL46-L53">source</a></section><h2><a class="nav-anchor" id="Pieces,-Piece-Types-and-Piece-Colors-1" href="#Pieces,-Piece-Types-and-Piece-Colors-1">Pieces, Piece Types and Piece Colors</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.Piece" href="#Chess.Piece"><code>Chess.Piece</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Piece</code></pre><p>Type representing a chess piece.</p><p>The possible values are <code>PIECE_WP</code>, <code>PIECE_WN</code>, <code>PIECE_WB</code>, <code>PIECE_WR</code>, <code>PIECE_WQ</code>, <code>PIECE_WK</code>, <code>PIECE_BP</code>, <code>PIECE_BN</code>, <code>PIECE_BB</code>, <code>PIECE_BR</code>, <code>PIECE_BQ</code>, <code>PIECE_BK</code> and <code>EMPTY</code>. The reason for the existence of the value <code>EMPTY</code> is that we represent a chess board as an array of pieces, and we need a value to indicate an empty square on the board.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/piece.jl#LL313-L323">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.Piece-Tuple{PieceColor,PieceType}" href="#Chess.Piece-Tuple{PieceColor,PieceType}"><code>Chess.Piece</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Piece(c::PieceColor, t::PieceType)</code></pre><p>Construct a piece with the given color and type.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Piece(BLACK, QUEEN)
PIECE_BQ</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/piece.jl#LL329-L339">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.PieceColor" href="#Chess.PieceColor"><code>Chess.PieceColor</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">PieceColor</code></pre><p>Type representing the color of a chess piece.</p><p>The possible values are <code>WHITE</code>, <code>BLACK</code> and <code>COLOR_NONE</code>. The reason for the existence of the value <code>COLOR_NONE</code> is that we represent a chess board as an array of pieces, and we need a special <code>Piece</code> value <code>EMPTY</code> to indicate an empty square on the board. The color of the <code>EMPTY</code> piece is <code>COLOR_NONE</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/piece.jl#LL30-L39">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.PieceType" href="#Chess.PieceType"><code>Chess.PieceType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">PieceType</code></pre><p>Type representing the type of a chess piece.</p><p>This is essentially a piece without color. The possible values are <code>PAWN</code>, <code>KNIGHT</code>, <code>BISHOP</code>, <code>ROOK</code>, <code>QUEEN</code>, <code>KING</code> and <code>PIECE_TYPE_NONE</code>. The reason for the existence of the value <code>PIECE_TYPE_NONE</code> is that we represent a chess board as an array of pieces, and we need a special <code>Piece</code> value <code>EMPTY</code> to indicate an empty square on the board. The type of the <code>EMPTY</code> piece is <code>PIECE_TYPE_NONE</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/piece.jl#LL171-L182">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.pcolor" href="#Chess.pcolor"><code>Chess.pcolor</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">pcolor(p::Piece)</code></pre><p>Find the color of a <code>Piece</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; pcolor(PIECE_WB)
WHITE

julia&gt; pcolor(EMPTY)
COLOR_NONE</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/piece.jl#LL369-L383">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.ptype" href="#Chess.ptype"><code>Chess.ptype</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">ptype(p::Piece)</code></pre><p>Find the type of a <code>Piece</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ptype(PIECE_BQ)
QUEEN

julia&gt; ptype(EMPTY)
PIECE_TYPE_NONE</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/piece.jl#LL389-L403">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.coloropp" href="#Chess.coloropp"><code>Chess.coloropp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">coloropp(c::PieceColor)</code></pre><p>Returns the opposite of a color.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; coloropp(WHITE) == BLACK
true

julia&gt; coloropp(BLACK) == WHITE
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/piece.jl#LL89-L103">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.isslider" href="#Chess.isslider"><code>Chess.isslider</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">isslider(t::PieceType)
isslider(p::Piece)</code></pre><p>Determine whether a piece is a sliding piece.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/piece.jl#LL513-L518">source</a><div><div><pre><code class="language-julia">isslider(t::PieceType)
isslider(p::Piece)</code></pre><p>Determine whether a piece is a sliding piece.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/piece.jl#LL513-L518">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.colorfromchar" href="#Chess.colorfromchar"><code>Chess.colorfromchar</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">colorfromchar(c::Char)</code></pre><p>Tries to convert a character to a <code>PieceColor</code>.</p><p>The return value is a <code>Union{PieceColor, Nothing}</code>. If the input character is one of the four characters <code>&#39;w&#39;</code>, <code>&#39;b&#39;</code>, <code>&#39;W&#39;</code>, <code>&#39;B&#39;</code>, the function returns the obvious corresponding color (<code>WHITE</code> or <code>BLACK</code>). For all other input characters, the function returns <code>nothing</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; colorfromchar(&#39;w&#39;) == WHITE
true

julia&gt; colorfromchar(&#39;B&#39;) == BLACK
true

julia&gt; colorfromchar(&#39;x&#39;) == nothing
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/piece.jl#LL109-L131">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.piecetypefromchar" href="#Chess.piecetypefromchar"><code>Chess.piecetypefromchar</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">piecetypefromchar(c::Chars)</code></pre><p>Tries to convert a character to a <code>PieceType</code>.</p><p>The return value is a <code>Union{PieceType, Nothing}</code>. If the input character is a valid upper- or lowercase English piece letter (PNBRQK), the function returns the corresponding piece type. For all other input characters, the function returns <code>nothing</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; piecetypefromchar(&#39;n&#39;) == KNIGHT
true

julia&gt; piecetypefromchar(&#39;B&#39;) == BISHOP
true

julia&gt; piecetypefromchar(&#39;a&#39;) == nothing
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/piece.jl#LL248-L270">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.piecefromchar" href="#Chess.piecefromchar"><code>Chess.piecefromchar</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">piecefromchar(ch::Char)</code></pre><p>Tries to convert a character to a <code>Piece</code>.</p><p>The return value is a <code>Union{Piece, Nothing}</code>. If the input character is a valid English piece letter, the corresponding piece is returned. If the piece letter is uppercase, the piece is white. If the piece letter is lowercase, the piece is black.</p><p>If the input value is not a valid English piece letter, the function returns <code>nothing</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; piecefromchar(&#39;Q&#39;)
PIECE_WQ

julia&gt; piecefromchar(&#39;n&#39;)
PIECE_BN

julia&gt; piecefromchar(&#39;-&#39;) == nothing
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/piece.jl#LL438-L463">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.tochar-Tuple{PieceColor}" href="#Chess.tochar-Tuple{PieceColor}"><code>Chess.tochar</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tochar(c::PieceColor)</code></pre><p>Converts a color to a character.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; tochar(WHITE)
&#39;w&#39;: ASCII/Unicode U+0077 (category Ll: Letter, lowercase)

julia&gt; tochar(BLACK)
&#39;b&#39;: ASCII/Unicode U+0062 (category Ll: Letter, lowercase)

julia&gt; tochar(COLOR_NONE)
&#39;?&#39;: ASCII/Unicode U+003f (category Po: Punctuation, other)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/piece.jl#LL142-L159">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.tochar" href="#Chess.tochar"><code>Chess.tochar</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">tochar(t::PieceType, uppercase = false)</code></pre><p>Converts a <code>PieceType</code> value to a character.</p><p>A valid piece type value is converted to its standard English algebraic notation piece letter. Any invalid piece type value is converted to a <code>&#39;?&#39;</code> character. The optional parameter <code>uppercase</code> controls whether the character is an upper- or lower-case letter.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; tochar(PAWN)
&#39;p&#39;: ASCII/Unicode U+0070 (category Ll: Letter, lowercase)

julia&gt; tochar(ROOK, true)
&#39;R&#39;: ASCII/Unicode U+0052 (category Lu: Letter, uppercase)

julia&gt; tochar(PIECE_TYPE_NONE)
&#39;?&#39;: ASCII/Unicode U+003f (category Po: Punctuation, other)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/piece.jl#LL281-L303">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.tochar-Tuple{Piece}" href="#Chess.tochar-Tuple{Piece}"><code>Chess.tochar</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tochar(p::Piece)</code></pre><p>Converts a piece to a character.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; tochar(PIECE_WN)
&#39;N&#39;: ASCII/Unicode U+004e (category Lu: Letter, uppercase)

julia&gt; tochar(PIECE_BK)
&#39;k&#39;: ASCII/Unicode U+006b (category Ll: Letter, lowercase)

julia&gt; tochar(EMPTY)
&#39;?&#39;: ASCII/Unicode U+003f (category Po: Punctuation, other)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/piece.jl#LL475-L492">source</a></section><h2><a class="nav-anchor" id="Squares-1" href="#Squares-1">Squares</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.Square" href="#Chess.Square"><code>Chess.Square</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Square</code></pre><p>Type representing a square on a chess board.</p><p>A <code>Square</code> can be constructed either with an <code>Int</code> (with the convention a8=1, a7=2, ..., a1=8, b8=9, b7=10, ..., h1=64) or with a <code>SquareFile</code> and a <code>SquareRank</code>. There are also constants <code>SQ_A1</code>, ..., <code>SQ_H8</code> for all 64 squares on the board.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Square(FILE_G, RANK_6)
SQ_G6

julia&gt; Square(8)
SQ_A1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/square.jl#LL242-L261">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.Square-Tuple{SquareFile,SquareRank}" href="#Chess.Square-Tuple{SquareFile,SquareRank}"><code>Chess.Square</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Square(f::SquareFile, r::SquareRank)</code></pre><p>Construct a square with the given file and rank.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Square(FILE_D, RANK_5)
SQ_D5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/square.jl#LL278-L289">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.SquareFile" href="#Chess.SquareFile"><code>Chess.SquareFile</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SquareFile</code></pre><p>Type representing the file of a square on a chess board.</p><p>Usually, a <code>SquareFile</code> is obtained either by calling the function <code>file()</code> on a <code>Square</code> or through one of the constants <code>FILE_A</code>, <code>FILE_B</code>, ..., <code>FILE_H</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/square.jl#LL44-L51">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.SquareRank" href="#Chess.SquareRank"><code>Chess.SquareRank</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SquareRank</code></pre><p>Type representing the rank of a square on a chess board.</p><p>Usually, a <code>SquareRank</code> is obtained either by calling the function <code>rank()</code> on a <code>Square</code> or through one of the constants <code>RANK_1</code>, <code>RANK_2</code>, ..., <code>RANK_8</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/square.jl#LL57-L64">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.SquareDelta" href="#Chess.SquareDelta"><code>Chess.SquareDelta</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SquareDelta</code></pre><p>A type representing the delta or vector between two squares.</p><p>A <code>SquareDelta</code> value is usually obtained either through one of the constants <code>DELTA_N</code>, <code>DELTA_S</code>, <code>DELTA_E</code>, <code>DELTA_W</code>, <code>DELTA_NW</code>, <code>DELTA_NE</code>, <code>DELTA_SW</code>, <code>DELTA_SE</code>, or by subtracting two square values.</p><p>It is possible to add or subtract two <code>SquareDelta</code>s, to multiply a <code>SquareDelta</code> by an integer scalar, or to add or subtract a <code>SquareDelta</code> to a <code>Square</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; DELTA_N + DELTA_W == DELTA_NW
true

julia&gt; SQ_D3 - SQ_C3 == DELTA_E
true

julia&gt; SQ_G8 - 3 * DELTA_N
SQ_G5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/square.jl#LL453-L478">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.file" href="#Chess.file"><code>Chess.file</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">file(s::Square)</code></pre><p>Compute the file of the square <code>s</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; file(SQ_C4)
FILE_C</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/square.jl#LL293-L304">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.rank" href="#Chess.rank"><code>Chess.rank</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">rank(s::Square)</code></pre><p>Compute the rank of the square <code>s</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; rank(SQ_C4)
RANK_4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/square.jl#LL310-L321">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.distance-Tuple{Square,Square}" href="#Chess.distance-Tuple{Square,Square}"><code>Chess.distance</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">distance(s1::Square, s2::Square)</code></pre><p>The distance between two squares, counted by number of king moves.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/square.jl#LL443-L447">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.distance-Tuple{SquareFile,SquareFile}" href="#Chess.distance-Tuple{SquareFile,SquareFile}"><code>Chess.distance</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">distance(f1::SquareFile, f2::SquareFile)</code></pre><p>The horizontal distance between two files.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/square.jl#LL423-L427">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.distance-Tuple{SquareRank,SquareRank}" href="#Chess.distance-Tuple{SquareRank,SquareRank}"><code>Chess.distance</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">distance(r1::SquareRank, r2::SquareRank)</code></pre><p>The vertical distance between two ranks.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/square.jl#LL433-L437">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.filefromchar" href="#Chess.filefromchar"><code>Chess.filefromchar</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">filefromchar(c::Char)</code></pre><p>Tries to convert a character to a file.</p><p>The return value is a <code>Union{SquareFile, Nothing}</code>. The <code>nothing</code> is returned in case the character does not represent a valid file.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; filefromchar(&#39;c&#39;)
FILE_C

julia&gt; filefromchar(&#39;2&#39;) == nothing
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/square.jl#LL160-L177">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.rankfromchar" href="#Chess.rankfromchar"><code>Chess.rankfromchar</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">rankfromchar(c::Char)</code></pre><p>Tries to convert a character to a rank.</p><p>The return value is a <code>Union{SquareRank, Nothing}</code>. The <code>nothing</code> is returned in case the character does not represent a valid rank.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; rankfromchar(&#39;2&#39;)
RANK_2

julia&gt; rankfromchar(&#39;x&#39;) == nothing
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/square.jl#LL184-L201">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.tochar-Tuple{SquareFile}" href="#Chess.tochar-Tuple{SquareFile}"><code>Chess.tochar</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tochar(f::SquareFile)</code></pre><p>Converts a <code>SquareFile</code> to a character.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; tochar(FILE_E)
&#39;e&#39;: ASCII/Unicode U+0065 (category Ll: Letter, lowercase)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/square.jl#LL208-L219">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.tochar-Tuple{SquareRank}" href="#Chess.tochar-Tuple{SquareRank}"><code>Chess.tochar</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tochar(r::SquareRank)</code></pre><p>Converts <code>SquareRank</code> to a character.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; tochar(RANK_3)
&#39;3&#39;: ASCII/Unicode U+0033 (category Nd: Number, decimal digit)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/square.jl#LL225-L236">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.squarefromstring" href="#Chess.squarefromstring"><code>Chess.squarefromstring</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">squarefromstring(s::String)</code></pre><p>Tries to convert a string to a <code>Square</code>.</p><p>The return value is of type <code>Union{Square, Nothing}</code>.</p><p>If the input string is too short, or if the two first characters do not represent a square in standard algebraic notation, returns <code>nothing</code>. If the first two characters do represent avalid square, that square is returned, even if there are additional characters.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; squarefromstring(&quot;d6&quot;)
SQ_D6

julia&gt; squarefromstring(&quot;xy&quot;) == nothing
true

julia&gt; squarefromstring(&quot;&quot;) == nothing
true

julia&gt; squarefromstring(&quot;g1f3&quot;)
SQ_G1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/square.jl#LL380-L407">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.tostring-Tuple{Square}" href="#Chess.tostring-Tuple{Square}"><code>Chess.tostring</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tostring(s::Square)</code></pre><p>Converts a square to a string in standard algebraic notation. If the square has an invalid value, the returned string is <code>&quot;??&quot;</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; tostring(SQ_E4)
&quot;e4&quot;

julia&gt; tostring(Square(100))
&quot;??&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/square.jl#LL353-L368">source</a></section><h2><a class="nav-anchor" id="Moves-1" href="#Moves-1">Moves</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.Move" href="#Chess.Move"><code>Chess.Move</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Move</code></pre><p>Type representing a chess move.</p><p>A <code>Move</code> value is usually obtained by asking a chess board for moves, or by parsing a move string in UCI or SAN format (in the latter case, we also need a board).</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/move.jl#LL23-L31">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.Move-Tuple{Square,Square}" href="#Chess.Move-Tuple{Square,Square}"><code>Chess.Move</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Move(from::Square, to::Square)</code></pre><p>Low-level constructor for creating a move with the given <code>from</code> and <code>to</code> squares.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/move.jl#LL40-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.Move-Tuple{Square,Square,PieceType}" href="#Chess.Move-Tuple{Square,Square,PieceType}"><code>Chess.Move</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Move(from::Square, to::Square, promotion::PieceType)</code></pre><p>Low-level constructor for creating a move with the given <code>from</code> and <code>to</code> squares and promotion piece type.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/move.jl#LL51-L56">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.from-Tuple{Move}" href="#Chess.from-Tuple{Move}"><code>Chess.from</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">from(m::Move)</code></pre><p>The source square of a move.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Move(SQ_D2, SQ_D4)
Move(d2d4)

julia&gt; from(Move(SQ_G1, SQ_F3))
SQ_G1

julia&gt; from(Move(SQ_C7, SQ_C8, QUEEN))
SQ_C7</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/move.jl#LL62-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.to-Tuple{Move}" href="#Chess.to-Tuple{Move}"><code>Chess.to</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">to(m::Move)</code></pre><p>The destination square of a move.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; to(Move(SQ_G1, SQ_F3))
SQ_F3

julia&gt; to(Move(SQ_C7, SQ_C8, QUEEN))
SQ_C8
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/move.jl#LL85-L100">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.ispromotion-Tuple{Move}" href="#Chess.ispromotion-Tuple{Move}"><code>Chess.ispromotion</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ispromotion(m::Move)</code></pre><p>Determine whether a move is a promotion move.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ispromotion(Move(SQ_G1, SQ_F3))
false

julia&gt; ispromotion(Move(SQ_C7, SQ_C8, QUEEN))
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/move.jl#LL106-L120">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.promotion-Tuple{Move}" href="#Chess.promotion-Tuple{Move}"><code>Chess.promotion</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">promotion(m::Move)</code></pre><p>Find the promotion piece type of a move.</p><p>Use this function only after first using <code>ispromotion</code> to determine whether the move is a promotion move at all.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; promotion(Move(SQ_C7, SQ_C8, QUEEN))
QUEEN

julia&gt; promotion(Move(SQ_B2, SQ_B1, KNIGHT))
KNIGHT</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/move.jl#LL126-L143">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.tostring-Tuple{Move}" href="#Chess.tostring-Tuple{Move}"><code>Chess.tostring</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tostring(m::Move)</code></pre><p>Convert a move to a string in UCI notation.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; tostring(Move(SQ_G1, SQ_F3))
&quot;g1f3&quot;

julia&gt; tostring(Move(SQ_E2, SQ_E1, KNIGHT))
&quot;e2e1n&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/move.jl#LL149-L163">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.movefromstring-Tuple{String}" href="#Chess.movefromstring-Tuple{String}"><code>Chess.movefromstring</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">movefromstring(s::String)</code></pre><p>Convert a UCI move string to a move.</p><p>Returns <code>nothing</code> if the input string is not a valid UCI move.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; movefromstring(&quot;d2d4&quot;) == Move(SQ_D2, SQ_D4)
true

julia&gt; movefromstring(&quot;h7h8q&quot;) == Move(SQ_H7, SQ_H8, QUEEN)
true

julia&gt; movefromstring(&quot;f7f9&quot;) == nothing
true

julia&gt; movefromstring(&quot;&quot;) == nothing
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/move.jl#LL169-L191">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.movefromsan" href="#Chess.movefromsan"><code>Chess.movefromsan</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">movefromsan((b::Board, san::String))::Union{Move, Nothing}</code></pre><p>Tries to read a move in Short Algebraic Notation.</p><p>Returns <code>nothing</code> if the provided string is an impossible or ambiguous move.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; movefromsan(b, &quot;Nf3&quot;)
Move(g1f3)

julia&gt; movefromsan(b, &quot;???&quot;) == nothing
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/san.jl#LL22-L38">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.movetosan" href="#Chess.movetosan"><code>Chess.movetosan</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function movetosan(b::Board, m::Move)</code></pre><p>Converts a move to a string in short algebraic notation.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b = startboard();

julia&gt; movetosan(b, Move(SQ_D2, SQ_D4))
&quot;d4&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/san.jl#LL134-L146">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.variationtosan-Tuple{Board,Array{Move,1}}" href="#Chess.variationtosan-Tuple{Board,Array{Move,1}}"><code>Chess.variationtosan</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">variationtosan(board::Board, v::Vector{Move};
               startply=1, movenumbers=true)::String</code></pre><p>Converts a variation to a string in short algebraic notation.</p><p>The vector of moves <code>v</code> should be a sequence of legal moves from the board position. If <code>movenumbers</code> is <code>true</code>, move numbers will be included in the string. The moves are numbered from 1, unless some other variable is supplied through the <code>startply</code> parameter.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b = startboard();

julia&gt; variationtosan(b, map(movefromstring, [&quot;e2e4&quot;, &quot;e7e5&quot;, &quot;g1f3&quot;, &quot;b8c6&quot;]))
&quot;1. e4 e5 2. Nf3 Nc6&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/san.jl#LL215-L233">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.variationtosan-Tuple{SimpleGame,Array{Move,1}}" href="#Chess.variationtosan-Tuple{SimpleGame,Array{Move,1}}"><code>Chess.variationtosan</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">variationtosan(g::SimpleGame, v::Vector{Move}; movenumbers=true)::String
variationtosan(g::Game, v::Vector{Move}; movenumbers=true)::String</code></pre><p>Converts a variation to a string in short algebraic notation.</p><p>The vector of moves <code>v</code> should be a sequence of legal moves from the current board position of the game. If <code>movenumbers</code> is <code>true</code>, move numbers will be included in the string.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = Game();

julia&gt; domoves!(g, &quot;d4&quot;, &quot;Nf6&quot;, &quot;c4&quot;, &quot;e6&quot;, &quot;Nf3&quot;);

julia&gt; variationtosan(g, map(movefromstring, [&quot;f8b4&quot;, &quot;c1d2&quot;, &quot;d8e7&quot;]))
&quot;3... Bb4+ 4. Bd2 Qe7&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/san.jl#LL257-L275">source</a></section><h2><a class="nav-anchor" id="Square-Sets-1" href="#Square-Sets-1">Square Sets</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.SquareSet" href="#Chess.SquareSet"><code>Chess.SquareSet</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SquareSet</code></pre><p>A type representing a set of squares on the chess board.</p><p>The most common ways of obtaining a square set are:</p><ul><li><p>Initializing it with one or more squares, for instance <code>SquareSet(SQ_D4, SQ_E4, SQ_D5, SQ_E5)</code>.</p></li><li><p>From one of the predefined square set constants, like <code>SS_FILE_C</code> (the squares on the C file) or <code>SS_RANK_7</code> (the squares on the 7th rank).</p></li><li><p>By extracting it from a chess board. See the <code>Board</code> type for details about this.</p></li><li><p>By performing operations transforming or combining one or more square sets to a new square set.</p></li></ul><p>The union or intersection of two sets can be computed by the functions <code>union</code> and <code>intersect</code>, or by the corresponding binary operators <code>∪</code> and <code>∩</code>. The complement of a square set is denoted by the unary <code>-</code> operator. The difference between two set is obtained by the <code>setdiff</code> function or by the binary <code>-</code> operator. Subset relationships can be tested by the <code>issubset</code> function or the binary operator <code>⊆</code>.</p><p>To add or remove a square to a square set, use the <code>+</code> or <code>-</code> operators with the square set as the left operand and the square as the right operand. To test whether a square set contains a square, use <code>s in ss</code> or <code>s ∈ ss</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL39-L68">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty" href="#Base.isempty"><code>Base.isempty</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">isempty(ss::SquareSet)</code></pre><p>Determine whether a square set is the empty set.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isempty(SS_RANK_1)
false

julia&gt; isempty(SS_EMPTY)
true

julia&gt; isempty(SS_RANK_1 ∩ SS_RANK_2)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL303-L320">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.in" href="#Base.in"><code>Base.in</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">in(s::Square, ss::SquareSet)
∈(s::Square, ss::SquareSet)</code></pre><p>Determine whether a square is a member of a square set.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; SQ_D7 ∈ SS_RANK_8
false

julia&gt; SQ_D8 ∈ SS_RANK_8
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL504-L519">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.squares" href="#Chess.squares"><code>Chess.squares</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">squares(ss::SquareSet)</code></pre><p>Convert a square set to a vector of squares.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; tostring.(squares(SS_RANK_1))
8-element Array{String,1}:
 &quot;a1&quot;
 &quot;b1&quot;
 &quot;c1&quot;
 &quot;d1&quot;
 &quot;e1&quot;
 &quot;f1&quot;
 &quot;g1&quot;
 &quot;h1&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL643-L662">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.union" href="#Base.union"><code>Base.union</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">union(ss1::SquareSet, ss2::SquareSet)
∪(ss1::SquareSet, ss2::SquareSet)</code></pre><p>Compute the union of two square sets.</p><p>The binary operator <code>∪</code> can be used instead of the named function.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; SS_FILE_C ∪ SS_RANK_3
SquareSet:
 -  -  #  -  -  -  -  -
 -  -  #  -  -  -  -  -
 -  -  #  -  -  -  -  -
 -  -  #  -  -  -  -  -
 -  -  #  -  -  -  -  -
 #  #  #  #  #  #  #  #
 -  -  #  -  -  -  -  -
 -  -  #  -  -  -  -  -</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL326-L348">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.intersect" href="#Base.intersect"><code>Base.intersect</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">intersect(ss1::SquareSet, ss2::SquareSet)
∩(ss1::SquareSet, ss2::SquareSet)</code></pre><p>Compute the intersection of two square sets.</p><p>The binary operator <code>∩</code> can be used instead of the named function.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; SS_FILE_D ∩ SS_RANK_7
SquareSet:
 -  -  -  -  -  -  -  -
 -  -  -  #  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL354-L376">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:-" href="#Base.:-"><code>Base.:-</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">-(ss::SquareSet)</code></pre><p>The complement of a square set.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ss = SquareSet(SQ_C4);

julia&gt; SQ_C4 ∈ ss
true

julia&gt; SQ_D4 ∈ ss
false

julia&gt; SQ_C4 ∈ -ss
false

julia&gt; SQ_D4 ∈ -ss
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL382-L404">source</a><div><div><pre><code class="language-none">setdiff(ss1::SquareSet, ss2::SquareSet)
-(ss1::SquareSet, ss2::SquareSet)</code></pre><p>The set of all squares that are in <code>ss1</code>, but not in <code>ss2</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; SquareSet(SQ_A1, SQ_A2, SQ_A3, SQ_B1, SQ_B2, SQ_B3) - SS_RANK_2
SquareSet:
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 #  #  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 #  #  -  -  -  -  -  -</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL410-L430">source</a><div><div><pre><code class="language-none">-(ss::SquareSet, s::Square)</code></pre><p>Remove a square from a square set.</p><p>If a non-member square is removed, the set is returned unchanged.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; SquareSet(SQ_A1, SQ_B1) - SQ_B1 == SquareSet(SQ_A1)
true

julia&gt; SS_FILE_A - SQ_H8 == SS_FILE_A
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL463-L479">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:+" href="#Base.:+"><code>Base.:+</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">+(ss::SquareSet, s::Square)</code></pre><p>Add a square to a square set.</p><p>If a square is added that is already a member is added to the set, the set is returned unchanged.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; SquareSet(SQ_A1) + SQ_H8 == SquareSet(SQ_A1, SQ_H8)
true

julia&gt; SS_FILE_A + SQ_A1 == SS_FILE_A
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL440-L457">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.issubset" href="#Base.issubset"><code>Base.issubset</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">issubset(ss1::SquareSet, ss2::SquareSet)
⊆(ss1::SquareSet, ss2::SquareSet)</code></pre><p>Determine whether <code>ss1</code> is a subset of <code>ss2</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; SquareSet(SQ_A1, SQ_A2) ⊆ SS_FILE_A
true

julia&gt; SquareSet(SQ_A1, SQ_B1) ⊆ SS_FILE_A
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL485-L500">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.toarray" href="#Chess.toarray"><code>Chess.toarray</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">toarray(ss::SquareSet)</code></pre><p>Convert a square set to a two-dimensional array.</p><p>The returned array&#39;s columns corresponds to the files, and the rows to the ranks. The array entries are 1 for the members of the square set, and 0 for non-members.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; toarray(SS_FILE_C ∪ SS_RANK_5)
8×8 Array{Int64,2}:
 0  0  1  0  0  0  0  0
 0  0  1  0  0  0  0  0
 0  0  1  0  0  0  0  0
 1  1  1  1  1  1  1  1
 0  0  1  0  0  0  0  0
 0  0  1  0  0  0  0  0
 0  0  1  0  0  0  0  0
 0  0  1  0  0  0  0  0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL525-L548">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.squarecount" href="#Chess.squarecount"><code>Chess.squarecount</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">squarecount(ss::SquareSet)</code></pre><p>The number of members of a square set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL555-L559">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.first" href="#Base.first"><code>Base.first</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">first(ss::SquareSet)</code></pre><p>The first square in a square set.</p><p>Returns SQ_NONE for an empty square set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL565-L571">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.removefirst" href="#Chess.removefirst"><code>Chess.removefirst</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">removefirst(ss::SquareSet)</code></pre><p>Remove the first member of a square set.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; removefirst(SquareSet(SQ_A4, SQ_D5, SQ_F6)) == SquareSet(SQ_D5, SQ_F6)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL577-L588">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.issingleton" href="#Chess.issingleton"><code>Chess.issingleton</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">issingleton(ss::SquareSet)</code></pre><p>Determine whether <code>ss</code> contains exactly one square.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; issingleton(SquareSet(SQ_D5))
true

julia&gt; issingleton(SquareSet(SQ_D5, SQ_C5))
false

julia&gt; issingleton(SS_EMPTY)
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL594-L611">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.onlyfirst" href="#Chess.onlyfirst"><code>Chess.onlyfirst</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">onlyfirst(ss::SquareSet)</code></pre><p>Return a square set with all squares excep the first removed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; onlyfirst(SquareSet(SQ_A4, SQ_D5, SQ_F6)) == SquareSet(SQ_A4)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL617-L628">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.shift_n" href="#Chess.shift_n"><code>Chess.shift_n</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">shift_n(ss::SquareSet)</code></pre><p>Shift the square set one step in the &#39;north&#39; direction.</p><p>Squares that are shifted off the edge of the board disappear.</p><pre><code class="language-julia-repl">julia&gt; shift_n(SS_RANK_2) == SS_RANK_3
true

julia&gt; shift_n(SquareSet(SQ_D3, SQ_E4, SQ_F8)) == SquareSet(SQ_D4, SQ_E5)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL672-L686">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.shift_s" href="#Chess.shift_s"><code>Chess.shift_s</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">shift_s(ss::SquareSet)</code></pre><p>Shift the square set one step in the &#39;south&#39; direction.</p><p>Squares that are shifted off the edge of the board disappear.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; shift_s(SS_RANK_3) == SS_RANK_2
true

julia&gt; shift_s(SquareSet(SQ_C3, SQ_D2, SQ_E1)) == SquareSet(SQ_C2, SQ_D1)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL692-L708">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.shift_e" href="#Chess.shift_e"><code>Chess.shift_e</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">shift_e(ss::SquareSet)</code></pre><p>Shift the square set one step in the &#39;east&#39; direction.</p><p>Squares that are shifted off the edge of the board disappear.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; shift_e(SS_FILE_F) == SS_FILE_G
true

julia&gt; shift_e(SquareSet(SQ_F5, SQ_G6, SQ_H7)) == SquareSet(SQ_G5, SQ_H6)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL714-L730">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.shift_w" href="#Chess.shift_w"><code>Chess.shift_w</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">shift_w(ss::SquareSet)</code></pre><p>Shift the square set one step in the &#39;west&#39; direction.</p><p>Squares that are shifted off the edge of the board disappear.</p><pre><code class="language-julia-repl">julia&gt; shift_w(SS_FILE_C) == SS_FILE_B
true

julia&gt; shift_w(SquareSet(SQ_C5, SQ_B6, SQ_A7)) == SquareSet(SQ_B5, SQ_A6)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL736-L750">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.pawnshift_n" href="#Chess.pawnshift_n"><code>Chess.pawnshift_n</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">pawnshift_n(ss::SquareSet)</code></pre><p>Shift a square set of pawns one step in the &#39;north&#39; direction.</p><p>This is identical to the <code>shift_n</code> function except that <code>pawnshift_n</code> is a little faster, but will not work for square sets containing squares on the 1st or 8th rank.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL756-L764">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.pawnshift_s" href="#Chess.pawnshift_s"><code>Chess.pawnshift_s</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">pawnshift_s(ss::SquareSet)</code></pre><p>Shift a square set of pawns one step in the &#39;south&#39; direction.</p><p>This is identical to the <code>shift_s</code> function except that <code>pawnshift_s</code> is a little faster, but will not work for square sets containing squares on the 1st or 8th rank.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL770-L778">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.pawnshift_nw" href="#Chess.pawnshift_nw"><code>Chess.pawnshift_nw</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">pawnshift_nw(ss::SquareSet)</code></pre><p>Shift a square set of pawns one step in the &#39;north west&#39; direction.</p><p>This is identical to calling <code>shift_n</code> followed by <code>shift_w</code>, except that <code>pawnshift_nw</code> is a little faster, but will not work for square sets containing squares on the 1st or 8th rank.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL784-L792">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.pawnshift_ne" href="#Chess.pawnshift_ne"><code>Chess.pawnshift_ne</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">pawnshift_ne(ss::SquareSet)</code></pre><p>Shift a square set of pawns one step in the &#39;north east&#39; direction.</p><p>This is identical to calling <code>shift_n</code> followed by <code>shift_e</code>, except that <code>pawnshift_ne</code> is a little faster, but will not work for square sets containing squares on the 1st or 8th rank.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL798-L806">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.pawnshift_sw" href="#Chess.pawnshift_sw"><code>Chess.pawnshift_sw</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">pawnshift_sw(ss::SquareSet)</code></pre><p>Shift a square set of pawns one step in the &#39;south west&#39; direction.</p><p>This is identical to calling <code>shift_s</code> followed by <code>shift_w</code>, except that <code>pawnshift_sw</code> is a little faster, but will not work for square sets containing squares on the 1st or 8th rank.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL812-L820">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.pawnshift_se" href="#Chess.pawnshift_se"><code>Chess.pawnshift_se</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">pawnshift_se(ss::SquareSet)</code></pre><p>Shift a square set of pawns one step in the &#39;south east&#39; direction.</p><p>This is identical to calling <code>shift_s</code> followed by <code>shift_e</code>, except that <code>pawnshift_se</code> is a little faster, but will not work for square sets containing squares on the 1st or 8th rank.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL826-L834">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.pawnattacks" href="#Chess.pawnattacks"><code>Chess.pawnattacks</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">pawnttacks(c::PieceColor, s::square)</code></pre><p>the set of squares attacked by a pawn of color <code>c</code> on the square <code>s</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL930-L934">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.knightattacks" href="#Chess.knightattacks"><code>Chess.knightattacks</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">knightattacks(s::Square)</code></pre><p>The set of squares attacked by a knight on the square <code>s</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL910-L914">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.bishopattacks-Tuple{SquareSet,Square}" href="#Chess.bishopattacks-Tuple{SquareSet,Square}"><code>Chess.bishopattacks</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">bishopattacks(blockers::SquareSet, s::Square)</code></pre><p>The squares attacked by a bishop on <code>s</code>, with <code>blockers</code> being the occupied squares.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL840-L845">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.bishopattacksempty" href="#Chess.bishopattacksempty"><code>Chess.bishopattacksempty</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">bishopattacksempty(s::Square)</code></pre><p>The set of squares a bishop on <code>s</code> would attack on an otherwise empty board.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL954-L958">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.rookattacks-Tuple{SquareSet,Square}" href="#Chess.rookattacks-Tuple{SquareSet,Square}"><code>Chess.rookattacks</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rookattacks(blockers::SquareSet, s::Square)</code></pre><p>The squares attacked by a rook on <code>s</code>, with <code>blockers</code> being the occupied squares.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL851-L856">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.rookattacksempty" href="#Chess.rookattacksempty"><code>Chess.rookattacksempty</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">rookattacksempty(s::Square)</code></pre><p>The set of squares a rook on <code>s</code> would attack on an otherwise empty board.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL964-L968">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.queenattacks-Tuple{SquareSet,Square}" href="#Chess.queenattacks-Tuple{SquareSet,Square}"><code>Chess.queenattacks</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">queenattacks(blockers::SquareSet, s::Square)</code></pre><p>The squares attacked by a queen on <code>s</code>, with <code>blockers</code> being the occupied squares.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL862-L867">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.queenattacksempty" href="#Chess.queenattacksempty"><code>Chess.queenattacksempty</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">queenattacksempty(s::Square)</code></pre><p>The set of squares a queen on <code>s</code> would attack on an otherwise empty board.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL974-L978">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.kingattacks" href="#Chess.kingattacks"><code>Chess.kingattacks</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">kingattacks(s::square)</code></pre><p>the set of squares attacked by a king on the square <code>s</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL920-L924">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.squaresbetween" href="#Chess.squaresbetween"><code>Chess.squaresbetween</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">squaresbetween(s1::Square, s2::Square)</code></pre><p>The set of squares on the line, file or diagonal between <code>s1</code> and <code>s2</code>.</p><p>When a queen on <code>s1</code> would attack <code>s2</code> on an otherwise empty board, this function returns the set of squares where a piece would block the queen on <code>s1</code> from attacking <code>s2</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; squaresbetween(SQ_A4, SQ_D4) == SquareSet(SQ_B4, SQ_C4)
true

julia&gt; squaresbetween(SQ_F7, SQ_A2)
SquareSet:
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  #  -  -  -
 -  -  -  #  -  -  -  -
 -  -  #  -  -  -  -  -
 -  #  -  -  -  -  -  -
 -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL1007-L1033">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.pprint-Tuple{SquareSet}" href="#Chess.pprint-Tuple{SquareSet}"><code>Chess.pprint</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">pprint(ss::SquareSet)</code></pre><p>Pretty-print a square set to the standard output.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL1058-L1062">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.filesquares" href="#Chess.filesquares"><code>Chess.filesquares</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">filesquares(f::SquareFile)</code></pre><p>The set of all squares on the provided file.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; filesquares(FILE_G) == SS_FILE_G
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL269-L280">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.ranksquares" href="#Chess.ranksquares"><code>Chess.ranksquares</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">ranksquares(r::SquareRank)</code></pre><p>The set of all squares on the provided rank.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ranksquares(RANK_2) == SS_RANK_2
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL286-L297">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.SS_EMPTY" href="#Chess.SS_EMPTY"><code>Chess.SS_EMPTY</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">SS_EMPTY</code></pre><p>An empty square set, containing no squares.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL122-L126">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.SS_FILE_A" href="#Chess.SS_FILE_A"><code>Chess.SS_FILE_A</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">SS_FILE_A</code></pre><p>The square set containing all the squares along the A file.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL130-L134">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.SS_FILE_B" href="#Chess.SS_FILE_B"><code>Chess.SS_FILE_B</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">SS_FILE_B</code></pre><p>The square set containing all the squares along the B file.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL138-L142">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.SS_FILE_C" href="#Chess.SS_FILE_C"><code>Chess.SS_FILE_C</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">SS_FILE_C</code></pre><p>The square set containing all the squares along the C file.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL146-L150">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.SS_FILE_D" href="#Chess.SS_FILE_D"><code>Chess.SS_FILE_D</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">SS_FILE_D</code></pre><p>The square set containing all the squares along the D file.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL154-L158">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.SS_FILE_E" href="#Chess.SS_FILE_E"><code>Chess.SS_FILE_E</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">SS_FILE_E</code></pre><p>The square set containing all the squares along the E file.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL162-L166">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.SS_FILE_F" href="#Chess.SS_FILE_F"><code>Chess.SS_FILE_F</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">SS_FILE_F</code></pre><p>The square set containing all the squares along the F file.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL170-L174">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.SS_FILE_G" href="#Chess.SS_FILE_G"><code>Chess.SS_FILE_G</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">SS_FILE_G</code></pre><p>The square set containing all the squares along the G file.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL178-L182">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.SS_FILE_H" href="#Chess.SS_FILE_H"><code>Chess.SS_FILE_H</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">SS_FILE_H</code></pre><p>The square set containing all the squares along the H file.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL186-L190">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.SS_RANK_1" href="#Chess.SS_RANK_1"><code>Chess.SS_RANK_1</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">SS_RANK_1</code></pre><p>The square set containing all the squares along the 1st rank.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL194-L198">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.SS_RANK_2" href="#Chess.SS_RANK_2"><code>Chess.SS_RANK_2</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">SS_RANK_2</code></pre><p>The square set containing all the squares along the 2nd rank.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL202-L206">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.SS_RANK_3" href="#Chess.SS_RANK_3"><code>Chess.SS_RANK_3</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">SS_RANK_3</code></pre><p>The square set containing all the squares along the 3rd rank.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL210-L214">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.SS_RANK_4" href="#Chess.SS_RANK_4"><code>Chess.SS_RANK_4</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">SS_RANK_4</code></pre><p>The square set containing all the squares along the 4th rank.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL218-L222">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.SS_RANK_5" href="#Chess.SS_RANK_5"><code>Chess.SS_RANK_5</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">SS_RANK_5</code></pre><p>The square set containing all the squares along the 5th rank.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL226-L230">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.SS_RANK_6" href="#Chess.SS_RANK_6"><code>Chess.SS_RANK_6</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">SS_RANK_6</code></pre><p>The square set containing all the squares along the 6th rank.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL234-L238">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.SS_RANK_7" href="#Chess.SS_RANK_7"><code>Chess.SS_RANK_7</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">SS_RANK_7</code></pre><p>The square set containing all the squares along the 7th rank.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL242-L246">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Chess.SS_RANK_8" href="#Chess.SS_RANK_8"><code>Chess.SS_RANK_8</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">SS_RANK_8</code></pre><p>The square set containing all the squares along the 8th rank.</p></div></div><a class="source-link" target="_blank" href="https://github.com/romstad/Chess.jl/blob/9175ed185bed2abd90404e98e8e619b98b841ab8/src/squareset.jl#LL250-L254">source</a></section><footer><hr/><a class="previous" href="../manual/"><span class="direction">Previous</span><span class="title">User Guide</span></a><a class="next" href="../api-index/"><span class="direction">Next</span><span class="title">Index</span></a></footer></article></body></html>
